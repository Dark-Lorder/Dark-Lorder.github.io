<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cloud-Native</title>
    <link href="/2023/07/31/Cloud-Native/"/>
    <url>/2023/07/31/Cloud-Native/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iPhone今天这个大漏洞，让人打开App就被盗刷一万五。。。</title>
    <link href="/2023/07/24/Spend-money-to-buy-lessons/"/>
    <url>/2023/07/24/Spend-money-to-buy-lessons/</url>
    
    <content type="html"><![CDATA[<p>微信零钱每日限额一万，微笑</p><span id="more"></span><p>众所周知，苹果一直在宣传自己的安全、隐私、可控。</p><p>而且在过去，它也足够的安全。</p><p>但世界上也没有绝对坚固的墙，大家也别因为这样，就彻底放松警惕。</p><p>因为今天，它就翻车了。。。</p><center><img src="https://img.darklorder.com/img/202307311242237.gif"  alt="文件名" style="zoom:100%;" /></center><p>事情是这样的，一个网友的丈母娘被 App Store 应用商店里的 “骗子 App” 骗走了一万五千元。</p><p>直到目前，他们被盗刷的钱都没能追回。</p><p>而我在复盘完事情的完整经过之后发现，其中两个重要环节，都是苹果出现了问题。</p><p>但凡苹果在这两个环节中的任何一个环节有安全措施，也不至于让骗子得逞。</p><p>先跟大家聊聊大概发生了什么事吧，大家可以先看看原博主 airycanon 描述的事情经过~</p><p>上下滑动可以查看完整长图</p><p><a href="https://img.darklorder.com/img/202307311319978.jpg">图片</a></p><p>简单来说，就是 airycanon 的丈母娘从 AppStore 应用商店里下载了一个菜谱 App。</p><p>但是这个 App 本身有问题，打开 App 之后，首先会弹出一个 Apple 账号登录界面。</p><img src="https://img.darklorder.com/img/202307311248469.png"/><p>用过 iPhone 的小伙伴都知道，不少 App 都支持使用苹果账号一键注册登录，就像微信小程序一键登录一样。</p><p><strong>所以这一步看起来是合理的。</strong></p><p>但其实，真正的苹果一键登录界面，是这个样子的：</p><p>大家可以上下对比看看</p><img src="https://img.darklorder.com/img/202307311248753.png"/><p>菜谱 App 弹出的那个“假登录界面”，其实也是有用的，<strong>它在后台已经完成了一次苹果账号登录。</strong></p><p>至于有什么用途，我们放到后面再说。</p><p>登录弹窗之后，这个 App 又弹出一个仿照系统界面设计的密码输入界面。</p><p>因为长得和安装应用时候的密码验证界面很像，手机用的不那么灵光的老人还是很容易中招的。</p><p>App”L”eID。。。</p><img src="https://img.darklorder.com/img/202307311249332.png"/><p>自此，骗子就搞到了受害者 iPhone 的账号和密码。</p><p>假如用户给苹果账号绑定了支付方式 —— 就比如 airycanon 的丈母娘绑定了微信免密支付。。。</p><p>那骗子就可以开始盗号刷刷刷了。</p><p>u1s1，这个骗子绝对是个惯犯。<strong>他为了避免受害人收到短信交易提醒，盗刷之前甚至还利用查找 iPhone 远程把受害者的手机给重置恢复出厂设置了。。。</strong></p><p>这要是没用 iCloud 备份相册的人，不得气疯了。。。</p><p><strong>真·砂仁猪心。</strong></p><p>OK，事情大概就是这么一回事，讲道理，看完之后我整个人就是一个大写的懵。</p><p>首先，我倒是理解这种骗人 App 能堂而皇之在苹果官方 App Store 上架。。。</p><p><strong>因为骗过苹果商店审核的操作在业内根本不算什么秘密。</strong></p><p>马甲包、同 ID 双版本、幸运按钮。。。黑产总有办法。</p><img src="https://img.darklorder.com/img/202307311250825.png"/><p>比如我也在 App Store 里下载了几个菜谱大全，他们倒是没有盗我的密码，但是点开以后也都不是菜谱。</p><p><strong>而是一个个关不掉的强制弹窗，“ 帮 ” 我开各种彩铃包、权益合约包。。。</strong></p><img src="https://img.darklorder.com/img/202307311250766.png"/><p>难得遇到了一个正经菜谱 App，结果刚看了两个菜，就要收我 28。。。</p><p><strong>不对，是每周 28 块钱。。。</strong></p><p>我估计正经厨房类 App 的产品经理们都得看傻了：同行们黑心钱都这么好赚的吗？</p><p>“ 非强制消费”</p><img src="https://img.darklorder.com/img/202307311250241.png"/><p>但是，就算 App 能通过钓鱼的方式骗到受害者苹果账户的密码，但是苹果本身是有 “ 两步验证 ” 机制的呀？</p><p>在登录新设备或者浏览器的时候，除了输入密码，苹果还会要求输入一个短信验证码。</p><p>而且 airycanon 也在帖子里说明了，他丈母娘的 Apple ID 已经开启了两步验证。</p><p>但是他们自始至终没有收到苹果的验证码。</p><img src="https://img.darklorder.com/img/202307311251965.png"/><p>这时候他发现，<strong>丈母娘账号的两步验证设置里，多出来了一个从来没见过的境外号码。</strong></p><p>怪不得自己手机上没有验证码了，<strong>因为接收验证码的手机已经变成骗子的手机了。。。</strong></p><p>考虑到设置两步验证是一个挺复杂的操作、即使手把手跟丈母娘说都不一定能设置成功。</p><p>那这个号码只能是骗子偷偷添加进来的了。。。</p><img src="https://img.darklorder.com/img/202307311251618.png"/><p>这就很离谱了好吧，因为虽然“菜谱骗子”们骗过了苹果的 App 审核，<strong>但它们最多也只是诈骗，是在玩弄社会工程学，而不是病毒。</strong></p><p><strong>理论上来说，它们根本没有办法绕过苹果最根本的安全措施，在不弹任何验证码的情况下往苹果的双证验证系统里加入<strong><strong>能收验证码的新手机号</strong></strong>。。。</strong></p><p>这一点是我和编辑部小伙伴们都感觉非常诧异的，也是今天关注到这件事的网友们讨论最激烈的。</p><p>不过在一段讨论之后，研究苹果开发的 BugOS 技术组提到了一种可能的思路：</p><img src="https://img.darklorder.com/img/202307311252605.png"/><p>上面截图里的内容大家看不懂没关系，简单来说，<strong>苹果浏览器框架的安全策略出了问题。</strong></p><p>事情大概是这么回事：我们都知道，不管是 iPhone，还是安卓手机，系统里都会有一个预装的默认网页浏览器对不对。</p><img src="https://img.darklorder.com/img/202307311252308.png"/><p>比如 iPhone 上就是 Safiri，安卓这边则是各家的自带浏览器。</p><p>但这其实只是表面上的浏览器。</p><p>但其实，<strong>再往系统底层找，还有一个“没有图标”的浏览器框架：WebView。</strong></p><img src="https://img.darklorder.com/img/202307311252723.png"/><p>这个 “ 浏览器框架 ” 不能被普通用户在手机里直接点开，它存在的意义，是供其他 App 调用的。</p><p>我们举个例子，就比方说美团、滴滴他们经常在 App 里搞领券的活动，对于这种临时的活动页面一般就是写个网页。</p><img src="https://img.darklorder.com/img/202307311253933.png"/><p>这些 “ App 内的网页 ”，实际上都不是 App 本身在渲染，而是美团和滴滴拉起了系统里的 WebView 组件来进行渲染的。</p><p>这个组件其实帮了开发者很大的忙，假如没有 WebView 浏览器框架的话，包括美团和滴滴在内的所有 App 开发者，都得往 App 里再额外集成一个独立的浏览器内核。</p><p>本身现在的 App 们就已经很占存储空间了，要是一人再背一个 Chrome。。。</p><p>画面太美了，我不敢想！</p><p>另外，作为网络世界的窗口，浏览器漏洞本身也是很多黑客行为的突破口。</p><p>系统本身提供一个全局自动更新的浏览器框架，也可以避免一些 App 不更新内置的浏览器内核，导致黑客趁虚而入。</p><p><strong>这次的问题，恰恰就出在这个 “为了不出问题” 而设计的系统级浏览器框架上。</strong></p><p>不知道大家有没有体验过系统浏览器的 “<strong>便捷单点登录</strong>” 功能。</p><p>就比方说，假如你在 Windows 电脑上使用自带的 Edge 浏览器打开微软账户官网，Edge 浏览器不会让你输入微软账户的账号密码。</p><p>而是会自动读取当前电脑里登录的微软账户，然后帮你在浏览器网站里完成登录。</p><img src="https://img.darklorder.com/img/202307311253625.png"/><p>假如你在登录了谷歌账号的安卓手机上使用谷歌 Chrome 浏览器，它也会自动帮你完成登录操作。</p><img src="https://img.darklorder.com/img/202307311254951.png"/><p>苹果也是如此，假如你在 Safari 浏览器里打开 Apple ID 官网，并点击登录。</p><p>浏览器也不会让你输入密码，而是直接弹出来一个登陆操作的确认框。</p><img src="https://img.darklorder.com/img/202307311254573.gif"/><p>假如你点了 “ 继续 ”，得益于高性能的苹果 A16 处理器，系统会光速弹出 Face ID 验证。</p><p>一个眨眼的功夫，就登录成功了。</p><img src="https://img.darklorder.com/img/202307311255122.png"/><p>诶，等会儿。。。</p><p><strong>这个登陆框，怎么有点儿眼熟啊？？？</strong></p><p><strong>为什么 “ 菜谱大全 ” 会请求登录 Apple ID 官网啊？？？</strong></p><img src="https://img.darklorder.com/img/202307311255195.png"/><p>说真的，假如没有对比的话，菜谱大全的操作很容易会被大家当成是普通的 “ 一键注册账号 ” ——</p><p>包括发帖的 airycanon 也没反应过来，以为是丈母娘没有选苹果的隐私邮箱登录选项才暴露了 Apple ID，让黑客掌握了信息。</p><p>真正的一键注册环节会要求选择是否隐藏邮件地址</p><img src="https://img.darklorder.com/img/202307311256034.png"/><p>实际上，当这个确认窗验证完毕之后，骗子都已经准备好往账号里加料了。。。</p><img src="https://img.darklorder.com/img/202307311256164.png"/><p>“ 菜谱大全 ” 之所以能够一键登录，恰恰就是利用了 WebView 这个系统级浏览器框架的 “ 便捷登录 ” 特性。</p><p>表面上，是一个菜谱 App，<strong>而在它的内部，隐藏了一个正在访问 Apple ID 官网、并准备篡改用户接收验证短信手机号的浏览器界面。</strong></p><p>我后来看 BugOS 技术组又发了一个微博，他们已经用自己写的代码还原完整个攻击过程了。</p><img src="https://img.darklorder.com/img/202307311256161.png"/><p>按照苹果 Apple ID 官网目前的安全逻辑，<strong>只有一开始的账号登录环节需要下发验证码做双重验证。</strong></p><p>而这最开始的一步，骗子已经通过 WebKit 的便捷登录绕过去了。</p><p><strong>已经处于登录状态的情况下，只要输固定的账号密码，就可以直接添加新的验证手机了。</strong></p><img src="https://img.darklorder.com/img/202307311257506.gif"/><p>现在相信大家已经彻底搞明白背后是怎么一回事儿了，这时候我们再重新回看故事的全貌：</p><p>“ 菜谱大全 ” 先是在表层界面的下面，隐藏了一个 WebView 浏览器组件，然后利用它系统级的 “便捷登录” 能力，进入了 Apple ID 官网。</p><p>接着，它给用户弹出了一个密码输入框，用来搞定添加验证手机的最后一步障碍。</p><img src="https://img.darklorder.com/img/202307311258021.png"/><p>拿到密码之后，App 就会偷偷跑起添加新验证手机的自动脚本，这时候受害者的苹果账号就已经不属于自己了。</p><p>什么时候发起攻击，全看黑客心情了。</p><p>OK，复盘完毕，这么一看好像还是受害者太傻，平白无故把密码交出来了对不对 —— 假如受害者打死不填密码，黑客也没招。</p><p>我们不应该骂苹果对不对？</p><p>emmmm，在下这个结论之前，我想先带大家看一看苹果的老对手 —— 谷歌是怎么做的。</p><img src="https://img.darklorder.com/img/202307311258470.png"/><p>和苹果 Apple ID 一样，只要已经处于登录状态了，谷歌这边的账号系统要想添加新的验证手机，也只是输一下固定密码的事。</p><p><strong>但是和苹果不同，谷歌根本不允许系统的 WebView 组件使用 “便捷登录” 技术。</strong></p><p>我在自己的安卓手机上做了个小测试，分别使用谷歌 Chrome 浏览器和 Via 浏览器（ 一款直接调用系统 WebView 框架的极简浏览器 App ）访问谷歌账号官网。</p><p>Chrome 浏览器因为已经获取了系统里的账号登录状态，因此直接就登录了。</p><p>Via 浏览器则没有这个能力，需要一步步重新输入账号、密码、验证码。</p><img src="https://img.darklorder.com/img/202307311259604.png"/><p>换句话说，假如有骗子想在安卓手机上做一个同样套路的事，第一步就卡住了。。。</p><p>但是在苹果系统里，不管是调用 WebView 的 Via，还是真正的自带浏览器 Safari，<strong>都能调用便捷登录。</strong></p><p>再搭配上 App Store 的审核漏洞，一锅好菜就出炉了。。。</p><img src="https://img.darklorder.com/img/202307311259869.png"/><p>严格来说，这对于 iOS 系统来说也算是一个漏洞 —— 它不是代码漏洞，而是一个逻辑漏洞。</p><p>骗子利用苹果开放的便捷登录能力，伪装了自己一波，再利用一点点社工技巧，就把钱骗到手了。</p><p>由于系统逻辑漏洞造成的问题，正确的解决方式应该是着手准备 OTA 补丁，同时帮着受骗的用户追回损失。</p><p>不过苹果给这个受害者带来的感知，并不是很好。。。</p><img src="https://img.darklorder.com/img/202307311259025.png"/><p>可能现在时间还比较短，希望苹果后续可以帮这个受害者妥善解决。</p><p><strong>不瞒大家说，本来我今天是没打算写这篇文章的。</strong></p><p>因为真要细究的话，安卓这边虽然把 WebView 的洞补上了，但是其他的漏洞更多、骗人的方式根本数不过来。</p><p>苹果生态总体来说都还是更安全的、让人用着更放心的，但是大家不要因为它 “安全” 的标签就变得麻木、不重视安全了。</p><p>就像大家都说沃尔沃安全，但你不能因为这点就不握着方向盘了。。。</p><p>相信很多给家长买 iPhone 的小伙伴，都是希望家长尽可能不被骗。</p><p>但我觉得，我们还是要告诉他们即便是 iPhone，即便是 App Store，也不能保证绝对安全。</p><p>不随便输密码、不给所有 App 用一模一样的密码是最后的底线。</p><p><strong>千万记得叮嘱他们，免密支付能不开就不开。</strong> <strong>如果开了的话，免密支付的卡里面也不要放太多的钱。</strong></p><p><a href="https://mp.weixin.qq.com/s/G55w5UakMUcuhWyUPaHFYQ">文章来源于iPhone今天这个大漏洞，让人打开App就被盗刷一万五。。。</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作为了生活，生活不是为了工作</title>
    <link href="/2023/01/04/Life-and-work/"/>
    <url>/2023/01/04/Life-and-work/</url>
    
    <content type="html"><![CDATA[<p><strong>乐视认为,生活绝不是为了更好地工作,但工作一定是为了更好地生活。</strong></p><span id="more"></span><p>这几天有几个朋友向我诉苦，</p><p>想换份工作。</p><p>而我只做过一份工作，</p><p>感觉没资格提意见。</p><p>如果真的要我说，</p><p>我希望你可以做自己擅长做的事，</p><p>其次也要做一份自己喜欢做的事，</p><p>碰巧你擅长做的也是你喜欢做的事，</p><p>那我为你感到庆幸。</p><p>工作为了生活，生活不是为了工作。</p><p>Recently some closed friends complained to me about changing their jobs.</p><p>But I am not qualified to comment due to I never change jobs before.</p><p>It is my little tips below:</p><p>First I hope you could do the jobs you are good at,</p><p>Secondly I hope you could do the jobs you like.</p><p>You will be lucky if the jobs you good at is same jobs you like.</p><p>Enjoy your work, enjoy you life.</p><p><strong>转载来源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>走在自己的时区里</title>
    <link href="/2023/01/01/walk-in-your-own-time-zone/"/>
    <url>/2023/01/01/walk-in-your-own-time-zone/</url>
    
    <content type="html"><![CDATA[<p><strong>美国的一首小诗</strong></p><span id="more"></span><p>在时间上，纽约走在加州前面三个小时，</p><p>New York is 3 hours ahead of California,</p><p>但加州并没有变慢。</p><p>but it does not make California slow.</p><p>有人22岁就毕业了，</p><p>Someone graduated at the age of 22,</p><p>但等了五年才找到好工作！</p><p>but waited 5 years before securing a good job!</p><p>有人25岁就当上了CEO，</p><p>Someone became a CEO at 25,</p><p>却在50岁去世了。</p><p>and died at 50.</p><p>也有人直到50岁才当上CEO，</p><p>While another became a CEO at 50,</p><p>最后活到90岁。</p><p>and lived to 90 years.</p><p>有人依然单身，</p><p>Someone is still single,</p><p>而别人却早已结婚。</p><p>while someone else got married.</p><p>奥巴马55岁退任总统，</p><p>Obama retires at 55,</p><p>而川普却是70岁才开始当。</p><p>but Trump starts at 70.</p><p>世上每个人都有自己的发展时区。</p><p>Absolutely everyone in this world works based on their Time Zone.</p><p>身边有些人看似走在你前面，</p><p>People around you might seem to go ahead of you,</p><p>也有人看似走在你后面。</p><p>some might seem to be behind you.</p><p>但其实每个人在自己的时区有自己的步程。</p><p>But everyone is running their own RACE, in their own TIME.</p><p>不用嫉妒或嘲笑他们。</p><p>Don’t envy them or mock them.</p><p>他们都在自己的时区，你在你的！</p><p>They are in their TIME ZONE, and you are in yours!</p><p>生命就是等待正确的时机行动。</p><p>Life is about waiting for the right moment to act.</p><p>所以，放轻松。</p><p>So, RELAX.</p><p>你没有落后，</p><p>You’re not LATE.</p><p>你没有领先。</p><p>You’re not EARLY.</p><p>在命运为你安排的属于你自己的时区里，一切都非常准时。</p><p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p><p><strong>转载来源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云原生 2.0 白皮书</title>
    <link href="/2022/10/01/Cloud-native-white-paper/"/>
    <url>/2022/10/01/Cloud-native-white-paper/</url>
    
    <content type="html"><![CDATA[<p>企业 IT 建设的三阶段两转变，进入云原生阶段</p><span id="more"></span><p>简单来看，企业 IT 建设所依赖的基础资源经历了从服务器到云化资源的发展历程，正在快速进入云原生阶段。</p><p>服务器阶段 ：其特点是以硬件设备为中心，业务应用随不同厂商设备、操作系统、虚拟化软件的差异化进行定制；设备的安装、调试，应用的部署、运维基本靠人力完成，自动化程度低，缺乏统一的设备和应用管理能力。后期随着虚拟化软件的出现，资源的利用率、扩缩容器的灵活性方面得到一定的提升，但并未从根本上解决基础设施与软件割裂、运维复杂的难题。</p><p>云化阶段：传统模式下分布离散的设备，被统一起来，实现了各类资源如计算、存储、网络的池化，通过统一的虚拟化软件平台，为上层业务软件提供统一的资源管理接口，实现资源管理能力的自动化，屏蔽一部分基础设施的差异，使得应用的通用性增强，但因为虚拟化软件平台差异化较大，尤其是各厂商的一些商业化增强，无法在厂商间进行能力共享，应用还是无法以完全标准化的模式构建，应用部署还是以资源为中心。</p><p>云原生阶段：在这一阶段，企业的关注点从以资源为中心转移到以应用为中心，包括应用敏捷交付、快速弹性、平滑迁移、无损容灾等。因此，企业开始考虑如何将基础设施与业务平台融合，为业务应用提供标准的运行、监控、治理平台，并将业务的通用能力下沉到平台侧，更好的帮助企业实现应用的自动化。</p><p><strong>企业IT数字化转型的“三阶段两转变”</strong></p><img src="https://img.darklorder.com/img/202307311440454.png"/><p><strong>转载来源于&lt;&lt;云原生2.0白皮书&gt;&gt;</strong></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式计算中的八大谬论</title>
    <link href="/2022/10/01/The-Eight-Fallacies-of-Distributed-Computing/"/>
    <url>/2022/10/01/The-Eight-Fallacies-of-Distributed-Computing/</url>
    
    <content type="html"><![CDATA[<p>分布式计算中的八大谬论</p><span id="more"></span><img src="https://img.darklorder.com/img/202307070417934.jpeg"/><p>构建分布式系统是一项复杂的工作。架构，设计，编码和测试对分布式系统的成功都至关重要。任何一点的失败都可能导致性能下降，故障频发，费用超标以及最终导致客户流失。在20世纪90年代Sun Microsystems的Peter Deutsch，James Gosling和其他人总结出了分布式计算的八个谬论。随着时间的推移，IT人员对这些谬论的认识可能已经消退，所以想要提醒下大家。</p><h3 id="八大谬论是："><a href="#八大谬论是：" class="headerlink" title="八大谬论是："></a><strong>八大谬论是：</strong></h3><p><strong>网络可靠。 The network is reliable.</strong><br><strong>延迟为零。 Latency is zero.</strong><br><strong>带宽是无限的。 Bandwidth is infinite.</strong><br><strong>网络是安全的。 The network is secure.</strong><br><strong>拓扑不会改变。 Topology doesn’t change.</strong><br><strong>只有一个管理员。 There is one administrator.</strong><br><strong>运输成本为零。 Transport cost is zero.</strong><br><strong>网络是同质的。The network is homogeneous.</strong></p><h4 id="网络可靠"><a href="#网络可靠" class="headerlink" title="网络可靠"></a>网络可靠</h4><p>在局域内，网络可能看起来坚如磐石。毕竟，现在网络组件多久失败一次？即使单个组件发生故障，也确实存在大量冗余？那么，随着网络变得越来越复杂，网络管理就越容易出错，大多数都是配置错误。在某些情况下，多达三分之一的网络更改会导致影响网络可靠性的错误。软件和硬件都可能出现故障，尤其是路由器，它们占所有故障的四分之一左右。“不间断”电源也可能会中断，人们可能会发生不明智的设备配置更改，并且可能存在网络拥塞，拒绝服务（DoS）攻击以及软件和固件升级或修补程序失败。网络遭受自然灾害和非自然灾害，设计一个对这类东西具有弹性的网络需要技巧。广域链接超出您的控制范围，很容易出错。</p><p>最近几个月，Azure上的事件令人痛苦，而且这种失败率是主要云服务提供商的典型特征。对于移动应用程序，各种各样的事情都可能会出错：网络请求将以不可预测的间隔失败，目标将不可用，数据将到达目的地但无法发回确认，数据将在传输中损坏或到达不完整。移动应用程序必须在网络可靠性范围的可怕范围内具有弹性，但所有分布式应用程序必须能够应对所有这些可能性，并且网络节点必须能够应对服务器故障。</p><h4 id="延迟为零"><a href="#延迟为零" class="headerlink" title="延迟为零"></a>延迟为零</h4><p>延迟与带宽不同。延迟是等待响应所花费的时间。除了明显的处理延迟外，还有网络延迟，包括传播延迟，节点延迟和拥塞延迟。传播延迟随距离增加：约为30 ms。欧洲和美国之间。路径中的节点数决定了节点延迟。</p><p>通常，开发人员在内部网中构建分布式系统，这些系统具有无关紧要的延迟，因此进行频繁的细粒度网络调用几乎不会受到惩罚。这种设计错误只有在投入实时系统时才会变得明显。</p><p>高延迟的一个令人不安的影响是它不是恒定的。在糟糕的网络上，偶尔可以在几秒钟内计算出来。就其性质而言，无法保证网络服务单个数据包的顺序，甚至不能保证请求进程仍然存在。延迟会让事情变得更糟。此外，在应用程序通过发送多个同时请求进行补偿的情况下，可以通过对其的响应来加剧暂时高延迟。</p><h4 id="带宽是无限的"><a href="#带宽是无限的" class="headerlink" title="带宽是无限的"></a>带宽是无限的</h4><p>虽然大多数现代电缆可以处理几乎无限的带宽，但我们还没有找到如何构建足够快的互连设备（集线器，交换机，路由器等）以保证所有连接用户的高带宽。典型的企业内部网仍将具有限制带宽的区域。</p><p>随着公共网络带宽的增加，网络对使用视频和音频的服务的使用也一样快，而视频和音频曾经使用过广播技术。诸如社交媒体之类的新用途往往会吸收不断增加的带宽。此外，主要城市以外的许多地方都存在“最后一英里”的限制，并且丢包的可能性也在增加。</p><p>一般而言，我们需要谨慎地假设高带宽是一种普遍的体验。无论网络带宽如何令人印象深刻，它都无法接近共同托管进程可以通信的速度。</p><h4 id="网络是安全的"><a href="#网络是安全的" class="headerlink" title="网络是安全的"></a>网络是安全的</h4><p>令人遗憾的是仍然遇到具有基本安全漏洞的基于网络的系统。网络攻击逐年增加，并且在好奇心，恶意和犯罪方面已经超越了它们的原始根源，成为国际冲突和政治“行动”的一部分。网络攻击是IT生活的一部分：对开发人员来说很无聊，但却是必不可少的。部分问题是网络入侵检测往往是低优先级，因此我们并不总是意识到成功的网络攻击。</p><p>传统上，漏洞通常是配置不当的防火墙的结果。大多数防火墙都会经常被检测出来，因为你会立即发现你是否愚蠢地禁用它们。然而，这只是破坏网络和防火墙的一种方式中的一种，只是防御的一部分。Wi-Fi通常是一个弱点，使用自己的设备（BYOD）可以允许通过受损设备进行入侵，虚拟化和软件定义网络（SDN）也是如此。越来越多的DevOps对快速变化的基础设施的需求使得更难以保持必要的控制措施。企业网络中的僵尸网络是一个持续存在的问题，以及通过业务合作伙伴的入侵。</p><p>您需要假设网络是敌对的，并且安全性必须深入。这意味着将安全性构建到分布式应用程序及其主机的基本设计中。</p><p>通过纵深防御，分布式系统的任何部分都需要具有访问其他网络资源的安全方式。</p><p>安全带来了自身的复杂性。这将来自维护不同用户帐户，权限，证书，帐户等的管理开销。一个主要的云网络中断是由于权限在更新之前到期而导致的。</p><h4 id="拓扑不会改变"><a href="#拓扑不会改变" class="headerlink" title="拓扑不会改变"></a>拓扑不会改变</h4><p>网络拓扑不断变化，速度非常快。由于“网络敏捷性”的压力越来越大，这是不可避免的，以便与快速变化的业务需求保持同步。</p><p>无论您在何处部署应用程序，都必须假设大部分网络拓扑都可能无法控制。网络管理员将一次进行更改，原因可能不符合您的利益。他们将移动服务器并更改网络拓扑以获得性能或安全性，并在服务器和网络故障的情况下进行路由更改。</p><p>因此，依赖特定端点或路由的持久性是错误的。必须始终从任何分布式设计中抽象出网络的物理结构。</p><h4 id="只有一个管理员"><a href="#只有一个管理员" class="headerlink" title="只有一个管理员"></a>只有一个管理员</h4><p>除非系统完全存在于小型LAN中，否则将有不同的管理员与网络的各种组件相关联。他们将拥有不同程度的专业知识，不同的职责和优先事项。</p><p>如果出现导致服务失败的问题，这将很重要。您的服务级别协议将要求在一定时间内做出响应。第一阶段将是确定问题。除非有问题的网络部分的管理员是您的开发团队的一部分，否则这可能并不容易。不幸的是，这不太可能。在许多网络中，问题可能完全是另一个组织的责任。如果云组件是应用程序的重要组成部分，并且云中断，则无法确定优先级。你所能做的就是等待。</p><p>如果网络中有许多管理员，那么协调升级到网络或应用程序就更加困难，特别是当涉及到几个忙碌的人时。升级和部署必须协调完成，涉及的人数越多，这就变得越困难！</p><h4 id="运输成本为零"><a href="#运输成本为零" class="headerlink" title="运输成本为零"></a>运输成本为零</h4><p>运输成本是指通过网络传输数据的总体成本。我们可以参考时间和计算机资源，或者我们可以参考财务成本。</p><p>将数据从应用程序层传输到传输层需要CPU和其他资源。需要对结构化信息进行序列化（编组）或解析以将数据传输到线路上。这种性能影响可能大于带宽和延迟时间，因为XML的冗长和复杂性使得XML占用JSON的两倍。</p><p>金融运输成本不仅包括创建网络的硬件和安装成本，还包括监控和维护网络服务器，服务和基础设施的成本，以及如果发现带宽不足，或者您的服务器实际上无法处理足够的并发请求。我们还需要考虑租用线路和云服务的成本，这些成本由所使用的带宽支付</p><h4 id="网络是同质的"><a href="#网络是同质的" class="headerlink" title="网络是同质的"></a>网络是同质的</h4><p>今天的同质网络是罕见的，甚至比首次发现谬论时更为罕见！网络可能连接计算机和其他设备，每个设备具有不同的操作系统，不同的数据传输协议，并且所有设备都与来自各种供应商的网络组件相连。</p><p>但是，异构网络没有什么特别的错误，除非它涉及需要专门支持，设备或驱动程序的专有数据传输协议。从应用程序的角度来看，如果数据以开放标准格式（如CSV，XML或JSON）传输，并且使用行业标准的查询数据（如ODBC）的方法，则会有很大帮助。</p><p>如果所有组件都来自一个供应商，则可靠性更高，因为测试覆盖范围可能更大，但实际情况是组件的丰富组合。这意味着互操作性应该从任何分布式系统的设计开始就内置。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>虽然这个指导是在二十年前制定的，但我们今天仍在犯这些错误。这些错误显示为不安全的端点，由于大型对象的序列化导致的超时，丢失的事务，性能降低等等。避免这些错误意味着在每次设计和代码审查中需要考虑这些谬论。</p><p><strong>相关链接</strong><br><a href="https://dandelioncloud.cn/article/details/1526804530352373762/">文章来源于 分布式计算中的八大谬论-蒲公英云</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器简介</title>
    <link href="/2022/09/02/Introduction-to-Docker-Containers/"/>
    <url>/2022/09/02/Introduction-to-Docker-Containers/</url>
    
    <content type="html"><![CDATA[<p>Docker容器简介</p><span id="more"></span><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a href="https://">文章来源于</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装部署</title>
    <link href="/2022/09/01/Install-Docker/"/>
    <url>/2022/09/01/Install-Docker/</url>
    
    <content type="html"><![CDATA[<p>关于 Docker安装部署</p><span id="more"></span><h2 id="Docker-安装部署"><a href="#Docker-安装部署" class="headerlink" title="Docker 安装部署"></a>Docker 安装部署</h2><p>目前，Docker支持在多个平台上进行安装部署，包括Linux、Windows和Mac。每个平台会有对应的系统版本要求，具体可以参见官方说明。</p><img src="https://img.darklorder.com/img/202305121626702.png"/><p>在实际应用中，Docker使用最多的场景是在Linux系统上。本文将基于市面上最常用的Centos和Ubuntu系统，对Docker的安装部署进行介绍。</p><h5 id="初始化环境-CentOS"><a href="#初始化环境-CentOS" class="headerlink" title="初始化环境 CentOS"></a>初始化环境 CentOS</h5><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</p><p>通过 uname -r 命令查看你当前的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>使用root 权限登录 CentOS。确保 yum 包更新到最新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update<br></code></pre></td></tr></table></figure><p>卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker  docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure><p>安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p>设置yum源</p><p>官方源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>阿里云源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>清华大学源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h5 id="安装Docker-CentOS"><a href="#安装Docker-CentOS" class="headerlink" title="安装Docker CentOS"></a>安装Docker CentOS</h5><p>安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce<br></code></pre></td></tr></table></figure><p>也可以查看所有仓库中所有docker版本，并选择特定版本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br>sudo yum install docker-ce-版本号.ce<br></code></pre></td></tr></table></figure><p>启动并加入开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start docker<br>sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure><h5 id="初始化环境-Ubuntu"><a href="#初始化环境-Ubuntu" class="headerlink" title="初始化环境 Ubuntu"></a>初始化环境 Ubuntu</h5><p>Docker CE 可以安装在 64 位的 x86平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。</p><p>卸载旧版本</p><p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker \<br>               docker-engine \<br>               docker.io<br></code></pre></td></tr></table></figure><h5 id="安装Docker-Ubuntu"><a href="#安装Docker-Ubuntu" class="headerlink" title="安装Docker Ubuntu"></a>安装Docker Ubuntu</h5><p>使用脚本自动安装</p><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套安装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror Aliyun<br></code></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中</p><p>启动Docker CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></figure><p>卸载Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 先执行命令</span><br>apt-get autoremove docker-ce<br></code></pre></td></tr></table></figure><p>删除 &#x2F;etc&#x2F;apt&#x2F;sources.list.d 目录下的 docker.list 文件</p><h6 id="安装Docker-Ubuntu-1"><a href="#安装Docker-Ubuntu-1" class="headerlink" title="安装Docker Ubuntu"></a>安装Docker Ubuntu</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 修改源地址</span><br>root@ubuntu2004:~<span class="hljs-comment"># vim /etc/apt/sources.list</span><br>deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br><br>root@ubuntu2004:~<span class="hljs-comment">#</span><br>root@ubuntu2004:~<span class="hljs-comment"># visudo</span><br>%sudo ALL=(ALL:ALL) NOPASSWD:ALL<br>root@ubuntu2004:~$ <br><span class="hljs-comment">## 更新本地包数据库</span><br>root@ubuntu2004:~$ apt update<br><span class="hljs-comment">## 更新所有已安装的包（也可以使用 full-upgrade）</span><br>root@ubuntu2004:~$ apt upgrade<br>root@ubuntu2004:~$ apt install screenfetch<br>root@ubuntu2004:~$ apt install vim net-tools aptitude git<br>root@ubuntu2004:~$ apt-get install uml-utilities<br>root@ubuntu2004:~$ apt install bridge-utils<br>root@ubuntu2004:~$ ufw <span class="hljs-built_in">disable</span> <br>root@ubuntu2004:~$ screenfetch<br>                          ./+o+-       root@ubuntu2004<br>                  yyyyy- -yyyyyy+      OS: Ubuntu 20.04 focal<br>               ://+//////-yyyyyyo      Kernel: x86_64 Linux 5.4.0-91-generic<br>           .++ .:/++++++/-.+sss/`      Uptime: 1m<br>         .:++o:  /++++++++/:--:/-      Packages: 656<br>        o:+o+:++.`..```.-/oo+++++/     Shell: bash 5.0.17<br>       .:+o:+o/.          `+sssoo+/    Resolution: No X Server<br>  .++/+:+oo+o:`             /sssooo.   WM: Not Found<br> /+++//+:`oo+o               /::--:.   GTK Theme: Adwaita [GTK3]<br> \+/+o+++`o++o               ++////.   Disk: 6.9G / 52G (15%)<br>  .++.o+++oo+:`             /dddhhh.   CPU: 11th Gen Intel Core i7-11700K @ 4x 3.6GHz<br>       .+.o+oo:.          `oddhhhh+    GPU: VMware SVGA II Adapter<br>        \+.++o+o``-````.:ohdhhhhh+     RAM: 509MiB / 3907MiB<br>         `:o+++ `ohhhhhhhhyo++os:     <br>           .o:`.syhhhhhhh/.oo++o`     <br>               /osyyyyyyo++ooo+++/    <br>                   ````` +oo+++o\:    <br>                          `oo++.      <br>root@ubuntu2004:~$ <br>root@ubuntu2004:~$ vim /etc/ssh/sshd_config<br>PermitRootLogin <span class="hljs-built_in">yes</span>              <span class="hljs-comment">#允许root直接登录</span><br>PermitEmptyPasswords no          <span class="hljs-comment">#因为设置了root密码，所以需要修改为no</span><br>root@ubuntu2004:~$ service ssh restart  重启ssh服务<br>root@ubuntu2004:~$ vim ~/.bash_profile<br><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">&quot;[\u@\h \W]\\$ &quot;</span><br>root@ubuntu2004:~$ <span class="hljs-built_in">source</span> ~/.bash_profile<br>[root@ubuntu2004 ~]<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## Ubuntu（使用 apt-get 进行安装）</span><br><span class="hljs-comment"># step 1: 安装必要的一些系统工具</span><br>sudo apt-get update<br>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br><span class="hljs-comment"># step 2: 安装GPG证书</span><br>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br><span class="hljs-comment"># Step 3: 写入软件源信息</span><br>sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br><span class="hljs-comment"># Step 4: 更新并安装Docker-CE</span><br>sudo apt-get -y update<br>sudo apt-get -y install docker-ce<br><span class="hljs-comment"># 安装指定版本的Docker-CE:</span><br><span class="hljs-comment"># Step 1: 查找Docker-CE的版本:</span><br><span class="hljs-comment"># apt-cache madison docker-ce</span><br><span class="hljs-comment">#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-comment">#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-comment"># Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)</span><br><span class="hljs-comment"># sudo apt-get -y install docker-ce=[VERSION]</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu2004:~$ docker version<br>Client: Docker Engine - Community<br> Version:           20.10.11<br> API version:       1.41<br> Go version:        go1.16.9<br> Git commit:        dea9396<br> Built:             Thu Nov 18 00:37:06 2021<br> OS/Arch:           linux/amd64<br> Context:           default<br> Experimental:      <span class="hljs-literal">true</span><br>Got permission denied <span class="hljs-keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get <span class="hljs-string">&quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version&quot;</span>: dial unix /var/run/docker.sock: connect: permission denied<br>root@ubuntu2004:~$ <br></code></pre></td></tr></table></figure><h5 id="Docker-镜像加速器"><a href="#Docker-镜像加速器" class="headerlink" title="Docker 镜像加速器"></a>Docker 镜像加速器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 镜像加速器</span><br>root@ubuntu2004:~<span class="hljs-comment"># </span><br>root@ubuntu2004:~<span class="hljs-comment"># sudo mkdir -p /etc/docker</span><br>root@ubuntu2004:~<span class="hljs-comment"># sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>          <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>          <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>          <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span><br>  ]<br>&#125;<br>EOF<br>root@ubuntu2004:~<span class="hljs-comment"># systemctl daemon-reload</span><br>root@ubuntu2004:~<span class="hljs-comment"># systemctl restart docker</span><br>root@ubuntu2004:~<span class="hljs-comment"># docker info</span><br> ...<br> Registry Mirrors:<br>  https://docker.mirrors.ustc.edu.cn/<br>  https://hub-mirror.c.163.com/<br>  https://reg-mirror.qiniu.com/<br> Live Restore Enabled: <span class="hljs-literal">false</span><br>root@ubuntu2004:~<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p><strong>相关链接</strong></p><p><a href="https://micromaple.blog.csdn.net/article/details/125727576">文章来源于CSDN【云原生】Docker镜像详细讲解</a><br><a href="https://developer.aliyun.com/mirror/docker-ce">阿里云 Docker CE镜像</a><br><a href="https://developer.aliyun.com/mirror/ubuntu">阿里云 Ubuntu 镜像</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文彻底弄懂REST API</title>
    <link href="/2022/08/20/REST-API/"/>
    <url>/2022/08/20/REST-API/</url>
    
    <content type="html"><![CDATA[<p>一文彻底弄懂REST API</p><span id="more"></span><center><img src="https://img.darklorder.com/img/202307070418363.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这是一个开发中经常会遇到的名词，也许你已经了解过一些这方面的知识，也有可能对这个概念比较模糊。本文将会诠释REST的基础以及如何给应用创建一个API，我们开始正文。</p><h4 id="什么是API？"><a href="#什么是API？" class="headerlink" title="什么是API？"></a><strong>什么是API？</strong></h4><p>首先介绍API的概念，Application Programming Interface（应用程序接口）是它的全称。简单的理解就是，API是一个接口。那么它是一个怎样的接口呢，现在我们常将它看成一个HTTP接口即HTTP API。也就是说这个接口得通过HTTP的方式来调用，做过前后端开发的小伙伴可能知道，后端开发又叫做面向接口开发，我们往往会提供一个接口供前端调用，或者供其他服务调用。举个例子，我们程序中往往会涉及到调用第三方接口，比如说，调用支付宝或者微信的支付接口来实现我们程序中的支付功能、调用带三方的短信接口来向用户发送验证码短信等等…</p><p>这样说吧，比如说我们有一个可以允许我们查看（view），创建（create），编辑（edit）以及删除（delete）部件的应用程序。我们可以创建一个可以让我们执行这些功能的HTTP API:</p><p><a href="http://demo.com/view_books">http://demo.com/view_books</a><br><a href="http://demo.com/create_new_book?name=shuxue">http://demo.com/create_new_book?name=shuxue</a><br><a href="http://demo.com/update_book?id=1&amp;name=shuxue">http://demo.com/update_book?id=1&amp;name=shuxue</a><br><a href="http://demo.com/delete_book">http://demo.com/delete_book</a>?</p><p>这是4个HTTP API，分别实现了图书的查看、新增、编辑、删除的操作，当我们把接口发布出去的时候，别人就可以通过这四个接口来调用相关的服务了。但是这样做有什么不方便的地方呢？你可能发现了，这种API的写法有一个缺点 ，那就是没有一个统一的风格，比如说第一个接口表示查询全部图书的信息，我们也可以写成这样：</p><p><a href="http://demo.com/books/list">http://demo.com/books/list</a><br>那这样就会造成使用我们接口的其他人必须得参考API才能知道它是怎么运作的。</p><p>不用担心，REST会帮我们解决这个问题。</p><h4 id="什么是REST？"><a href="#什么是REST？" class="headerlink" title="什么是REST？"></a><strong>什么是REST？</strong></h4><p>有了上面的介绍，你可能也大概有了直观的了解，说白了，<strong>REST是一种风格！</strong></p><p>REST的作用是将我们上面提到的查看（view），创建（create），编辑（edit）和删除（delete）直接映射到HTTP 中已实现的<strong>GET,POST,PUT和DELETE</strong>方法。</p><p>这四种方法是比较常用的，HTTP总共包含<strong>八种</strong>方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GET</span><br>POST<br>PUT<br><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">OPTIONS</span><br>HEAD<br>TRACE<br><span class="hljs-keyword">CONNECT</span><br></code></pre></td></tr></table></figure><p>当我们在浏览器点点点的时候我们通常只用到了GET方法，当我们提交表单，例如注册用户的时候我们就用到了POST方法…</p><p>介绍到这里，我们重新将上面的四个接口改写成REST风格：</p><p><strong>查看所有图书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//</span>demo.com/books<br></code></pre></td></tr></table></figure><p><strong>新增一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST http:<span class="hljs-regexp">//</span>demo.com/books<br>Data: name=shuxue<br></code></pre></td></tr></table></figure><p><strong>修改一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT http:<span class="hljs-regexp">//</span>demo.com/books<br>Data:id=<span class="hljs-number">1</span>,name=shuxue<br></code></pre></td></tr></table></figure><p><strong>删除一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">DELETE http:<span class="hljs-regexp">//</span>demo.com/books<br>Data:id=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>大家有没有发现，这样改动之后API变得统一了，我们只需要改变请求方式就可以完成相关的操作，这样大大简化了我们接口的理解难度，变得易于调用。</p><p><strong>这就是REST风格的意义！</strong></p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h4><p>REST的另一重要部分就是为既定好请求的类型来响应正确的状态码。如果你对HTTP状态码陌生，以下是一个简易总结。当你请求HTTP时，服务器会响应一个状态码来判断你的请求是否成功，然后客户端应如何继续。以下是四种不同层次的状态码：</p><ul><li>2xx &#x3D; Success（成功）</li><li>3xx &#x3D; Redirect（重定向）</li><li>4xx &#x3D; User error（客户端错误）</li><li>5xx &#x3D; Server error（服务器端错误）</li></ul><p>我们常见的是200（请求成功）、404（未找到）、401（未授权）、500（服务器错误）…</p><h4 id="API格式响应"><a href="#API格式响应" class="headerlink" title="API格式响应"></a><strong>API格式响应</strong></h4><p>上面介绍了REST API的写法，响应状态码，剩下就是请求的数据格式以及响应的数据格式。说的通俗点就是，我们用什么格式的参数去请求接口并且我们能得到什么格式的响应结果。</p><p>我这里只介绍一种用的最多的格式——JSON格式</p><p>目前json已经发展成了一种最常用的数据格式，由于其轻量、易读的优点。</p><p>所以我们经常会看到一个请求的header信息中有这样的参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>:application/json<br></code></pre></td></tr></table></figure><p>这个参数的意思就是接收来自后端的json格式的信息。</p><p>我举个json响应的例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;<br>&quot;code&quot;: 200,<br>&quot;books&quot;: [&#123;<br>&quot;id&quot;: 1,<br>&quot;name&quot;: &quot;yuwen&quot;<br>&#125;, &#123;<br>&quot;id&quot;: 2,<br>&quot;name&quot;: &quot;shuxue&quot;<br>&#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样返回是不是一目了然，而且冗余信息很少！</p><h4 id="REST-API例子"><a href="#REST-API例子" class="headerlink" title="REST API例子"></a><strong>REST API例子</strong></h4><p>说了这么多，最后我以一个实际REST API的例子结尾（这里以java语言为例）</p><p>我们新建一个SpringBoot的项目demo</p><center><img src="https://img.darklorder.com/img/202307070418852.jpg"  alt="文件名" style="zoom:50%;" /></center><p>然后写上查看、新增、修改、删除四个接口（这里为了方便返回的格式我用字符串代替json格式）</p><center><img src="https://img.darklorder.com/img/202307070418147.jpg"  alt="文件名" style="zoom:40%;" /></center><p>最后通过Apifox工具对四个接口依次进行测试。如下图。</p><center><img src="https://img.darklorder.com/img/202307070418078.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070418452.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070418347.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070417291.jpg"  alt="文件名" style="zoom:40%;" /></center><p>以上，</p><p><strong>问：REST API是什么呢？</strong></p><p><strong>答：是一种REST风格的HTTP接口！</strong></p><p><strong>相关链接</strong></p><p><a href="https://zhuanlan.zhihu.com/p/536437382">一文彻底弄懂REST API - 知乎</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟化技术</title>
    <link href="/2022/08/10/what-is-a-hypervisor/"/>
    <url>/2022/08/10/what-is-a-hypervisor/</url>
    
    <content type="html"><![CDATA[<p>Hypervisor是所有虚拟化技术的核心。</p><span id="more"></span><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>虚拟化技术源于提升计算机硬件资源使用效率的需求，发展出了Xen、KVM等众多硬件虚拟化方式的虚拟机技术、以Docker容器为代表的软件虚拟化技术，虚拟化技术实质上在不同层级上对于计算机的软硬件资源进行了模拟封装，使得这些资源可按需分配、配置和调度，也为云计算的发展奠定了坚实的基础，甚至可以说没有虚拟化技术的发展就没有云计算发展。</p><p>“虚拟化”的概念最早于1959年6月提出，牛津大学的计算机教授克里斯·托弗在国际信息处理大会上发表了一篇名为《大型高速计算机中的时间共享》的学术报告，文中首次提出了 “虚拟化” 的基本概念，并论述了什么是虚拟化技术。上个世纪60年代，IBM公司最先进行了虚拟化技术的实践探索，发明了一种操作系统虚拟机技术，允许用户在一台主机上运行多个操作系统，让用户尽可能地充分利用昂贵的大型机资源。最初主要运用于大型服务器上，但随着硬件技术突飞猛进的发展，普通PC的性能越来越强，也可用来运行虚拟机，构建云服务平台。</p><p><strong>相关链接</strong><br><a href="https://www.ibm.com/cn-zh/topics/hypervisors?mhsrc=ibmsearch_a&mhq=hypervisor">IBM 虚拟机管理器</a><br><a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">RedHat 什么是虚拟机监控程序</a></p>]]></content>
    
    
    <categories>
      
      <category>Hypervisor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hypervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE 到底是什么</title>
    <link href="/2022/08/07/What-is-SRE/"/>
    <url>/2022/08/07/What-is-SRE/</url>
    
    <content type="html"><![CDATA[<p>什么是 SRE？SRE 需要具备什么能力？</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>SRE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算概论</title>
    <link href="/2022/08/06/Introduction-to-Cloud-Computing/"/>
    <url>/2022/08/06/Introduction-to-Cloud-Computing/</url>
    
    <content type="html"><![CDATA[<p>关于云计算基本特征、部署模型和服务模型</p><span id="more"></span><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p>让我们首先了解云的五个基本特征，包括按需自助服务、广泛的网络访问、资源池、快速弹性和可度量的服务。</p><p><strong>按需自助服务（On-demand Self-service）：</strong> 用户可以使用简单的界面访问云资源，如处理能力、存储和网络，而无需与每个服务提供商进行人工交互。</p><p><strong>广泛的网络访问（Broad Network Access）：</strong> 可以通过标准机制和平台（如手机、平板电脑、笔记本电脑和工作站）通过网络访问云计算资源。</p><p><strong>资源池（Resource Pooling）：</strong> 云提供商的规模经济，他们将其传递给客户，使云具有成本效益。使用多租户模型，将计算资源集中起来为多个消费者提供服务；云资源是根据需求动态分配和重新分配的，而客户无需关心这些资源的物理位置。</p><p><strong>快速弹性（Rapid Elasticity）：</strong> 用户可以在需要的时候访问更多的资源，在不需要的时候缩小规模，因为资源是弹性供应和释放的。</p><p><strong>可度量的服务（Measured Service）：</strong> 用户只为其使用或预订的东西付费。如果用户不使用资源，就不会付钱。根据利用率透明地监控、测量和报告资源使用情况。</p><h3 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h3><p><strong>Public Cloud：公共云</strong> 云服务提供商通过公共网络向用户提供云服务，用户可以根据自己的需求随时使用或释放资源。<br><strong>Private Cloud：私有云</strong> 云服务提供商在企业内部或数据中心中提供云服务，仅对内部员工或合作伙伴提供服务。<br><strong>Hybrid Cloud：混合云</strong> 结合了公有云和私有云的特点，使用户可以在公有云和私有云之间移动工作负载和数据。<br><strong>Community Cloud：社区云</strong> 特定的组织或行业提供的云服务，仅面向该组织或行业的成员。<br><strong>Multi-cloud：多云</strong> 同时采用两个或多个不同的云服务提供商，以获取更好的性能、可靠性、安全性和成本控制等方面的优势。<br><strong>Edge computing 边缘计算</strong> 在边缘设备上进行数据处理和存储，以减少数据传输和响应时间，提高应用程序性能。</p><h3 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h3><p><strong>Infrastructure as a Service (IaaS)：基础设施即服务</strong> 提供基础设施服务，例如虚拟机、存储、网络等。<br><strong>Platform as a Service (PaaS)：平台即服务</strong> 提供完整的应用程序开发和部署平台，包括开发、测试、部署和管理工具等。<br><strong>Software as a Service (SaaS)：软件即服务</strong> 提供基于云的应用程序服务，例如邮件、协作、客户关系管理等。<br><strong>Function as a Service (FaaS)：函数即服务</strong> 以事件驱动的方式提供计算服务，例如无服务器计算、事件处理等。<br><strong>Backend as a Service (BaaS)：后端即服务</strong> 提供云端的后端服务，例如数据库、身份认证、通知、存储等。<br><strong>Data as a Service (DaaS)：数据即服务</strong> 提供数据访问和分析服务，例如数据挖掘、数据分析、数据可视化等。<br><strong>Machine as a Service (MaaS)：机器即服务</strong> 提供物联网设备租赁或购买服务，例如传感器、智能家居设备等。<br><strong>Gaming as a Service (GaaS)：游戏即服务</strong> 提供云游戏服务，例如流媒体游戏、云端游戏服务器等。<br><strong>Container as a Service (CaaS)：容器即服务</strong> 提供容器管理平台，快速部署、运行和管理容器化应用程序。<br><strong>Anything as a Service (XaaS)：任何事物即服务</strong> 广义的术语，包括所有可以作为服务提供的事物，例如网络安全服务、身份认证服务、API管理服务等。</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Computing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算（Cloud Computing）</title>
    <link href="/2022/08/05/Cloud-Computing/"/>
    <url>/2022/08/05/Cloud-Computing/</url>
    
    <content type="html"><![CDATA[<p>关于云计算（Cloud Computing） 看懂云计算、虚拟化和容器，这一篇就够啦！</p><span id="more"></span><h2 id="云计算这个词，相信大家都非常熟悉了。"><a href="#云计算这个词，相信大家都非常熟悉了。" class="headerlink" title="云计算这个词，相信大家都非常熟悉了。"></a>云计算这个词，相信大家都非常熟悉了。</h2><p>云计算的准确定义，有比较多的先驱定义过，具体如下：</p><p><strong>Gartner公司</strong>将云计算定义为：「一种计算方式，能够通过Internet技术将可扩展的和弹性的IT能力作为服务交付给外部用户。」</p><p><strong>Forrester Research公司</strong>，将云计算定义为：「一种标准化的IT性能（服务，软件或者基础设施），以按使用付费和自助服务方式，通过Internet技术进行交付。」</p><p><strong>NIST（美国国家标准和技术研究院）</strong>，将云计算定义为：「云计算是一种模型，可以随时随地，便捷地，按需地从可配置计算资源共享池中获取所需的资源（例如，网络，服务器，存储，应用程序及服务），资源可以快速供给和释放，使管理的工作量和服务提供者的介入降低至最少。这种云模型，包括五个基本特征，三种服务模型和四种部署模型。」</p><p>“云计算”这个词，相信大家都非常熟悉。</p><p>作为信息科技发展的主流趋势，它频繁地出现在我们的眼前。伴随它一起出现的，还有这些概念名词——OpenStack、Hypervisor、KVM、Docker、K8S…</p><center><img src="https://img.darklorder.com/img/202305112240666.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这些名词概念，全部都属于云计算技术领域的范畴。</p><p>对于初学者来说，理解这些概念的具体含义并不是一件容易的事情。</p><p>所以，今天这篇文章，将给大家做一个通俗易懂的介绍，解释这些云计算概念以及它们之间的关系，希望对大家入门有所帮助。</p><h3 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h3><p>在介绍那些古怪名词之前，我先介绍一下<strong>云计算。</strong></p><p>以前电脑被发明的时候，还没有网络，每个电脑（PC），就是一个单机。</p><center><img src="https://img.darklorder.com/img/202305112242464.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这台单机，包括CPU、内存、硬盘、显卡等硬件。用户在单机上，安装操作系统和应用软件，完成自己的工作。</p><p>后来，有了<strong>网络（Network），</strong>单机与单机之间，可以交换信息，协同工作。</p><center><img src="https://img.darklorder.com/img/202305112243322.jpg"  alt="文件名" style="zoom:50%;" /></center><p>再后来，单机性能越来越强，就有了<strong>服务器（Server）。</strong>人们发现，可以把一些服务器集中起来，放在机房里，然后让用户通过网络，去访问和使用机房里的计算机资源。</p><center><img src="https://img.darklorder.com/img/202305112243607.jpg"  alt="文件名" style="zoom:50%;" /></center><p>再再后来，小型网络变成了大型网络，就有了<strong>互联网（Internet）。</strong>小型机房变成了大型机房，就有了<strong>IDC（Internet Data Center，互联网数据中心）。</strong></p><p>当越来越多的计算机资源和应用服务（Application，例如看网页，下电影）被集中起来，就变成了——<strong>“云计算（Cloud Computing）”。</strong>无数的大型机房，就成了“云端”。</p><center><img src="https://img.darklorder.com/img/202305112244542.jpg"  alt="文件名" style="zoom:50%;" /></center><p>是不是觉得太简单？别急，开始深入。</p><p>云计算的道理是简单的，说白了，就是把计算机资源集中起来，放在网络上。但是，云计算的实现方式，就非常复杂了。</p><p>举个例子，如果你只是在公司小机房摆了一个服务器，开个FTP下载服务，然后用于几个同事之间的电影分享，当然是很简单的。</p><p>如果是“双11”的淘宝购物节，全球几十亿用户访问阿里巴巴的淘宝网站，单日几十<strong>PB（1PB&#x3D;1024TB&#x3D;1024×1024GB）</strong>的访问量，每秒几百<strong>GB</strong>的流量……这个，就不是几根网线几台服务器能解决的了。</p><p>这时，需要设计一个<strong>超大容量、超高并发（同时访问）、超快速度、超强安全</strong>的云计算系统，才能满足业务平稳运行的要求。</p><p>这才是云计算的复杂之处。</p><p>刚才说了，我们把计算机资源放在云端。这个计算机资源，实际上分为好几种层次：</p><p><strong>第一层次，</strong>是最底层的硬件资源，主要包括CPU（计算资源），硬盘（存储资源），还有网卡（网络资源）等。</p><p><strong>第二层次，</strong>要高级一些，我不打算直接使用CPU、硬盘、网卡，我希望你把操作系统（例如Windows、Linux）装好，把数据库软件装好，我再来使用。</p><p><strong>第三层次，</strong>更高级一些，你不但要装好操作系统这些基本的，还要把具体的应用软件装好，例如FTP服务端软件、在线视频服务端软件等，我可以直接使用服务。</p><p>这三种层次，就是大家经常听到的<strong>IaaS、Paas、SaaS。</strong></p><center><img src="https://img.darklorder.com/img/202305112246787.jpg"  alt="文件名" style="zoom:50%;" /></center><p>SaaS: Software-as-a-Service（软件即服务）<br>PaaS: Platform-as-a-Service（平台即服务）<br>IaaS: Infrastructure-as-a-Service（基础设施即服务）</p><p>再补一张图，可能更直观：</p><center><img src="https://img.darklorder.com/img/202305112246104.jpg"  alt="文件名" style="zoom:50%;" /></center><p>目前主流的云计算服务提供商，例如亚马逊AWS、阿里云、华为云、天翼云、腾讯云，说白了，都是为大家提供以上三个层次的云资源。你想要什么，它们就提供什么。你想要多少，它们就提供多少。</p><center><img src="https://img.darklorder.com/img/202305112247813.jpg"  alt="文件名" style="zoom:50%;" /></center><p>继续，继续。</p><p>这么多样化多层次的云计算服务，阿里、华为们又是怎么提供的呢？</p><p>难道说，是人工安排？——</p><p>如果你要八核CPU、16GB内存、500GB硬盘的服务器，阿里临时安排工程师帮你组装？如果你要装CentOS 7.2（一种类Linux操作系统），MySQL 5.5.60（一种数据库系统），阿里也临时让工程师帮你安装配置？</p><p>这显然是不可能的，耗不起人力，也等不起时间。</p><p><strong>于是，就有了各种软件和平台，负责对资源进行快速调用和集中管理。</strong></p><h3 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h3><p>如果要对物理资源进行管理，第一步，就是<strong>“虚拟化”。</strong></p><p>虚拟化是云计算的基础。简单来说，虚拟化就是在一台物理服务器上，运行多台“虚拟服务器”。这种虚拟服务器，也叫<strong>虚拟机（VM，Virtual Machine）。</strong></p><p>从表面来看，这些虚拟机都是独立的服务器，但实际上，它们共享物理服务器的CPU、内存、硬件、网卡等资源。</p><center><img src="https://img.darklorder.com/img/202305112248949.png"  alt="文件名" style="zoom:50%;" /></center><p>物理机，通常称为“宿主机（Host）”。虚拟机，则称为“客户机（Guest）”。</p><p>谁来完成物理资源虚拟化的工作呢？</p><p>就是大名鼎鼎的 <strong>Hypervisor 。</strong></p><p>Hypervisor，汉译过来是“超级监督者”，也叫做VMM（Virtual Machine Monitor，虚拟机监视器）。它不是一款具体的软件，而是一类软件的统称。</p><p>Hypervisor分为两大类：</p><p>第一类，hypervisor直接运行在物理机之上。虚拟机运行在hypervisor之上。第二类，物理机上安装正常的操作系统（例如Linux或Windows），然后在正常操作系统上安装hypervisor，生成和管理虚拟机。</p><center><img src="https://img.darklorder.com/img/202305112249807.jpg"  alt="文件名" style="zoom:50%;" /></center><p>像<strong>VMware、KVM、Xen、Virtual Box，</strong>都属于Hypervisor。</p><p>VMware大家应该很熟悉，就是VMware Workstation。学习Linux的话，很多人都是在windows系统下安装WMware，然后创建Linux虚拟机。</p><center><img src="https://img.darklorder.com/img/202305112250795.jpg"  alt="文件名" style="zoom:50%;" /></center><p>但是，真正厉害的，是但是，真正厉害的，是 <strong>KVM（kernel-based virtual machine，基于Linux内核的虚拟机）。</strong>它是目前最热门最受追捧的虚拟化方案。</p><center><img src="https://img.darklorder.com/img/202305112251358.jpg"  alt="文件名" style="zoom:50%;" /></center><p>KVM这样的Hypervisor软件，实际上是提供了一种虚拟化能力，模拟CPU的运行，更为底层。但是它的用户交互并不良好，不方便使用。</p><p>于是，为了更好地管理虚拟机，就需要OpenStack这样的云管理平台。</p><center><img src="https://img.darklorder.com/img/202305112252953.jpg"  alt="文件名" style="zoom:50%;" /></center><p>关于OpenStack，我之前曾经介绍过（<a href="https://mp.weixin.qq.com/s?__biz=MzI1NTA0MDUyMA==&mid=2456660029&idx=1&sn=1a900a0c45ff77355693e7902c3d8f38&chksm=fda5055acad28c4c34d015b72843ef14c5529f81651cf38daddd1ce4d7e595c9f937f1ee3327&scene=21#wechat_redirect">链接</a>）。它有点像个商店，负责管理商品（计算资源、存储资源、网络资源等），卖给用户，但它本身不制造商品（不具备虚拟化能力），它的商品，来自于KVM。当然，如果不用KVM，也可以用Xen等其它hypervisor。</p><center><img src="https://img.darklorder.com/img/202305112252467.jpg"  alt="文件名" style="zoom:50%;" /></center><p>OpenStack的管理界面，比命令行好多了吧？</p><p>请记住，上面所说的几个概念，包括VM、KVM、OpenStack等，都主要属于IaaS（基础设施即服务）。这个不难理解吧？</p><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>继续往下说。</p><p>那么，容器是什么呢？大佬们经常说的Docker和K8S，又是什么呢？</p><p>前面我们介绍了虚拟化。人们在使用虚拟化一段时间后，发现它存在一些问题：</p><p>不同的用户，有时候只是希望运行各自的一些简单程序，跑一个小进程。为了不相互影响，就要建立虚拟机。如果建虚拟机，显然浪费就会有点大，而且操作也比较复杂，花费时间也会比较长。</p><p>而且，有的时候，想要迁移自己的服务程序，就要迁移整个虚拟机。显然，迁移过程也会很复杂。</p><p>有没有办法<strong>更灵活快速一</strong>些呢？</p><p>有，这就引入了<strong>“容器（Container）”。</strong></p><p>容器也是虚拟化，但是属于“轻量级”的虚拟化。它的目的和虚拟机一样，都是为了创造“隔离环境”。但是，它又和虚拟机有很大的不同——虚拟机是操作系统级别的资源隔离，而容器本质上是进程级的资源隔离。</p><center><img src="https://img.darklorder.com/img/202305112253652.jpg"  alt="文件名" style="zoom:50%;" /></center><p>虚拟化 VS 容器</p><p>而大家常听说的<strong>Docker，</strong>就是创建容器的工具，是应用容器引擎。</p><p>Docker的中文意思，就是码头工人。而它的LOGO，就是一只鲸鱼背着很多货柜箱。</p><center><img src="https://img.darklorder.com/img/202305112254729.jpg"  alt="文件名" style="zoom:50%;" /></center><p>相比于传统的虚拟机，Docker的优势很明显，它启动时间很快，是秒级，而且对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB，而容器只需要MB级甚至KB级。</p><center><img src="https://img.darklorder.com/img/202305112254245.jpg"  alt="文件名" style="zoom:50%;" /></center><p>除了Docker对容器进行创建之外，我们还需要一个工具，对容器进行<strong>编排。</strong></p><p>这个工具，就是<strong>K8S。</strong></p><p><strong>K8S，</strong>就是<strong>Kubernetes，</strong>中文意思是舵手或导航员。Kubernetes这个单词很长，所以大家把中间8个字母缩写成8，就成了K8S。</p><center><img src="https://img.darklorder.com/img/202305112255615.jpg"  alt="文件名" style="zoom:50%;" /></center><p>K8S是一个容器集群管理系统，主要职责是<strong>容器编排（Container Orchestration）</strong>——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。</p><p>简单来说，K8S有点像容器的保姆。它负责管理容器在哪个机器上运行，监控容器是否存在问题，控制容器和外界的通信，等等。</p><p>通过下面这张K8S系统结构图，就能够看出K8S和容器之间的关系。</p><center><img src="https://img.darklorder.com/img/202305112255372.jpg"  alt="文件名" style="zoom:80%;" /></center><p>除了K8S之外，还有很多种容器管理平台，例如<strong>Compose，Marathon，Swarm，Mesos</strong>等。</p><p>Docker和K8S，关注的不再是基础设施和物理资源，而是应用层，所以，就属于PaaS。明白了吧？</p><p>好啦，今天就先到这里了。再说下去，估计很多人又要晕啦。</p><p>正如文章开头所说，今天主要是介绍KVM、Hypervisor、OpenStack、Docker、K8S这些名词的意思，它们在云计算系统中的位置，以及它们之间的关系。云计算涉及到大量的需求。同一个需求，会有很多不同的技术来实现。同一个技术，往往又有多个不同的厂家互相竞争。所以，概念和名词就会特别多，发展变化也会很快。</p><p>不管怎么说，梳理清楚最关键的名词概念，是学好云计算的第一步。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NTA0MDUyMA==&mid=2456665252&idx=1&sn=365da9095c9a1ed46886eab43b5bc003&chksm=fda511c3cad298d5679642973577a7380ad050fddc15fde6c5bd81f354aacc787fb9ee86bb7f&scene=21#wechat_redirect">文章来源于鲜枣课堂 ，作者小枣君</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Computing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writing Article</title>
    <link href="/2022/07/31/writing/"/>
    <url>/2022/07/31/writing/</url>
    
    <content type="html"><![CDATA[<p>写作</p><span id="more"></span><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><ul><li>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p><table><thead><tr><th align="center">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="left">source&#x2F;_posts</td></tr><tr><td align="center">page</td><td align="left">source</td></tr><tr><td align="center">draft</td><td align="left">source&#x2F;_drafts</td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source&#x2F;_drafts 文件夹，您可通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><ul><li>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</li></ul><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是文件最上方以 —— 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>title: Hello World<br><span class="hljs-built_in">date</span>: 2022-07-24 00:00:00<br>---<br></code></pre></td></tr></table></figure><ul><li>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="left"></td></tr><tr><td align="left"><code>lang</code></td><td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="left">Inherited from <code>_config.yml</code></td></tr></tbody></table><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">删除文件夹<span class="hljs-built_in">source</span>/_posts下目标文章markdown文件<br>删除.deploy_git文件夹<br>执行hexo cl 后，再执行 hexo g ，hexo s 即可。<br></code></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>创建 分类 页并添加 tpye 属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page categories<br></code></pre></td></tr></table></figure><p>source&#x2F;categories&#x2F;index.md 添加 categories 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: categories<br>date: 2022-07-24 00:00:00<br><span class="hljs-section">type: &quot;categories&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>给文章添加 categories 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: 写作<br>date: 2022-07-31 00:00:00<br>categories:<br><span class="hljs-section">- Hello World</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>打开需要添加分类的文章，为其添加categories属性。</li><li>下方的categories: Hello World 表示添加这篇文章到 Hello World 这个分类。</li><li>注意：hexo一篇文章只能属于一个分类，也就是说如果在 “- Hello World” 下方添加 “-xxx”，hexo不会产生两个分类，</li><li>而是把分类嵌套（即该文章属于 “- Hello World” 下的 “-xxx” 分类）。</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>创建 标签 页并添加 tpye 属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page tags<br></code></pre></td></tr></table></figure><p>source&#x2F;tags&#x2F;index.md 添加 tags 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: tags<br>date: 2022-07-24 00:00:00<br><span class="hljs-section">type: &quot;tags&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>给文章添加 tags 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: 写作<br>date: 2022-07-25 00:00:00<br>categories:<br><span class="hljs-bullet">-</span> Hello World<br>tags:<br><span class="hljs-bullet">-</span> Hello <br><span class="hljs-section">- World</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- Hello - World 就是这篇文章的标签了</li><li>至此，成功给文章添加分类，点击首页的 “标签” 可以看到该标签下的所有文章。</li><li>当然，只有添加了tags: xxx的文章才会被收录到首页的 “标签” 中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Writing Article</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Writing Article</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>出身重要还是后天努力重要？</title>
    <link href="/2022/07/25/Origin-or-hard-work/"/>
    <url>/2022/07/25/Origin-or-hard-work/</url>
    
    <content type="html"><![CDATA[<p>我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”;你和别人同时搞，你比别人搞的好，就是“专家”。</p><p><strong>转载来源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/24/hello-world/"/>
    <url>/2022/07/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>用户手册</p><span id="more"></span><p>主题 GitHub: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>主题 用户手册: <a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p><h2 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a>用户手册</h2><h3 id="自动更新主题"><a href="#自动更新主题" class="headerlink" title="自动更新主题"></a>自动更新主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm update            <span class="hljs-comment">#  更新所有</span><br>$ npm update --save hexo-theme-fluid            <span class="hljs-comment"># 更新主题</span><br></code></pre></td></tr></table></figure><h3 id="手动更新主题"><a href="#手动更新主题" class="headerlink" title="手动更新主题"></a>手动更新主题</h3><p>修改根目录的package.json文件，将对应插件名称所对应的版本号更改为要更新的版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm <span class="hljs-built_in">ls</span>            <span class="hljs-comment"># 查询当前项目已安装插件版本</span><br>$ npm install --save            <span class="hljs-comment"># 更新</span><br></code></pre></td></tr></table></figure><h3 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean            <span class="hljs-comment"># 清理缓存 clean</span><br>$ hexo generate         <span class="hljs-comment"># 构建 build</span><br>$ hexo server           <span class="hljs-comment"># 本地启动 server</span><br>$ hexo deploy           <span class="hljs-comment"># 自动部署 deploy</span><br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&quot;博客配置&quot;</span> <span class="hljs-string">指的是</span> <span class="hljs-string">根目录下的</span> <span class="hljs-string">_config.yml</span><br><span class="hljs-string">&quot;主题配置&quot;</span> <span class="hljs-string">指的是</span> <span class="hljs-string">theme/fluid/_config.yml</span><br></code></pre></td></tr></table></figure><h3 id="顶部大图"><a href="#顶部大图" class="headerlink" title="顶部大图"></a>顶部大图</h3><p>主题配置中，每个页面都有名为 banner_img 的属性，可以使用本地图片的相对路径，也可以为外站链接。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml">  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span>          <span class="hljs-comment"># 对应存放在 /source/img/default.png</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://xxxx.com/img/default.png</span><br>  <br><span class="hljs-comment"># 高度</span><br>  <span class="hljs-string">鉴于每个人的喜好不同，开放对页面</span> <span class="hljs-string">banner_img</span> <span class="hljs-string">高度的控制。</span><br>  <span class="hljs-string">主题配置中，每个页面对应的</span> <span class="hljs-string">banner_img_height</span> <span class="hljs-string">属性，有效值为</span> <span class="hljs-number">0</span> <span class="hljs-bullet">-</span> <span class="hljs-number">100</span><span class="hljs-string">。100</span> <span class="hljs-string">即为全屏，个人建议</span> <span class="hljs-number">70</span> <span class="hljs-string">以上。</span><br><span class="hljs-comment"># 蒙版透明度</span><br>  <span class="hljs-string">主题配置中，每个页面对应的</span> <span class="hljs-string">banner_mask_alpha</span> <span class="hljs-string">属性，有效值为</span> <span class="hljs-number">0</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1.0</span><span class="hljs-string">，</span> <span class="hljs-number">0</span> <span class="hljs-string">是完全透明（无蒙版），1</span> <span class="hljs-string">是完全不透明</span><br></code></pre></td></tr></table></figure><h3 id="博客标题"><a href="#博客标题" class="headerlink" title="博客标题"></a>博客标题</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">博客标题</span><br></code></pre></td></tr></table></figure><h3 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;links&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/links/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-link-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li>key: 用于关联有语言配置，如不存在关联则显示 key 本身的值</li><li>link: 跳转链接</li><li>icon: 图标的 css class，可以省略（即没有图标），主题内置图标详见这里</li><li>name: 强制使用此名称显示（不再按语言配置显示），可省略</li></ul><p>另外支持二级菜单（下拉菜单），配置写法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;文档&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-books&#x27;</span>,<br>      <span class="hljs-attr">submenu:</span> [<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;主题博客&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;配置指南&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/guide/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;图标用法&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/icon/&#x27;</span> &#125;<br>      ]<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="全局字体"><a href="#全局字体" class="headerlink" title="全局字体"></a>全局字体</h3><p>设置单独的页面，可以直接在 markdown 里通过 style 标签实现：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&lt;style&gt;</span><br>  <span class="hljs-string">/*</span> <span class="hljs-string">设置整个页面的字体</span> <span class="hljs-string">*/</span><br>  <span class="hljs-string">html,</span> <span class="hljs-string">body,</span> <span class="hljs-string">.markdown-body</span> &#123;<br>    <span class="hljs-attr">font-family:</span> <span class="hljs-string">KaiTi</span>,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,<span class="hljs-string">Georgia</span>, <span class="hljs-string">sans</span>, <span class="hljs-string">serif;</span><br>    <span class="hljs-attr">font-size:</span> <span class="hljs-string">15px;</span><br>  &#125;<br><br>  <span class="hljs-string">/*</span> <span class="hljs-string">只设置</span> <span class="hljs-string">markdown</span> <span class="hljs-string">字体</span> <span class="hljs-string">*/</span><br>  <span class="hljs-string">.markdown-body</span> &#123;<br>    <span class="hljs-attr">font-family:</span> <span class="hljs-string">KaiTi</span>,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,<span class="hljs-string">Georgia</span>, <span class="hljs-string">sans</span>, <span class="hljs-string">serif;</span><br>    <span class="hljs-attr">font-size:</span> <span class="hljs-string">15px;</span><br>  &#125;<br><span class="hljs-string">&lt;/style&gt;</span><br></code></pre></td></tr></table></figure><h3 id="强制全局-HTTPS"><a href="#强制全局-HTTPS" class="headerlink" title="强制全局 HTTPS"></a>强制全局 HTTPS</h3><p>这种情况可以在主题配置中开启此配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">force_https:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="自定义-JS-x2F-CSS-x2F-HTML"><a href="#自定义-JS-x2F-CSS-x2F-HTML" class="headerlink" title="自定义 JS &#x2F; CSS &#x2F; HTML"></a>自定义 JS &#x2F; CSS &#x2F; HTML</h3><p>如果你想引入外部的 JS、CSS（比如 IconFont）或 HTML，可以通过以下主题配置，具体见注释：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 指定自定义 js 文件路径，路径是相对 source 目录</span><br><span class="hljs-attr">custom_js:</span> <span class="hljs-string">/js/custom.js</span><br><br><span class="hljs-comment"># 指定自定义 css 文件路径，路径是相对 source 目录</span><br><span class="hljs-attr">custom_css:</span> <span class="hljs-string">/css/custom.css</span><br><br><span class="hljs-comment"># 自定义 &lt;head&gt; 节点中的 HTML 内容</span><br><span class="hljs-attr">custom_head:</span> <span class="hljs-string">&#x27;&lt;meta name=&quot;key&quot; content=&quot;value&quot;&gt;&#x27;</span><br><br><span class="hljs-comment"># 自定义底部 HTML 内容（位于 footer 上方），也可用于外部引入 js css 这些操作，注意不要和 post.custom 配置冲突</span><br><span class="hljs-attr">custom_html:</span> <span class="hljs-string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css&quot;&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Slogan-打字机"><a href="#Slogan-打字机" class="headerlink" title="Slogan(打字机)"></a>Slogan(打字机)</h3><p>标题文字默认开启了打字机动效，相关配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">fun_features:</span><br>  <span class="hljs-attr">typing:</span> <span class="hljs-comment"># 为 subtitle 添加打字机效果</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typeSpeed:</span> <span class="hljs-number">70</span> <span class="hljs-comment"># 打印速度</span><br>    <span class="hljs-attr">cursorChar:</span> <span class="hljs-string">&quot;_&quot;</span> <span class="hljs-comment"># 游标字符</span><br>    <span class="hljs-attr">loop:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否循环播放效果</span><br></code></pre></td></tr></table></figure><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>若要手动指定摘要，使用 <!-- more --> MD文档里划分，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文的一部分作为摘要</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">余下的正文</span><br></code></pre></td></tr></table></figure><p>或者在 Front-matter 里设置 excerpt 字段，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ul><li>无论哪种摘要都最多显示 3 行，当屏幕宽度不足时会隐藏部分摘要。</li></ul><h3 id="文章跳转方式"><a href="#文章跳转方式" class="headerlink" title="文章跳转方式"></a>文章跳转方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_blank</span><br></code></pre></td></tr></table></figure><ul><li>_blank：新标签页打开</li><li>_self：当前标签页打开</li></ul><h3 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h3><p>如果想把某些文章隐藏起来，不在首页和其他分类里展示，可以在文章开头 Front-matter 中配置 hide: true 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><ul><li>隐藏会使文章在分类和标签类里都不显示</li><li>隐藏后依然可以通过文章链接访问</li></ul><h3 id="文章排序"><a href="#文章排序" class="headerlink" title="文章排序"></a>文章排序</h3><p>如果想手动将某些文章固定在首页靠前的位置，在文章开头 Front-matter 中配置 sticky 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><ul><li>sticky 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</li></ul><h3 id="文章在首页的封面图"><a href="#文章在首页的封面图" class="headerlink" title="文章在首页的封面图"></a>文章在首页的封面图</h3><p>对于单篇文章，在文章开头 Front-matter 中配置 index_img 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h3 id="文章页顶部大图"><a href="#文章页顶部大图" class="headerlink" title="文章页顶部大图"></a>文章页顶部大图</h3><p>默认显示主题配置中的 post.banner_img，如需要设置单个文章的 Banner，在 Front-matter 中指定 banner_img 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h3 id="文章内容本地图片"><a href="#文章内容本地图片" class="headerlink" title="文章内容本地图片"></a>文章内容本地图片</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-type">![](/img/example.jpg)</span><br></code></pre></td></tr></table></figure><h3 id="日期-x2F-字数-x2F-阅读时长-x2F-阅读数"><a href="#日期-x2F-字数-x2F-阅读时长-x2F-阅读数" class="headerlink" title="日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数"></a>日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数</h3><p>显示在文章页大标题下的文章信息，除了作者和阅读次数，其他功能都是默认开启的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">author:</span>  <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">date:</span>  <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;dddd, MMMM Do YYYY, h:mm a&quot;</span>  <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-attr">wordcount:</span>  <span class="hljs-comment"># 字数统计</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">min2read:</span>  <span class="hljs-comment"># 阅读时间</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span><br>    <span class="hljs-attr">views:</span>  <span class="hljs-comment"># 阅读次数</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span>  <span class="hljs-comment"># 统计数据来源，可选：leancloud | busuanzi   注意不蒜子会间歇抽风</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br></code></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>将脚注写在文末，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文</span><br><br><span class="hljs-comment">## 参考</span><br>[<span class="hljs-string">^1</span>]<span class="hljs-string">:</span> <span class="hljs-string">参考资料1</span><br>[<span class="hljs-string">^2</span>]<span class="hljs-string">:</span> <span class="hljs-string">参考资料2</span><br></code></pre></td></tr></table></figure><h3 id="Tag-插件"><a href="#Tag-插件" class="headerlink" title="Tag 插件"></a>Tag 插件</h3><p>在 markdown 中加入如下的代码来使用便签</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br><br>使用时 &#123;% note primary %&#125; 和 &#123;% endnote %&#125; 需单独一行，否则会出现问题<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-info">info</p><p class="note note-light">light</p><h3 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h3><p>在 markdown 中加入如下的代码来使用 Label：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% label primary @text %&#125;<br><br>若使用 &#123;% label primary @text %&#125;，text 不能以 @ 开头<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;label label-primary&quot;</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class="label label-primary">primary</span> <span class="label label-default">default</span> <span class="label label-info">info</span> <span class="label label-success">success</span> <span class="label label-warning">warning</span> <span class="label label-danger">danger</span></p><h3 id="组图"><a href="#组图" class="headerlink" title="组图"></a>组图</h3><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% gi total n1-n2-... %&#125;<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>&#123;% endgi %&#125;<br><br>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-...：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式<br>如下图为 &#123;% gi 5 3-2 %&#125; 示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。<br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div></div></div><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>标签是以词云的形式展示，标签的大小和颜色会根据标签下的文章数量变化，相关配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tag:</span><br>  <span class="hljs-attr">tagcloud:</span><br>    <span class="hljs-attr">min_font:</span> <span class="hljs-number">15</span><br>    <span class="hljs-attr">max_font:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">unit:</span> <span class="hljs-string">px</span>  <span class="hljs-comment"># 字号单位</span><br>    <span class="hljs-attr">start_color:</span> <span class="hljs-string">&quot;#BBBBEE&quot;</span><br>    <span class="hljs-attr">end_color:</span> <span class="hljs-string">&quot;#337ab7&quot;</span><br></code></pre></td></tr></table></figure><h3 id="友情链接页"><a href="#友情链接页" class="headerlink" title="友情链接页"></a>友情链接页</h3><p>友情链接页用于展示好友的博客入口，默认关闭，开启需要先在 navbar 项中将 links 的注释(#号)删掉：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;links&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/links/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-link-fill&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>然后找到 links 的配置项，对页面内容进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">links:</span><br>  <span class="hljs-attr">items:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Fluid Docs&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;主题使用指南&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span><br>    &#125;<br>  <span class="hljs-attr">default_avatar:</span> <span class="hljs-string">/img/avatar.png</span><br></code></pre></td></tr></table></figure><ul><li>title: 友链站的标题</li><li>intro: 站点或博主的简介，可省略</li><li>link: 跳转链接</li><li>avatar: 头像图片，可省略</li><li>default_avatar: 成员的默认头像（仅在指定了头像并且加载失败时生效）</li></ul><p>友链页也可以使用自定义区域和评论，使用方式类似于文章页，具体见配置项与相关注释。</p><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><p>如果想单独生成一个页面，步骤和创建「关于页」类似<br>先用命令行创建页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page example<br></code></pre></td></tr></table></figure><p>创建成功后编辑博客目录下 &#x2F;source&#x2F;example&#x2F;index.md：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">若不填默认是</span> <span class="hljs-string">title</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>正文默认没有 Markdown 样式，如果希望和文章相同的样式，可以加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;markdown-body&quot;</span>&gt;</span><br>正文<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面的参数配置可以在主题配置中统一设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">page:<br>  banner_img: /img/default.png<br>  banner_img_height: 70<br>  banner_mask_alpha: 0.3<br></code></pre></td></tr></table></figure><p>也可以直接在 Front-matter 里单独设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br><span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br><span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.5</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里可以写正文</span><br></code></pre></td></tr></table></figure><h3 id="Fluid-注入代码"><a href="#Fluid-注入代码" class="headerlink" title="Fluid 注入代码"></a>Fluid 注入代码</h3><p>进入博客目录下 scripts 文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">filter</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">injects</span>) &#123;<br>  injects.<span class="hljs-property">header</span>.<span class="hljs-title function_">file</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;source/_inject/test1.ejs&#x27;</span>, &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;, -<span class="hljs-number">1</span>);<br>  injects.<span class="hljs-property">footer</span>.<span class="hljs-title function_">raw</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;&lt;script async src=&quot;https://xxxxxx&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>header 和 footer 是注入点的名称，表示代码注入到页面的什么位置；</li><li>file 方法表示注入的是文件，第一个参数下面介绍，第二个参数则是文件的路径，第三个参数是传入文件的参数（可省略），第四个参数是顺序（可省略）；</li><li>raw 方法表示注入的是原生代码，第一个参数下面介绍，第二个参数则是一句原生的 HTML 语句；</li><li>default 表示注入的键名，可以使用任意键名，同一个注入点下的相同键名会使注入的内容覆盖，而不同键名则会让内容依次排列（默认按执行先后顺序，可通过 file 第四个参数指定），这里 default 为主题默认键名，通常会替换掉主题默认的组件；</li></ul><p>主题目前提供的注入点如下：</p><table><thead><tr><th>注入点名称</th><th>注入范围</th><th>存在 <code>default</code> 键</th></tr></thead><tbody><tr><td>head</td><td><code>&lt;head&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>header</td><td><code>&lt;header&gt;</code> 标签中所有内容</td><td>有</td></tr><tr><td>bodyBegin</td><td><code>&lt;body&gt;</code> 标签中的开始</td><td>无</td></tr><tr><td>bodyEnd</td><td><code>&lt;body&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>footer</td><td><code>&lt;footer&gt;</code> 标签中所有内容</td><td>有</td></tr><tr><td>postMetaTop</td><td>文章页 <code>&lt;header&gt;</code> 标签中 meta 部分内容</td><td>有</td></tr><tr><td>postMetaBottom</td><td>文章页底部 meta 部分内容</td><td>有</td></tr><tr><td>postMarkdownBegin</td><td><code>&lt;div class=&quot;markdown-body&quot;&gt;</code> 标签中的开始</td><td>无</td></tr><tr><td>postMarkdownEnd</td><td><code>&lt;div class=&quot;markdown-body&quot;&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>postLeft</td><td>文章页左侧边栏</td><td>有</td></tr><tr><td>postRight</td><td>文章页右侧边栏</td><td>有</td></tr><tr><td>postCopyright</td><td>文章页版权信息</td><td>有</td></tr><tr><td>postRight</td><td>文章页右侧边栏</td><td>无</td></tr><tr><td>postComments</td><td>文章页评论</td><td>有</td></tr><tr><td>pageComments</td><td>自定义页评论</td><td>有</td></tr><tr><td>linksComments</td><td>友链页评论</td><td>有</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Hello World</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
