<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>云原生词汇表</title>
    <link href="/2023/08/16/Cloud-Native-Glossary/"/>
    <url>/2023/08/16/Cloud-Native-Glossary/</url>
    
    <content type="html"><![CDATA[<p>云原生词汇表是由 CNCF 商业价值小组委员会 (BVS, Business Value Subcommittee) 领导的一个项目。 该项目的目的是在不需要任何先决技术知识的情况下，以通俗易懂的语言阐释云原生概念。</p><span id="more"></span><p><strong>参考资料</strong><br><a href="https://glossary.cncf.io/">Cloud Native(云原生) Glossary</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12因素应用程序图解</title>
    <link href="/2023/08/16/12-Factor-Apps/"/>
    <url>/2023/08/16/12-Factor-Apps/</url>
    
    <content type="html"><![CDATA[<p>云原生架构设计方法论——12因素应用程序图解，12 Factor</p><span id="more"></span><h2 id="严重参考"><a href="#严重参考" class="headerlink" title="严重参考"></a>严重参考</h2><p><a href="https://resources.sei.cmu.edu/asset_files/Presentation/2016_017_001_454665.pdf">The Twelve-Factor App （简体中文） (12factor.net)</a></p><p><a href="https://www.redhat.com/architect/12-factor-app">An illustrated guide to 12 Factor Apps | Enable Architect (redhat.com)</a></p><p><a href="https://developer.ibm.com/articles/creating-a-12-factor-application-with-open-liberty/">Creating cloud-native applications: 12-factor applications – IBM Developer</a></p><p><a href="https://ngeninv.hashnode.dev/12-factor-app">12 Factor App (hashnode.dev)</a></p><p><a href="https://resources.sei.cmu.edu/asset_files/Presentation/2016_017_001_454665.pdf">12 Factor Apps: A Scorecard (cmu.edu)</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.darklorder.com/img/202308161207731.jpeg"></p><p>12要素应用程序（12-Factor App）早在2011年就由 Adam Wiggins 发布。</p><p>12要素应用程序是一套原则，一种软件工程的方法论，产出的代码，能够<strong>可靠地发布，快速的扩展，并以一致和可预知的方式</strong>维护。</p><p>然而，这种方法论创建于十年前，云技术自最初创建以来已经取得了进步。</p><p>为了使应用程序能够<strong>真正利用现代云基础设施和工具，并在云中蓬勃发展</strong>，而不是仅仅在云中生存，Kevin Hoffman 修订了最初的12个因素，并增加了三个额外的因素——15因素应用程序方法论: <a href="https://www.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/">超越12因素应用程序</a>。</p><p>12要素应用程序的原文，不太好理解。这里编译了一些资料，以图文的方式梳理如下。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>12要素应用程序是由 Heroku 的开发人员定义的一种方法论，用于构建软件即服务（SaaS）或者云原生（cloud-native）的应用程序:</p><ul><li>使用<strong>声明式（declarative）</strong>格式自动化安装，这样可以最大限度地减少新加入项目的开发人员的时间和成本</li><li>与底层操作系统有一个<strong>整洁的契约（clean contract）</strong>，这样可以提供运行环境之间的<strong>最大可移植性（maximum portability）</strong></li><li>适合在<strong>现代云平台（cloud platform）</strong>上<strong>部署（deployment）</strong>，这样可以除去服务器和系统管理；</li><li>在开发和生产环境之间<strong>最小化分歧（minimize divergence）</strong>，这样可以支持最高敏捷程度的<strong>持续部署（continuous deployment）</strong></li><li>可以在不对工具、架构或开发实践进行重大更改的情况下进行<strong>扩展（scale up）</strong></li></ul><p><a href="https://12factor.net/">12因素</a></p><ol><li>One codebase, one application - 一个代码库，一个应用程序</li><li>Dependency management - 依赖管理</li><li>Design, build, release, and run - 设计、构建、发布和运行</li><li>Configuration, credentials, and code - 配置、证书和代码</li><li>Logs - 日志</li><li>Disposability - 易处理</li><li>Backing services - 后端服务</li><li>Environment parity - 环境等价</li><li>Administrative processes - 管理进程</li><li>Port binding - 端口绑定</li><li>Stateless processes - 无状态进程</li><li>Concurrency - 并发性</li></ol><p>为了云原生应用程序而<a href="https://developer.ibm.com/articles/15-factor-applications/">新增加3个因素</a>：</p><ol><li>API first - API 优先</li><li>Telemetry - 遥测</li><li>Authentication and authorization - 认证和授权</li></ol><h2 id="1-Codebase"><a href="#1-Codebase" class="headerlink" title="1. Codebase"></a>1. Codebase</h2><p><strong>1. 基准代码</strong></p><blockquote><p>One codebase tracked in revision control, many deploys<br>一份基准代码记录在版本控制中，多份部署</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207746.jpeg"></p><p><strong>基准代码</strong>原则：所有与应用程序相关的资产，包括源代码、配置脚本和配置设置，都存储在一个可供开发人员、测试人员和系统管理人员访问的源代码仓库中。</p><p>所有自动化脚本都可以访问源代码仓库，这是持续集成&#x2F;持续交付（Continuous Integration&#x2F;Continuous Delivery，CI&#x2F;CD）过程的一部分，这些过程是企业软件开发生命周期（Software Development Lifecycle，SDLC）的一部分。</p><p><strong>云原生应用程序，必须始终由单个基准代码组成，且跟踪在版本控制系统中。</strong>基准代码是一个源代码仓库或一组存储库，它们共享一个公共根，用于生成任意数量的不可变发行版。应用程序和基准代码之间应该存在<strong>1:1</strong>的关系，但应用程序的基准代码和部署之间应该存在<strong>一对多</strong>的关系。</p><p>这个单独的基准代码有助于支持开发团队之间的协作，并有助于实现应用程序的正确版本控制。</p><p>Git是目前最常见的版本控制工具之一。</p><h2 id="II-Dependencies"><a href="#II-Dependencies" class="headerlink" title="II. Dependencies"></a>II. Dependencies</h2><p><strong>2. 依赖关系</strong></p><blockquote><p>Explicitly declare and isolate dependencies<br>显式声明和隔离依赖关系</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207939.jpeg"></p><p><strong>依赖关系</strong>原则：只有与应用程序的用途唯一相关的代码存储在源代码控制系统中。</p><p>外部构件，如 Node.js 的 package、Java 的 Jar、NET 的 dll，在开发、测试和生产运行时，都应该引用自被加载到内存中的依赖关系清单。需要避免将构件和源代码一起存储在源代码仓库中。</p><p><strong>云原生应用程序永远不能依赖于系统级包的隐式存在。</strong>这就是这个要素所关注的——鼓励显式声明和隔离应用程序的依赖关系。这有助于提供开发和生产环境之间的一致性，简化应用程序新手开发人员的设置，并支持云平台之间的可移植性。</p><p>大多数当代编程语言都有管理这些依赖关系的工具或工具。这些工具有助于简化依赖管理固有的复杂性，使开发人员能够声明他们的依赖关系，然后让工具负责实际确保这些依赖关系得到满足。</p><h2 id="III-Config"><a href="#III-Config" class="headerlink" title="III. Config"></a>III. Config</h2><p>3. <strong>配置</strong></p><blockquote><p>Store configuration in the environment<br>在环境中存储配置</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207372.jpeg"></p><p><strong>配置</strong>原则：配置信息以环境变量或独立配置文件中定义的设置，注入到各种运行环境中。在某些情况下，允许在代码中存储可以直接被覆盖的默认设置，例如端口号、依赖 URL，但是 DEBUG 等状态设置应该单独存在并在部署时进行覆盖。</p><p>外部配置文件的好例子是 Java properties文件、 Kubernetes manifest文件或 docker-compose.yml 文件。</p><p><strong>云原生应用程序不应该关心它在什么环境中运行，我们也不应该需要改变应用程序来在不同的环境中运行它。</strong>将这些配置值存储在环境变量中被认为是外化此配置的最佳实践。这种方法有助于简化应用程序在多个环境中的部署，降低证书和密码泄漏的风险，并支持更有效的发布管理。</p><h2 id="IV-Backing-Services"><a href="#IV-Backing-Services" class="headerlink" title="IV. Backing Services"></a>IV. Backing Services</h2><p><strong>4. 后端服务</strong></p><blockquote><p>Treat backing services as attached resources<br>将后端服务视为附加资源</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207292.jpeg"></p><p><strong>后端服务</strong>原则：鼓励架构师将外部组件，如数据库、电子邮件服务器、消息代理以及可由系统人员提供和维护的独立服务作为附加资源。将资源视为后端服务可以提高软件开发生命周期(SDLC)中的灵活性和效率。</p><p><strong>云原生应用程序应声明其对给定后端服务的需求，但允许云环境执行实际的资源绑定。</strong>应用程序与其后端服务的绑定应该通过外部配置完成。应该可以随意附加和分离应用程序的后端服务，而不需要重新部署应用程序。应用程序中不应该有一行代码将应用程序与特定的后端服务紧密耦合。</p><p>将后端服务作为绑定资源使得云原生应用程序具有更大的灵活性和弹性，从而支持服务和部署之间的松散耦合。</p><h2 id="V-Build-Release-Run"><a href="#V-Build-Release-Run" class="headerlink" title="V. Build, Release, Run"></a>V. Build, Release, Run</h2><p><strong>5. 构建，发布，运行</strong></p><blockquote><p>Strictly separate build and run stages<br>严格区分构建和运行阶段</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207549.jpeg"></p><p><strong>构建、发布和运行</strong>的原则：将部署过程分解为三个可复制的阶段，可以在任何时候进行实例化。</p><ol><li><strong>构建</strong>阶段是从源代码管理系统检出代码，并构建&#x2F;编译成存储在构件仓库(如 Docker Hub 或 Maven 仓库)中的构件的阶段。</li><li>在编译代码之后，<strong>发布</strong>阶段应用配置设置。</li><li>在<strong>运行</strong>阶段，使用 Ansible 之类的工具通过脚本提供一个执行运行环境。应用程序及其依赖关系被部署到新配置的运行环境中。</li></ol><p><strong>构建、发布和运行</strong>的关键是这个过程是完全瞬息的。如果流水线上的任何东西被破坏，所有的构件和环境都可以使用存储在源代码仓库中的资产从零再造。</p><p><strong>对于云原生应用程序而言，关键在于，每个部署阶段都是独立的，并且是单独发生的。</strong>一旦运行，云运行时将负责其维护、健康和动态扩展。</p><h2 id="VI-Processes"><a href="#VI-Processes" class="headerlink" title="VI. Processes"></a>VI. Processes</h2><p><strong>6. Processes</strong> <strong>进程</strong></p><blockquote><p>Execute the app as one or more stateless processes<br>将应用程序作为一个或多个无状态进程执行</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207401.jpeg"></p><p><strong>进程</strong>原则：可以更准确地称为无状态进程，在12要素应用程序结构下开发的应用程序将作为无状态进程的集合运行。这意味着没有单个进程跟踪另一个进程的状态，也没有进程跟踪会话或工作流状态等信息。</p><p><strong>无状态的云原生进程使扩展更加容易。</strong>当流程是无状态的时候，可以添加和删除实例，以解决给定时间点的特定负载负担。由于每个进程都是独立运行的，无状态可以防止意想不到的副作用。</p><h2 id="VII-Port-Binding"><a href="#VII-Port-Binding" class="headerlink" title="VII. Port Binding"></a>VII. Port Binding</h2><p><strong>Port binding</strong> <strong>端口绑定</strong></p><blockquote><p>Export services via port binding<br>通过端口绑定发布服务</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207767.jpeg"></p><p><strong>端口绑定</strong>原则：服务或应用程序可以通过端口号而不是域名来给网络识别。其理由是，域名和相关的 IP 地址可以通过手动操作和自动服务发现机制动态分配。因此，用它们作为参考点是不可靠的。但是，根据端口号将服务或应用程序暴露给网络更可靠，也更容易管理。</p><p>端口绑定原则背后的基本思想是，统一使用端口号是向网络公开进程的最佳方式。</p><p>例如，已经出现的模式是端口80是传统的运行在 HTTP 下的 web 服务器，端口443是 HTTPS 的默认端口号，端口22是 SSH，端口3306是 MySQL 的默认端口，端口27017是 MongoDB 的默认端口。</p><p><strong>云原生应用程序应该使用端口绑定输出服务。</strong></p><h2 id="VIII-Concurrency"><a href="#VIII-Concurrency" class="headerlink" title="VIII. Concurrency"></a>VIII. Concurrency</h2><p><strong>Concurrency</strong> <strong>并发性</strong></p><blockquote><p>Scale-out via the process model<br>通过进程模型横向扩展</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207801.jpeg"></p><p><strong>并发</strong>原则：建议根据进程的用途来组织进程，然后将这些进程分开，以便可以根据需要扩展和缩小（scale up and down）这些进程。</p><p>如上图所示，应用程序通过在负载均衡器后面运行的 web 服务器向网络公开。负载均衡器后面的 web 服务器组，依次使用业务服务流程中的业务逻辑，这些业务逻辑在自己的负载均衡器后面运行。如果 web 服务器的负载增加，可以单独扩大这个小组，以满足眼前的需求。但是，如果由于业务服务的负载而出现瓶颈，则可以独立地扩展该层。</p><p>支持并发意味着应用程序的不同部分可以扩展以满足眼前的需要。否则，当不支持并发时，架构除了垂直扩展整个应用程序之外别无选择。</p><p><strong>云原生应用程序的一种云支持的弹性可伸缩性的理想方法，是向外扩展，或者水平扩展。</strong>与其让单个大进程变得更大，不如创建多个进程，并将应用程序的负载分配给这些进程。</p><h2 id="IX-Disposability"><a href="#IX-Disposability" class="headerlink" title="IX. Disposability"></a>IX. Disposability</h2><p>易处理</p><blockquote><p>Maximize robustness with fast start-up and graceful shutdown<br>快速启动和优雅终止可最大化稳健性</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207800.jpeg"></p><p>看待这个问题的一种方式是牛和宠物的对比模型。应用实例应该更多地被视为牛(即，对它们没有情感上的依恋，相当容易替换，编号没有命名等) ，而不是宠物(即，有情感上的依恋，健康恢复护理而不是替换，等等)。</p><p><strong>易处理</strong>原则：应用程序应该优雅地启动和停止。这意味着在使用者可以访问应用程序之前，必须完成所有必需的“家务活”。例如，一个优雅的启动将确保所有数据库连接和对其他网络资源的访问都是可使用的。此外，需要进行的任何其他配置工作都已经完成。</p><p>在关机方面，易处理倡导者确保所有数据库连接和其他网络资源正确终止，并确保所有关机活动都被记录下来，如下面的代码示例所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">shutdown</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">signal</span>) =&gt; &#123;<br>   logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Disconnecting message broker at <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;</span>`</span>);<br>   messageBroker.<span class="hljs-title function_">disconnect</span>();<br><br>   logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Disconnecting database at <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;</span>`</span>);<br>   database.<span class="hljs-title function_">disconnect</span>();<br><br>   <span class="hljs-keyword">let</span> shutdownMessage;<br><br>   <span class="hljs-keyword">if</span> (!signal) &#123;<br>       shutdownMessage = (<span class="hljs-string">`MyCool service shutting down at <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;</span>`</span>);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>       shutdownMessage = (<span class="hljs-string">`Signal <span class="hljs-subst">$&#123;signal&#125;</span> : MyCool service shutting down at <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;</span>`</span>);<br>   &#125;<br>   <span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&quot;SHUTDOWN&quot;</span>, shutdownMessage, <span class="hljs-attr">pid</span>: process.<span class="hljs-property">pid</span>&#125;;<br>   <span class="hljs-keyword">await</span> server.<span class="hljs-title function_">close</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<br>       process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);<br>   &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>云原生应用程序的进程必须是易处理的，这意味着它们可以快速启动或停止。如果应用程序不能快速启动并优雅地关闭，那么它就不能迅速扩展、部署、发布或恢复。如果启动一个应用程序，并且需要几分钟才能进入稳定状态，在当今流量高的世界中，这可能意味着在应用程序启动时，成百上千的请求被拒绝。</p><p>无法足够快速地关闭也可能带来无法处理资源的风险，这可能会破坏数据。</p><h2 id="X-Dev-x2F-Prod-Parity"><a href="#X-Dev-x2F-Prod-Parity" class="headerlink" title="X. Dev&#x2F;Prod Parity"></a>X. Dev&#x2F;Prod Parity</h2><p><strong>10. 开发与生产环境等价</strong></p><blockquote><p>Keep development, staging, and production as similar as possible<br>尽可能保持开发、预发布和生产环境相同</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207186.jpeg"></p><p><strong>开发与生产环境等价</strong>原则：所有的部署路径都是相似的但又是独立的，并且没有部署“蛙跳”到另一个部署目标。</p><p>上图显示了应用程序代码的两个版本。V1版本的目标是发布到生产环境。新版本 V2的目标是一个开发环境。V1和 V2遵循类似的部署路径，从<strong>构建</strong>到<strong>发布</strong>，然后<strong>运行</strong>。如果代码的 V2版本已经准备好投入生产，那么与 V2相关的构件和设置将<strong>不会</strong>被复制到生产环境中（图中红<strong>X</strong>）。</p><p>相反，CI&#x2F;CD 流程将被调整以设置 V2到 生产环境的部署目标。CI&#x2F;CD 流程将遵循预期的针对新目标的<strong>构建、发布和运行</strong>模式。</p><p><strong>开发与生产环境等价</strong>与<strong>构建、发布和运行</strong>非常相似。重要的区别在于<strong>开发与生产环境等价</strong>确保了生产部署过程与开发部署过程相同。这样就可以确保所有潜在的错误&#x2F;故障都可以在开发和测试中识别出来，而不是在应用程序投入生产时识别出来。</p><p>像 Docker 这样的工具可以帮助实现这种开发&#x2F;测试&#x2F;生产环境的等价。容器的好处是它为运行代码创建和使用相同的映像，提供了绝对统一的环境。它还有助于确保在每个环境中使用相同的后端服务。</p><h2 id="XI-Logs"><a href="#XI-Logs" class="headerlink" title="XI. Logs"></a>XI. Logs</h2><p><strong>11. Logs</strong> <strong>日志</strong></p><blockquote><p>Treat logs as event streams<br>将日志视为事件流</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207315.jpeg"></p><p><strong>日志</strong>原则：将日志数据发送到一个流中，各种感兴趣的消费者可以访问这个流。路由日志数据的过程需要与处理日志数据分开。</p><p>例如，一个消费者可能只对 Error 数据感兴趣，而另一个消费者可能对 Request&#x2F;Response 数据感兴趣。另一个消费者可能对存储用于事件归档的所有日志数据感兴趣。</p><p>一个额外的好处是，即使一个应用程序消亡，日志数据在之后仍然存在。</p><p>云原生应用程序的日志聚合、处理和存储，是云提供商或其他工具套件(例如，ELK 技术栈、 Splunk 等)的职责，这些工具套件与正在使用的云平台一起运行。<strong>通过简化应用程序在日志聚合和分析中的部分，可以简化应用程序的代码库，并更多地关注业务逻辑。</strong></p><h2 id="XII-Admin-Processes"><a href="#XII-Admin-Processes" class="headerlink" title="XII. Admin Processes"></a>XII. Admin Processes</h2><p><strong>管理进程</strong></p><blockquote><p>Run admin&#x2F;management tasks as one-off processes<br>将管理任务作为一次性进程运行</p></blockquote><p><img src="https://img.darklorder.com/img/202308161207330.jpeg"></p><p><strong>管理进程</strong>原则：管理进程是软件开发生命周期中的一等公民，需要被这样对待。</p><p>上图显示了作为 Docker 容器部署的名为 Orders 的服务。此外，还有一个管理服务名为 dataSeeder，可以将数据种子化到 Orders 服务中。服务 dataSeeder 是一个管理进程，用于与 Orders 一起使用，如下图所示。</p><p><img src="https://img.darklorder.com/img/202308161207998.jpeg"></p><p>但是，即使 dataSeeder 是一个管理进程，它也会被赋予一个类似于 Orders 服务的 Build、 Release 和 Run 部署路径。此外，它是根据<strong>基准代码</strong>和<strong>开发与生产环境等价</strong>的原则发布的。<strong>管理进程</strong> dataSeeder <strong>与整个 SDLC 不是分离的，而是它的一部分。</strong></p><h2 id="XIII-API-first"><a href="#XIII-API-first" class="headerlink" title="XIII. API first"></a>XIII. API first</h2><p><strong>13. API优先</strong></p><p><img src="https://img.darklorder.com/img/202308161208639.jpeg"></p><p><strong>API优先</strong>原则：应用程序通常会成为服务生态系统的参与者。但是，如果应用程序中没有明确定义 API，这可能会导致在这个生态系统中的集成失败。</p><p>API 优先方法包括开发一致且可重用的 API，使团队能够针对彼此的公共契约进行工作，而不会干扰内部开发过程。通过使用 API 优先的方法，并清楚地规划客户端应用程序和服务将使用的各种 API，每个 API 都可以被设计得尽可能有效，并且可以很容易地进行模拟。</p><p>API 描述语言可以帮助建立一个关于 API 应该如何行为的契约。API 描述语言是领域特定语言（DSL），这适合于描述 API。与编程语言或 API 实现语言相比，API 描述语言使用更高层次的抽象和声明性范式，这意味着可以使用它们来帮助表达“什么”而不是“如何”。</p><p><strong>API 的引入是为了强调 API 在云原生应用程序开发中的重要性</strong>。为云开发的应用程序通常是分布式服务生态系统的参与者，如果没有明确定义 API，这可能会导致集成失败的噩梦。因此，在设计在云中蓬勃发展的应用程序时，这个因素非常重要。</p><h2 id="XIV-Telemetry"><a href="#XIV-Telemetry" class="headerlink" title="XIV. Telemetry"></a>XIV. Telemetry</h2><p><strong>14. 遥测</strong></p><p><img src="https://img.darklorder.com/img/202308161208382.jpeg"></p><p><strong>遥测</strong>原则：遥测让云端的应用程序及其行为具有更深层次的可见性。运行在云端的应用程序实例可能在很少或没有警告的情况下移动到世界的任何地方。除此之外，可能开始时只有应用程序的一个实例，几分钟后，您可能已经运行了数百个应用程序副本。</p><p>遥测技术可以包括领域特定的指标，以及应用程序的健康和系统指标。健康度量和系统度量包括应用程序启动、关闭、伸缩、 web 请求跟踪和定期健康检查的结果。</p><p><strong>云原生应用程序的遥测技术是日志记录的重要补充</strong>。遥测技术的重点是数据收集。遥测和实时应用程序监控使开发人员能够在这个复杂和高度分布式的环境中监控应用程序的性能、健康状况和关键指标。</p><h2 id="XV-Authentication-and-authorization"><a href="#XV-Authentication-and-authorization" class="headerlink" title="XV. Authentication and authorization"></a>XV. Authentication and authorization</h2><p><strong>15. 认证和授权</strong></p><p><img src="https://img.darklorder.com/img/202308161208669.jpeg"></p><p><strong>认证和授权</strong>原则：安全性是任何应用程序和云环境的重要组成部分。</p><p>云原生应用程序可以使用基于以角色为基础的访问控制(role-based access control，RBAC)来保护其端点。这些角色规定调用的客户端是否具有足够的权限，以便应用程序能够响应请求，并为审计需要帮助跟踪发出请求的人。</p><p><strong>认证和授权要素的添加是为了强调云原生应用程序的安全性</strong>。在云环境中部署应用程序意味着应用程序可以跨越世界各地的许多数据中心传输，在多个容器中执行，并由几乎无限数量的客户端访问。</p><p>不管这个应用程序是为企业、移动设备还是云服务而设计的，安全性都不应该是事后才考虑的问题。</p><h2 id="12因素应用程序打分表"><a href="#12因素应用程序打分表" class="headerlink" title="12因素应用程序打分表"></a>12因素应用程序打分表</h2><p>最后，是一份使用12因素评估应用程序的打分表，看看你的应用程序有几分。</p><table><thead><tr><th>12因素</th><th>打分（分数越高，越符合）</th></tr></thead><tbody><tr><td>基准代码</td><td>1. 使用电子邮件发送不同名称的src zip <br />2. 频繁地提交到源代码控制系统（所有代码使用同一个仓卡）  <br />3. 应用程序拆分成独立的部分，每个部分都有自有的仓库</td></tr><tr><td>依赖管理</td><td>1. 手动下载jar到&#x2F;lib。  <br />2. 使用软件包管理器（mvn、npm），期望提供工具(curl)  <br />3. 使用 artifact 管理器（Artifactory），捆绑依赖项和工具</td></tr><tr><td>配置、证书和代码</td><td>1. 硬代码 URL，密码在代码中，使用像if(Mode.PROD) 的代码  <br />2. 使用配置文件，不同环境的多个配置文件  <br />3. 使用配置服务（Spring Cloud Config、Zookeeper）</td></tr><tr><td>后端服务</td><td>1. 供应商特定的连接库，硬代码连接字符串  <br />2. 连接参数存在在配置文件中  <br />3. 动态发现资源，独立地更新后端服务</td></tr><tr><td>设计、构建、发布和运行</td><td>1. 开发从本地构建和部署代码，生产环境由手动推送  <br />2. 使用构建&#x2F;发布工具(Jenkins，TravisCI)，清晰地分离构建和部署步骤  <br />3. 有一键点击发布流水线，每个发布都用版本控制并保存用于回滚，没有人工干预</td></tr><tr><td>无状态进程</td><td>1. 粘性会话，将应用程序数据写入到本地文件系统  <br />2. 不依赖于本地存储的数据  <br />3. 无状态，将会话数据存储在数据存储中(redis)，缓存中间阶段的事务步骤</td></tr><tr><td>端口绑定</td><td>1. 部署到应用程序容器  <br />2. 单机的，但监听特定的端口  <br />3. Web服务器是应用程序的一部分(node，netty)，应用程输出HTTP服务</td></tr><tr><td>并发性</td><td>1. 必须顺序运行的阻塞式任务  <br />2. 非阻塞式IO服务器（node、netty） <br />3. 水平扩展，小型、独立的微服务</td></tr><tr><td>易处理</td><td>1. 需要一个开发人员来协调重启  <br />2. 快速启动  <br />3. 优雅地崩溃，低于1秒重新启动，存储状态以快速恢复</td></tr><tr><td>环境等价</td><td>1. 开发人员对生产环境没有了解，开发环境不同于生产环境  <br />2. 用轻量级替换品（内存H2、SQLite）替代  <br />3. 环境是相同的</td></tr><tr><td>日志</td><td>1. System.out.print()  <br />2. 写入到web服务器上的日志文件  <br />3. 将日志当作流来处理(ELK)</td></tr><tr><td>管理进程</td><td>1. 手动编辑数据库条目  <br />2. 将迁移脚本存储在仓库中  <br />3. 使用框架的工具链</td></tr></tbody></table><p><strong>参考资料</strong><br><a href="https://zhuanlan.zhihu.com/p/452532308">云原生架构设计方法论——12因素应用程序图解，12 Factor - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后疫情时代：大重构</title>
    <link href="/2023/08/16/COVID-19-The-Great-Reset/"/>
    <url>/2023/08/16/COVID-19-The-Great-Reset/</url>
    
    <content type="html"><![CDATA[<p>“当危机结束后，有些人会突然发现他们的国家已经不再是那个他们愿意生活的地方了。这种心态的变化并不新鲜。过去几年中,政府和企业一直在使用越来越专业的技术来监测甚至操控公民和员工”。——《后疫情时代：大重构》</p><p>类似于，奥本海默对发明原子弹的晚年悔恨，“我们知道世界将不一样了。”</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机提供的生产力</title>
    <link href="/2023/08/16/computer/"/>
    <url>/2023/08/16/computer/</url>
    
    <content type="html"><![CDATA[<p>计算机提供两种重要的生产力，一种是解决繁琐重复性的劳作，一种是解决人解决不了的问题，前者替换人，后者超越人。</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iPhone今天这个大漏洞，让人打开App就被盗刷一万五。。。</title>
    <link href="/2023/07/24/Spend-money-to-buy-lessons/"/>
    <url>/2023/07/24/Spend-money-to-buy-lessons/</url>
    
    <content type="html"><![CDATA[<p>微信零钱每日限额一万，微笑</p><span id="more"></span><p>众所周知，苹果一直在宣传自己的安全、隐私、可控。</p><p>而且在过去，它也足够的安全。</p><p>但世界上也没有绝对坚固的墙，大家也别因为这样，就彻底放松警惕。</p><p>因为今天，它就翻车了。。。</p><center><img src="https://img.darklorder.com/img/202307311242237.gif"  alt="文件名" style="zoom:100%;" /></center><p>事情是这样的，一个网友的丈母娘被 App Store 应用商店里的 “骗子 App” 骗走了一万五千元。</p><p>直到目前，他们被盗刷的钱都没能追回。</p><p>而我在复盘完事情的完整经过之后发现，其中两个重要环节，都是苹果出现了问题。</p><p>但凡苹果在这两个环节中的任何一个环节有安全措施，也不至于让骗子得逞。</p><p>先跟大家聊聊大概发生了什么事吧，大家可以先看看原博主 airycanon 描述的事情经过~</p><p>上下滑动可以查看完整长图</p><p><a href="https://img.darklorder.com/img/202307311319978.jpg">图片</a></p><p>简单来说，就是 airycanon 的丈母娘从 AppStore 应用商店里下载了一个菜谱 App。</p><p>但是这个 App 本身有问题，打开 App 之后，首先会弹出一个 Apple 账号登录界面。</p><img src="https://img.darklorder.com/img/202307311248469.png"/><p>用过 iPhone 的小伙伴都知道，不少 App 都支持使用苹果账号一键注册登录，就像微信小程序一键登录一样。</p><p><strong>所以这一步看起来是合理的。</strong></p><p>但其实，真正的苹果一键登录界面，是这个样子的：</p><p>大家可以上下对比看看</p><img src="https://img.darklorder.com/img/202307311248753.png"/><p>菜谱 App 弹出的那个“假登录界面”，其实也是有用的，<strong>它在后台已经完成了一次苹果账号登录。</strong></p><p>至于有什么用途，我们放到后面再说。</p><p>登录弹窗之后，这个 App 又弹出一个仿照系统界面设计的密码输入界面。</p><p>因为长得和安装应用时候的密码验证界面很像，手机用的不那么灵光的老人还是很容易中招的。</p><p>App”L”eID。。。</p><img src="https://img.darklorder.com/img/202307311249332.png"/><p>自此，骗子就搞到了受害者 iPhone 的账号和密码。</p><p>假如用户给苹果账号绑定了支付方式 —— 就比如 airycanon 的丈母娘绑定了微信免密支付。。。</p><p>那骗子就可以开始盗号刷刷刷了。</p><p>u1s1，这个骗子绝对是个惯犯。<strong>他为了避免受害人收到短信交易提醒，盗刷之前甚至还利用查找 iPhone 远程把受害者的手机给重置恢复出厂设置了。。。</strong></p><p>这要是没用 iCloud 备份相册的人，不得气疯了。。。</p><p><strong>真·砂仁猪心。</strong></p><p>OK，事情大概就是这么一回事，讲道理，看完之后我整个人就是一个大写的懵。</p><p>首先，我倒是理解这种骗人 App 能堂而皇之在苹果官方 App Store 上架。。。</p><p><strong>因为骗过苹果商店审核的操作在业内根本不算什么秘密。</strong></p><p>马甲包、同 ID 双版本、幸运按钮。。。黑产总有办法。</p><img src="https://img.darklorder.com/img/202307311250825.png"/><p>比如我也在 App Store 里下载了几个菜谱大全，他们倒是没有盗我的密码，但是点开以后也都不是菜谱。</p><p><strong>而是一个个关不掉的强制弹窗，“ 帮 ” 我开各种彩铃包、权益合约包。。。</strong></p><img src="https://img.darklorder.com/img/202307311250766.png"/><p>难得遇到了一个正经菜谱 App，结果刚看了两个菜，就要收我 28。。。</p><p><strong>不对，是每周 28 块钱。。。</strong></p><p>我估计正经厨房类 App 的产品经理们都得看傻了：同行们黑心钱都这么好赚的吗？</p><p>“ 非强制消费”</p><img src="https://img.darklorder.com/img/202307311250241.png"/><p>但是，就算 App 能通过钓鱼的方式骗到受害者苹果账户的密码，但是苹果本身是有 “ 两步验证 ” 机制的呀？</p><p>在登录新设备或者浏览器的时候，除了输入密码，苹果还会要求输入一个短信验证码。</p><p>而且 airycanon 也在帖子里说明了，他丈母娘的 Apple ID 已经开启了两步验证。</p><p>但是他们自始至终没有收到苹果的验证码。</p><img src="https://img.darklorder.com/img/202307311251965.png"/><p>这时候他发现，<strong>丈母娘账号的两步验证设置里，多出来了一个从来没见过的境外号码。</strong></p><p>怪不得自己手机上没有验证码了，<strong>因为接收验证码的手机已经变成骗子的手机了。。。</strong></p><p>考虑到设置两步验证是一个挺复杂的操作、即使手把手跟丈母娘说都不一定能设置成功。</p><p>那这个号码只能是骗子偷偷添加进来的了。。。</p><img src="https://img.darklorder.com/img/202307311251618.png"/><p>这就很离谱了好吧，因为虽然“菜谱骗子”们骗过了苹果的 App 审核，<strong>但它们最多也只是诈骗，是在玩弄社会工程学，而不是病毒。</strong></p><p><strong>理论上来说，它们根本没有办法绕过苹果最根本的安全措施，在不弹任何验证码的情况下往苹果的双证验证系统里加入<strong><strong>能收验证码的新手机号</strong></strong>。。。</strong></p><p>这一点是我和编辑部小伙伴们都感觉非常诧异的，也是今天关注到这件事的网友们讨论最激烈的。</p><p>不过在一段讨论之后，研究苹果开发的 BugOS 技术组提到了一种可能的思路：</p><img src="https://img.darklorder.com/img/202307311252605.png"/><p>上面截图里的内容大家看不懂没关系，简单来说，<strong>苹果浏览器框架的安全策略出了问题。</strong></p><p>事情大概是这么回事：我们都知道，不管是 iPhone，还是安卓手机，系统里都会有一个预装的默认网页浏览器对不对。</p><img src="https://img.darklorder.com/img/202307311252308.png"/><p>比如 iPhone 上就是 Safiri，安卓这边则是各家的自带浏览器。</p><p>但这其实只是表面上的浏览器。</p><p>但其实，<strong>再往系统底层找，还有一个“没有图标”的浏览器框架：WebView。</strong></p><img src="https://img.darklorder.com/img/202307311252723.png"/><p>这个 “ 浏览器框架 ” 不能被普通用户在手机里直接点开，它存在的意义，是供其他 App 调用的。</p><p>我们举个例子，就比方说美团、滴滴他们经常在 App 里搞领券的活动，对于这种临时的活动页面一般就是写个网页。</p><img src="https://img.darklorder.com/img/202307311253933.png"/><p>这些 “ App 内的网页 ”，实际上都不是 App 本身在渲染，而是美团和滴滴拉起了系统里的 WebView 组件来进行渲染的。</p><p>这个组件其实帮了开发者很大的忙，假如没有 WebView 浏览器框架的话，包括美团和滴滴在内的所有 App 开发者，都得往 App 里再额外集成一个独立的浏览器内核。</p><p>本身现在的 App 们就已经很占存储空间了，要是一人再背一个 Chrome。。。</p><p>画面太美了，我不敢想！</p><p>另外，作为网络世界的窗口，浏览器漏洞本身也是很多黑客行为的突破口。</p><p>系统本身提供一个全局自动更新的浏览器框架，也可以避免一些 App 不更新内置的浏览器内核，导致黑客趁虚而入。</p><p><strong>这次的问题，恰恰就出在这个 “为了不出问题” 而设计的系统级浏览器框架上。</strong></p><p>不知道大家有没有体验过系统浏览器的 “<strong>便捷单点登录</strong>” 功能。</p><p>就比方说，假如你在 Windows 电脑上使用自带的 Edge 浏览器打开微软账户官网，Edge 浏览器不会让你输入微软账户的账号密码。</p><p>而是会自动读取当前电脑里登录的微软账户，然后帮你在浏览器网站里完成登录。</p><img src="https://img.darklorder.com/img/202307311253625.png"/><p>假如你在登录了谷歌账号的安卓手机上使用谷歌 Chrome 浏览器，它也会自动帮你完成登录操作。</p><img src="https://img.darklorder.com/img/202307311254951.png"/><p>苹果也是如此，假如你在 Safari 浏览器里打开 Apple ID 官网，并点击登录。</p><p>浏览器也不会让你输入密码，而是直接弹出来一个登陆操作的确认框。</p><img src="https://img.darklorder.com/img/202307311254573.gif"/><p>假如你点了 “ 继续 ”，得益于高性能的苹果 A16 处理器，系统会光速弹出 Face ID 验证。</p><p>一个眨眼的功夫，就登录成功了。</p><img src="https://img.darklorder.com/img/202307311255122.png"/><p>诶，等会儿。。。</p><p><strong>这个登陆框，怎么有点儿眼熟啊？？？</strong></p><p><strong>为什么 “ 菜谱大全 ” 会请求登录 Apple ID 官网啊？？？</strong></p><img src="https://img.darklorder.com/img/202307311255195.png"/><p>说真的，假如没有对比的话，菜谱大全的操作很容易会被大家当成是普通的 “ 一键注册账号 ” ——</p><p>包括发帖的 airycanon 也没反应过来，以为是丈母娘没有选苹果的隐私邮箱登录选项才暴露了 Apple ID，让黑客掌握了信息。</p><p>真正的一键注册环节会要求选择是否隐藏邮件地址</p><img src="https://img.darklorder.com/img/202307311256034.png"/><p>实际上，当这个确认窗验证完毕之后，骗子都已经准备好往账号里加料了。。。</p><img src="https://img.darklorder.com/img/202307311256164.png"/><p>“ 菜谱大全 ” 之所以能够一键登录，恰恰就是利用了 WebView 这个系统级浏览器框架的 “ 便捷登录 ” 特性。</p><p>表面上，是一个菜谱 App，<strong>而在它的内部，隐藏了一个正在访问 Apple ID 官网、并准备篡改用户接收验证短信手机号的浏览器界面。</strong></p><p>我后来看 BugOS 技术组又发了一个微博，他们已经用自己写的代码还原完整个攻击过程了。</p><img src="https://img.darklorder.com/img/202307311256161.png"/><p>按照苹果 Apple ID 官网目前的安全逻辑，<strong>只有一开始的账号登录环节需要下发验证码做双重验证。</strong></p><p>而这最开始的一步，骗子已经通过 WebKit 的便捷登录绕过去了。</p><p><strong>已经处于登录状态的情况下，只要输固定的账号密码，就可以直接添加新的验证手机了。</strong></p><img src="https://img.darklorder.com/img/202307311257506.gif"/><p>现在相信大家已经彻底搞明白背后是怎么一回事儿了，这时候我们再重新回看故事的全貌：</p><p>“ 菜谱大全 ” 先是在表层界面的下面，隐藏了一个 WebView 浏览器组件，然后利用它系统级的 “便捷登录” 能力，进入了 Apple ID 官网。</p><p>接着，它给用户弹出了一个密码输入框，用来搞定添加验证手机的最后一步障碍。</p><img src="https://img.darklorder.com/img/202307311258021.png"/><p>拿到密码之后，App 就会偷偷跑起添加新验证手机的自动脚本，这时候受害者的苹果账号就已经不属于自己了。</p><p>什么时候发起攻击，全看黑客心情了。</p><p>OK，复盘完毕，这么一看好像还是受害者太傻，平白无故把密码交出来了对不对 —— 假如受害者打死不填密码，黑客也没招。</p><p>我们不应该骂苹果对不对？</p><p>emmmm，在下这个结论之前，我想先带大家看一看苹果的老对手 —— 谷歌是怎么做的。</p><img src="https://img.darklorder.com/img/202307311258470.png"/><p>和苹果 Apple ID 一样，只要已经处于登录状态了，谷歌这边的账号系统要想添加新的验证手机，也只是输一下固定密码的事。</p><p><strong>但是和苹果不同，谷歌根本不允许系统的 WebView 组件使用 “便捷登录” 技术。</strong></p><p>我在自己的安卓手机上做了个小测试，分别使用谷歌 Chrome 浏览器和 Via 浏览器（ 一款直接调用系统 WebView 框架的极简浏览器 App ）访问谷歌账号官网。</p><p>Chrome 浏览器因为已经获取了系统里的账号登录状态，因此直接就登录了。</p><p>Via 浏览器则没有这个能力，需要一步步重新输入账号、密码、验证码。</p><img src="https://img.darklorder.com/img/202307311259604.png"/><p>换句话说，假如有骗子想在安卓手机上做一个同样套路的事，第一步就卡住了。。。</p><p>但是在苹果系统里，不管是调用 WebView 的 Via，还是真正的自带浏览器 Safari，<strong>都能调用便捷登录。</strong></p><p>再搭配上 App Store 的审核漏洞，一锅好菜就出炉了。。。</p><img src="https://img.darklorder.com/img/202307311259869.png"/><p>严格来说，这对于 iOS 系统来说也算是一个漏洞 —— 它不是代码漏洞，而是一个逻辑漏洞。</p><p>骗子利用苹果开放的便捷登录能力，伪装了自己一波，再利用一点点社工技巧，就把钱骗到手了。</p><p>由于系统逻辑漏洞造成的问题，正确的解决方式应该是着手准备 OTA 补丁，同时帮着受骗的用户追回损失。</p><p>不过苹果给这个受害者带来的感知，并不是很好。。。</p><img src="https://img.darklorder.com/img/202307311259025.png"/><p>可能现在时间还比较短，希望苹果后续可以帮这个受害者妥善解决。</p><p><strong>不瞒大家说，本来我今天是没打算写这篇文章的。</strong></p><p>因为真要细究的话，安卓这边虽然把 WebView 的洞补上了，但是其他的漏洞更多、骗人的方式根本数不过来。</p><p>苹果生态总体来说都还是更安全的、让人用着更放心的，但是大家不要因为它 “安全” 的标签就变得麻木、不重视安全了。</p><p>就像大家都说沃尔沃安全，但你不能因为这点就不握着方向盘了。。。</p><p>相信很多给家长买 iPhone 的小伙伴，都是希望家长尽可能不被骗。</p><p>但我觉得，我们还是要告诉他们即便是 iPhone，即便是 App Store，也不能保证绝对安全。</p><p>不随便输密码、不给所有 App 用一模一样的密码是最后的底线。</p><p><strong>千万记得叮嘱他们，免密支付能不开就不开。</strong> <strong>如果开了的话，免密支付的卡里面也不要放太多的钱。</strong></p><p><strong>参考资料</strong><br><a href="https://mp.weixin.qq.com/s/G55w5UakMUcuhWyUPaHFYQ">iPhone今天这个大漏洞，让人打开App就被盗刷一万五。。。</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作为了生活，生活不是为了工作</title>
    <link href="/2023/01/04/Life-and-work/"/>
    <url>/2023/01/04/Life-and-work/</url>
    
    <content type="html"><![CDATA[<p><strong>乐视认为,生活绝不是为了更好地工作,但工作一定是为了更好地生活。</strong></p><span id="more"></span><p>这几天有几个朋友向我诉苦，</p><p>想换份工作。</p><p>而我只做过一份工作，</p><p>感觉没资格提意见。</p><p>如果真的要我说，</p><p>我希望你可以做自己擅长做的事，</p><p>其次也要做一份自己喜欢做的事，</p><p>碰巧你擅长做的也是你喜欢做的事，</p><p>那我为你感到庆幸。</p><p>工作为了生活，生活不是为了工作。</p><p>Recently some closed friends complained to me about changing their jobs.</p><p>But I am not qualified to comment due to I never change jobs before.</p><p>It is my little tips below:</p><p>First I hope you could do the jobs you are good at,</p><p>Secondly I hope you could do the jobs you like.</p><p>You will be lucky if the jobs you good at is same jobs you like.</p><p>Enjoy your work, enjoy you life.</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>走在自己的时区里</title>
    <link href="/2023/01/01/walk-in-your-own-time-zone/"/>
    <url>/2023/01/01/walk-in-your-own-time-zone/</url>
    
    <content type="html"><![CDATA[<p><strong>美国的一首小诗</strong></p><span id="more"></span><p>在时间上，纽约走在加州前面三个小时，</p><p>New York is 3 hours ahead of California,</p><p>但加州并没有变慢。</p><p>but it does not make California slow.</p><p>有人22岁就毕业了，</p><p>Someone graduated at the age of 22,</p><p>但等了五年才找到好工作！</p><p>but waited 5 years before securing a good job!</p><p>有人25岁就当上了CEO，</p><p>Someone became a CEO at 25,</p><p>却在50岁去世了。</p><p>and died at 50.</p><p>也有人直到50岁才当上CEO，</p><p>While another became a CEO at 50,</p><p>最后活到90岁。</p><p>and lived to 90 years.</p><p>有人依然单身，</p><p>Someone is still single,</p><p>而别人却早已结婚。</p><p>while someone else got married.</p><p>奥巴马55岁退任总统，</p><p>Obama retires at 55,</p><p>而川普却是70岁才开始当。</p><p>but Trump starts at 70.</p><p>世上每个人都有自己的发展时区。</p><p>Absolutely everyone in this world works based on their Time Zone.</p><p>身边有些人看似走在你前面，</p><p>People around you might seem to go ahead of you,</p><p>也有人看似走在你后面。</p><p>some might seem to be behind you.</p><p>但其实每个人在自己的时区有自己的步程。</p><p>But everyone is running their own RACE, in their own TIME.</p><p>不用嫉妒或嘲笑他们。</p><p>Don’t envy them or mock them.</p><p>他们都在自己的时区，你在你的！</p><p>They are in their TIME ZONE, and you are in yours!</p><p>生命就是等待正确的时机行动。</p><p>Life is about waiting for the right moment to act.</p><p>所以，放轻松。</p><p>So, RELAX.</p><p>你没有落后，</p><p>You’re not LATE.</p><p>你没有领先。</p><p>You’re not EARLY.</p><p>在命运为你安排的属于你自己的时区里，一切都非常准时。</p><p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 上 API 网关的未来</title>
    <link href="/2022/11/16/the-future-of-api-gateways-on-kubernetes/"/>
    <url>/2022/11/16/the-future-of-api-gateways-on-kubernetes/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><img src="https://img.darklorder.com/img/202308161506230.png" style="zoom:80%;" /><h2 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h2><ul><li><p>API 网关已从基本的转换器发展为适应市场需求的高级云网关，在管理和保护客户端与后端服务之间的 API 通信中发挥着关键作用。</p></li><li><p>尽管开源的 Kubernetes Gateway API 项目将 API 网关定位为基础设施中必不可少但可商业化的一部分，但全周期的 API 管理在推动云原生应用和服务方面仍然至关重要。</p></li><li><p>为了充分发挥云原生计算的潜力，传统的 API 管理架构必须重新设计，以不仅满足 Kubernetes 和云原生环境的要求，而且还要充分利用它们提供的功能。</p></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>随着互联网和云计算的指数级增长，催生了更小、更分布式的应用程序，这些应用为高度动态的环境而设计，能够根据需要快速扩展或缩减。这些应用程序推动了对现代 API 管理产品架构的需求，这些架构可以利用云原生能力实现可伸缩性、弹性、敏捷性和成本效益。与此同时，云原生应用帮助推动 API 网关从简单转换器发展为推动数字化计划中不可或缺的高级中间件。</p><p>与此同时，<strong>Kubernetes</strong> 已经成为现代分布式应用程序首选的开源容器编排系统，无论是部署在一个还是多个公共或私有云上。根据 2022 年全球 CNCF 调查<sup>[1]</sup>显示，89% 的 CNCF 最终用户正在使用或试验 Kubernetes。<strong>Kubernetes Gateway API</strong> 项目旨在通过定义声明性 API 来配置 Kubernetes 集群中的网关和入口点，以促进组织实施该技术。预计这一发展将使得 API 网关变得更加易于访问和产品化，尽管完整生命周期的 API 管理仍然对于推动云原生应用程序和服务至关重要。</p><p>本文将探讨 API 网关如何演变、传统 API 网关在支持 Kubernetes 云原生环境方面的不足之处、当今的 API 网关需求、为什么 Envoy 是构建下一代 API 网关的最佳标准，以及基于 Kubernetes 的 API 管理的未来。</p><h2 id="网关的演变"><a href="#网关的演变" class="headerlink" title="网关的演变"></a>网关的演变</h2><img src="https://img.darklorder.com/img/202308161507504.png" style="zoom:80%;" /><p>图1：网关的演变</p><p>在探讨 API 网关是如何演变之前，让我们快速定义我们所说的 API 管理与 API 网关的含义。API 管理包括策略规划、设计、实施到监控 API 在其生命周期的每个阶段的端到端过程。API 网关是 API 管理基础设施中的一个专用组件，作为 API 请求的主要入口点，促进客户端和后端服务之间的通信。</p><p>API 网关的演变可以分为九个不同的阶段，每个阶段都代表了它们能力的进步和变化。这些阶段反映了 API 网关为满足现代应用架构和 API 管理的不断发展的需求而进行的持续开发和适应。</p><ul><li><p><strong>早期的网关</strong>：作为转换器，使不同的网络架构之间的通信成为可能，并促进了不同系统之间的连接。</p></li><li><p><strong>代理服务器</strong>：包括 Apache HTTP Server 和 Squid 在内的代理服务器作为网关越来越受欢迎，可以跨多个端点管理流量，并提供缓存、安全和访问控制等功能。</p></li><li><p><strong>硬件负载均衡器</strong>：如 F5 Networks Big-IP，出现是为了优化性能并处理随着应用程序变得更加复杂而增加的用户需求。</p></li><li><p><strong>软件负载均衡器</strong>：包括 HAProxy，由于其强大的功能、性能和可靠性而成为了流行的选择。它提供了高级的负载均衡算法、会话持久性、健康检查和可伸缩性选项，使其非常适合处理大量的 API 流量。</p></li><li><p><strong>应用交付控制器（ADCs）</strong>：如 NGINX 和 Citrix ADC 作为优化应用性能和确保客户端和服务器之间的安全通信的高级网关出现。它们提供负载均衡、安全套接字层(SSL)和传输层安全性(TLS)终止、安全性、缓存和流量管理功能。</p></li><li><p><strong>SOAP 网关</strong>：随着 SOAP 和 web 服务 API 的并行发展，支持集成、协议转换和 SOAP 基础服务的安全性实施。</p></li><li><p><strong>API 网关</strong>：随着 web API 和面向服务的架构的崛起，作为访问 API 的中介并处理如路由、身份验证、速率限制和转换等任务而演变。它们在保护、监控和管理 API 流量中发挥着至关重要的作用，其中一些利用了 Netty 网络框架。API 网关进一步演变，以处理微服务架构中通信和路由的复杂性，与服务发现机制集成，实现动态路由、负载均衡和协议转换。</p></li><li><p><strong>微网关</strong>：随着微服务、边缘计算和物联网的崛起，越来越多地在网络边缘使用。它们将处理能力和连接性带到数据源附近，减少延迟和拥塞，同时实现数据聚合、本地处理和安全性实施。它们还促进了 IoT 设备与后端系统之间的通信。</p></li><li><p><strong>云原生 API 网关</strong>：云原生 API 网关的出现是为了管理云原生环境中的流量，利用 Kubernetes 等容器编排平台并采用云原生原则来实现可扩展性和弹性在云原生环境中，网关越来越多地结合人工智能和机器学习技术。</p></li></ul><h2 id="API-网关的角色"><a href="#API-网关的角色" class="headerlink" title="API 网关的角色"></a>API 网关的角色</h2><img src="https://img.darklorder.com/img/202308161507298.png" style="zoom:80%;" /><p>图 2：API 网关概述</p><p>在当今的技术环境中，API 网关的角色已经受到了其演变的显著影响。目前，API 网关作为 API 管理的核心，充当 API 请求的入口点，抽象出各种服务的服务质量(QoS)问题。它集成了各种 QoS 功能，包括安全性、速率限制、消息转换、请求路由、缓存和 API 洞察，以确保 API 请求的全面管理。</p><p><strong>API 安全性</strong>至关重要，身份验证和授权起着关键作用。身份验证方法，如双向 TLS (mTLS)、Open Authorization (OAuth) 2.0 Tokens 和 API 密钥，以及通过授权范围进行的细粒度访问控制，增强了安全性。</p><p><strong>API 速率限制</strong>确保用户遵循定义的策略公平使用。它防止滥用，保持一致的服务质量，并在 API 管理中促进透明度和责任。</p><p><strong>缓存</strong>为 API 驱动的应用程序提供了显著的好处。通过减少后端负载、最小化延迟、优化带宽使用和提供对后端故障的弹性，它增强了性能、可伸缩性和弹性。</p><p><strong>消息转换功能</strong>允许用户修改 API 请求，但在 API 网关上直接实施大量转换可能会影响性能。最佳实践是使用专为复杂消息转换设计的集成层。</p><p><strong>请求路由</strong>涉及根据定义的规则和配置将传入的 API 请求引导到适当的后端服务，同时还结合了服务负载均衡、故障转移机制和 A&#x2F;B 测试。</p><p><strong>API 洞察</strong>通过收集和发布数据进行分析和可视化，提供业务智能。</p><p><strong>监控和可观察性</strong>涉及数据收集和分析，以获得 API 性能、可用性和使用情况的洞察。这些功能允许组织跟踪指标、检测异常并解决问题，确保 API 网关和底层 API 基础设施的高效运行和持续改进。</p><p>现代 API 网关不仅支持 REST 服务，还包括对 GraphQL 服务、gRPC 服务和各种流服务的支持。每种类型的 API 从 API 网关获得不同的 QoS 处理。部署模式包括集中式模式，其中所有 API 一起进行缩放，以及分布式模式。API 管理器控制平面管理部署在不同环境中的网关，提供集中化的控制和配置。</p><h2 id="云原生环境中的-API-管理"><a href="#云原生环境中的-API-管理" class="headerlink" title="云原生环境中的 API 管理"></a>云原生环境中的 API 管理</h2><p>Kubernetes 的采用推动了 API 网关的广泛使用，因为组织利用了容器化和微服务架构的好处。API 网关在基于 Kubernetes 的环境中实现了高效的 API 管理、可伸缩性和安全性，使其成为现代应用开发和部署中的关键组件。</p><h3 id="在使用传统的-API-管理-Kubernetes-时存在的缺陷"><a href="#在使用传统的-API-管理-Kubernetes-时存在的缺陷" class="headerlink" title="在使用传统的 API 管理 Kubernetes 时存在的缺陷"></a>在使用传统的 API 管理 Kubernetes 时存在的缺陷</h3><p>尽管它们被广泛使用，但传统的 API 管理架构并不适合 Kubernetes 和其他云原生环境。它们具有将多个功能捆绑在一个应用程序中的单一设计。这使得难以独立缩放各个组件，相反，必须将整个应用程序一起缩放，这会浪费资源，并在处理高流量或增加的工作负载时导致性能问题。</p><p>传统的 API 管理架构还依赖于与云原生环境不兼容的特定基础设施组件和技术。它们不仅具有更大的内存占用和更长的服务器启动时间；它们可能还需要专用硬件、特定软件配置或专有解决方案。这限制了它们利用云平台的优势，包括自动扩展、基础设施即代码实践和多云部署。由于 API 管理架构中存在一些外部依赖关系，API 网关在支持云原生应用程序方面也面临类似挑战。为了克服这些挑战并满足当前和未来云原生环境的需求，需要重新设计 API 网关。</p><h3 id="Envoy-代理：重构-API-网关的关键"><a href="#Envoy-代理：重构-API-网关的关键" class="headerlink" title="Envoy 代理：重构 API 网关的关键"></a>Envoy 代理：重构 API 网关的关键</h3><p>Envoy<sup>[2]</sup> 已经成为重构 API 网关的首选解决方案，因为这个开源的边缘和服务代理专为云原生应用设计。此外，其适应性、可扩展性和强大的安全功能使其成为在各种云环境中管理 API 流量的绝佳选择。作为一个开源解决方案，Envoy 从全球的开发者那里获得了持续的改进，他们为代理提供了新功能、增强功能和错误修复，进一步增强了代理的健壮性和可靠性。</p><p><strong>从 API 管理的角度看</strong>，Envoy 提供了如限速、响应缓存、CORS 处理、请求认证和授权等关键功能。它支持同时暴露 REST 和 gRPC 服务，并与 AWS 进行直接集成，以暴露 AWS Lambda 函数。该代理还提供了内置的可观察性功能，与开放遥测无缝集成，为监控和调试提供了全面的指标和跟踪数据。Envoy 代理使用 xDS API 进行配置，这些 API 允许动态配置、服务发现、流量路由和代理的运行时控制。通过利用 xDS API，Envoy 可以轻松地进行设置和修改，以满足不断变化的需求。</p><p><strong>Envoy 代理主要采用两种部署模式</strong>：边车代理模式和前端代理模式。在边车代理模式中，Envoy 作为 SOA 架构中内部流量的通信总线。它通常用作服务网格中的边车，管理网络流量并与其代理的服务并行。Envoy 的轻量级核心和强大的功能，如负载均衡和服务发现，使其成为 Istio 等服务网格实现的热门选择。</p><p>在前端代理模式中，Envoy 在 Kubernetes Ingress 控制器中使用，将服务暴露给外部消费者。一些 Ingress 控制器是基于 Envoy 构建的，利用其核心功能。Envoy 的灵活配置模型和功能集也使其成为 API 网关的理想选择。大多数现代 API 网关都是基于 Envoy 代理构建的，该代理作为基本框架。</p><h3 id="云原生-API-管理架构"><a href="#云原生-API-管理架构" class="headerlink" title="云原生 API 管理架构"></a>云原生 API 管理架构</h3><p>基于 Envoy 代理的 API 网关在增强整体 API 管理架构中起到了关键作用，因为它们利用了云原生技术来有效地管理 API，同时确保了可扩展性和弹性。在这里，API 管理架构基于微服务原则、容器化和使用 Kubernetes 的容器编排，为云原生环境中的高效 API 管理提供了基础设施。</p><p>云原生 API 管理架构包括两个独特的平面：<strong>控制平面</strong>和<strong>数据平面</strong>。控制平面是命令中心，执行 API 管理任务和 API 密钥生成。数据平面作为 API 调用的网关，将创建的 API 暴露给公共或私有消费者。该架构设计为高度可扩展，允许单个控制平面管理多个数据平面。这使得无缝的 API 网关联邦成为可能，并促进了跨多个云提供商或本地数据中心的 API 管理。为了增强可扩展性和弹性，该架构利用了 Kubernetes 的基本功能，如自动缩放和自我修复，以确保最佳性能和可靠性。</p><img src="https://img.darklorder.com/img/202308161507971.png" style="zoom:80%;" /><p>图 3：API 管理的控制平面和数据平面</p><h2 id="Envoy-网关项目与-API-标准化"><a href="#Envoy-网关项目与-API-标准化" class="headerlink" title="Envoy 网关项目与 API 标准化"></a>Envoy 网关项目与 API 标准化</h2><p>在 2022 年，Envoy 的创建者 Matt Klein 推出了一个名为 Envoy Gateway<sup>[3]</sup> 的新项目，专门针对 API 网关。Envoy 已经具备了构建 API 网关所需的组件，包括代理层；用于网络流量过滤、路由和处理的可配置过滤器架构；以及用于向 Envoy 代理传输数据的 xDS API。开源的 Envoy 网关项目增加了一个管理层，用于处理 Envoy 代理作为独立网关或作为 Kubernetes 管理的 API 网关。</p><p>该项目的目标是提供一个简化的 API 层和部署模型，专注于更简单的用例。它还旨在将各种 CNCF API 网关项目整合到一个公共核心中，使供应商能够在 Envoy 和 Envoy Gateway 之上构建增值解决方案。通过促进社区合作，该项目还旨在消除在开发基本 API 网关功能方面的重复努力，使供应商能够更加专注于 API 管理功能。这种统一努力有可能提高效率并鼓励 API 网关领域的创新。</p><p>Envoy 网关项目主要基于 Kubernetes Gateway API<sup>[4]</sup>，该 API 定义了如何将 Kubernetes 服务暴露给外部世界。它利用 Kubernetes CRD 定义，如 <code>GatewayClass</code>、<code>Gateway</code>、<code>HTTPRoute</code>、<code>TCPRoute</code> 等来配置 API 网关。CRD 描述了诸如流量分割、请求路由、重定向、重写和 TLS 处理等重要功能。此外，还可以将各种策略与 API 网关或特定 API 路径关联。</p><p>通过采用 Kubernetes Gateway API 作为基础，供应商可以灵活地在其首选的技术栈上开发自己的实现，并且可以利用 API 规范提供的扩展点来包含供应商特定的功能。这种方法促进了共享、标准化的 API 规范的采用，从而促进了 API 网关之间的互操作性，提高了 API 网关的一致性，并为未来的创新打开了新的可能性。</p><h2 id="Kubernetes-上的-API-管理的未来"><a href="#Kubernetes-上的-API-管理的未来" class="headerlink" title="Kubernetes 上的 API 管理的未来"></a>Kubernetes 上的 API 管理的未来</h2><p>API 管理在动态的 API 环境中起着至关重要的作用，随着 API 标准化的推进，API 网关将成为基础设施的基本元素。这一变化将使开发人员免于直接管理网关及其相关的复杂性，使他们可以将注意力集中在构建和维护 API 以及其他核心开发任务上。因此，重点转向 API 管理，该管理涵盖了一系列基本功能。</p><ul><li><p><strong>API 生命周期管理</strong>使 API 的生命周期得以规划，允许自定义事件和生命周期变更的利益相关者授权。</p></li><li><p><strong>API 治理</strong>建立了流程和政策，以确保有效的 API 开发、管理，并符合组织目标和标准。</p></li><li><p><strong>API 市场</strong>作为一个在线平台，供开发人员发现、访问和管理 API。它提供文档、目录、SDK、测试工具、社区支持和货币化选项。</p></li><li><p><strong>API 版本管理</strong>涉及管理不同的 API 版本，以适应变化，同时保持向后兼容性。</p></li><li><p><strong>API 产品化</strong>将 API 视为可销售的产品，应用产品管理原则以满足开发者和业务需求。这包括创建用户友好的体验和实施货币化策略。</p></li><li><p><strong>API 洞察</strong>提供有价值的信息，通过分析使用情况、性能和行为，使得可以进行数据驱动的决策，以增强 API 体验。</p></li></ul><p>为了充分利用云原生生态系统的优势，许多这些功能都需要重新设计。这将涉及与 Kubernetes 上可用的各种第三方服务的无缝集成，以实现更全面和强大的 API 管理解决方案。</p><p>此外，采用开源分发模式对企业来说将是一个关键因素。开源产品鼓励社区参与和适应，促进生态系统内的合作与创新。拥抱开源还确保了 API 管理解决方案能够从多元化社区的集体知识和贡献中受益，从而实现持续改进和演进。</p><h2 id="单一控制平面的-API-网关"><a href="#单一控制平面的-API-网关" class="headerlink" title="单一控制平面的 API 网关"></a>单一控制平面的 API 网关</h2><img src="https://img.darklorder.com/img/202308161508844.png" style="zoom:80%;" /><p>图 4：用于不同 API 网关实现的单一控制平面</p><p>API 标准化将 API 网关转化为一种商品，为包含 API 管理和发现的统一控制平面铺平了道路。与此同时，数据平面可以由来自不同供应商的一个或多个 API 网关实现组成。这种范式转变带来了许多含义和机会。</p><ul><li><p><strong>供应商中立性和灵活性</strong>：通过使用能够管理来自不同供应商的多个网关的单一控制平面，组织实现了供应商中立性和增强的灵活性。这使他们能够为每个独特的用例或环境选择最合适的网关解决方案。通过接受多个供应商，组织可以利用不同供应商提供的特定优势和优点，避免供应商锁定，并培育一个更加适应的生态系统。</p></li><li><p><strong>互操作性和标准化</strong>：采用单一控制平面促进了不同网关之间的互操作性和标准化。通过遵循共享的 API、协议和数据格式，控制平面使来自不同供应商的网关能够进行无缝通信和管理。这促进了配置、策略和安全措施的一致性，从而提高了 API 基础设施的稳定性和可靠性。</p></li><li><p><strong>生态系统扩展和创新</strong>：单一控制平面管理来自多个供应商的网关，促进了多样化的生态系统并刺激了创新。它使组织能够接受和整合来自新兴供应商的新网关解决方案，而不会对现有基础设施造成中断。这种健康的供应商之间的竞争驱动了创新，扩展了可用选项的范围，并使组织能够使用更广泛的尖端解决方案来满足其 API 管理需求。</p></li><li><p><strong>成本优化</strong>：单一控制平面管理来自不同供应商的网关，使组织有灵活性选择与其特定要求和预算考虑相一致的经济有效的网关解决方案。这种自由使企业能够优化其支出，从其 API 管理基础设施中提取最大价值，并做出与其特定需求相一致的明智决策。</p></li><li><p><strong>简化的管理和操作</strong>：组织可以集中配置、监控和控制其 API 网关，消除了单独管理不同网关的复杂性。这种集中化方法提高了管理效率，简化了操作，并最大限度地减少了潜在的不一致性。由于网关遵循相同的 API 标准化，因此在 API 网关解决方案之间进行迁移变得更加容易。这简化了从一个网关解决方案过渡到另一个网关解决方案的过程，确保了对现有基础设施的平滑整合和减少了潜在的中断。</p></li></ul><p>总之，当 API 网关成为一种商品，并且单一控制平面管理来自不同供应商的多个网关时，团队将获得供应商中立性、简化的管理、更大的互操作性、成本优化、增强的安全性和更容易的生态系统扩展的好处。这种汇聚还将使企业能够利用不同网关解决方案的优势，简化操作，推动创新，并优化其 API 管理的实践。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]2022 年全球 CNCF 调查: <a href="https://www.cncf.io/reports/cncf-annual-survey-2022/#findings">https://www.cncf.io/reports/cncf-annual-survey-2022/#findings</a></p><p>[2]Envoy: <a href="https://www.envoyproxy.io/">https://www.envoyproxy.io/</a></p><p>[3]Envoy Gateway: <a href="https://gateway.envoyproxy.io/">https://gateway.envoyproxy.io/</a></p><p>[4]Kubernetes Gateway API: <a href="https://gateway-api.sigs.k8s.io/">https://gateway-api.sigs.k8s.io/</a></p><p><strong>参考资料</strong><br><a href="https://wso2.com/library/blogs/the-future-of-api-gateways-on-kubernetes/">The Future of API Gateways on Kubernetes</a></p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gateway API：Kubernetes 和服务网格入口中网关的未来</title>
    <link href="/2022/11/15/why-gateway-api-is-the-future-of-ingress-and-mesh/"/>
    <url>/2022/11/15/why-gateway-api-is-the-future-of-ingress-and-mesh/</url>
    
    <content type="html"><![CDATA[<p>本文介绍 Kubernetes 中的入口网关及 Gateway API，入口网关与服务网格融合的新趋势。</p><span id="more"></span><p>本文将以 Kubernetes Ingress、Istio 和 Envoy Gateway 为例，向你介绍 Kubernetes 中的入口网关和 Gateway API，同时介绍 Gateway API 使得 Kubernetes 和服务网格入口网关融合的新趋势。</p><h2 id="本文观点"><a href="#本文观点" class="headerlink" title="本文观点"></a>本文观点</h2><ul><li>Ingress 作为 Kubernetes 的初代入口网关，它的资源模型过于简单以致于无法适应当今的可编程网络；</li><li>Gateway API 作为 Kubernetes 入口网关的最新成果，它通过角色划分将关注点分离，并提供跨 namespace 支持使其更适应多云环境，已获得大多数 API 网关的支持；</li><li>入口网关（南北向）与服务网格（东西向，集群内路由）存在部分功能重叠，Gateway API 为两者的融合提供了新的参考模型；</li></ul><h2 id="Kubernetes-入口网关的历史"><a href="#Kubernetes-入口网关的历史" class="headerlink" title="Kubernetes 入口网关的历史"></a>Kubernetes 入口网关的历史</h2><p>2014 年 6 月 Kubernetes 开源，起初只能使用 NodePort 和 LoadBalancer 类型的 Service 对象来暴露集群内服务，后来才诞生了 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress</a>，两年后（Kubernetes 1.2）Ingress API 进入 Beta 版本，随后为了保持其轻量和可移植的特性，Ingress API 相较于 Kubernetes 其他 API 发展得比较缓慢，直到 Kubernetes 1.19 它才升级到 GA。</p><p>Ingress 的主要目标是用简单的、声明性的语法来暴露 HTTP 应用。你可以在 Kubernetes 中部署多种 Ingress Controller，并在创建 Ingress 的时候通过 IngressClass 指定该网关使用的控制器，或者在 Kubernetes 中设置默认的默认的 IngressClass。Kubernetes 默认只支持 AWS、GCE 和 Nginx Ingress Controller，同时还支持大量的<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers">第三方 Ingress Controller</a>。</p><p>下图展示了 Kubernetes Ingress 的工作流程。</p><p><img src="https://img.darklorder.com/img/202308161518566.svg" alt="Kubernetes Ingress 工作流程"></p><p>详细流程如下：</p><ol><li>Kubernetes 集群管理员在 Kubernetes 中部署 Ingress Controller；</li><li>Ingress Controller 会持续监视 Kubernetes  API Server 中的 IngressClass 和 Ingress 对象的变动；</li><li>管理员应用 IngressClass 和 Ingress 来部署网关；</li><li>Ingress Controller 会根据管理员的配置来创建对应的入口网关并配置路由规则；</li><li>如果在云中，客户端会访问该入口网关的负载均衡器；</li><li>网关将根据 HTTP 请求中的 host 和 path 将流量路由到对应的后端服务；</li></ol><p>Istio 同时支持 Ingress 和 Gateway API，下面是一个使用 Istio 入口网关的配置示例，在后文中会使用 Gateway API 创建该配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">IngressClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">istio</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">controller:</span> <span class="hljs-string">istio.io/ingress-controller</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ingressClassName:</span> <span class="hljs-string">istio</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">httpbin.example.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">httpbin</span><br>            <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>注意：Ingress 的 spec 中必须在 <code>ingressClassName</code> 字段中指定使用的 <code>IngressClass</code>，否则将无法创建对应的入口网关。</p><h2 id="Kubernetes-Ingress-的局限性"><a href="#Kubernetes-Ingress-的局限性" class="headerlink" title="Kubernetes Ingress 的局限性"></a>Kubernetes Ingress 的局限性</h2><p>虽然 <code>IngressClass</code> 实现了入口网关与后台实现的解耦，但是它仍然有着巨大的局限性：</p><ul><li>Ingress 的配置过于简单，仅支持 HTTP 协议路由；</li><li>HTTP 路由仅支持 host 和 path 匹配，对于高级路由功能没有通用配置，只能通过 annotation 来实现，比如<a href="https://help.aliyun.com/document_detail/86533.html#section-xsg-g5g-1uy">使用 Nginx Ingress Controller 实现 URL 重定向</a>，需要配置 <code>nginx.ingress.kubernetes.io/rewrite-target</code> annotation，已经无法适应可编程路由的需求；</li><li>不同命名空间中的服务要绑定到同一个网关中的情况在实际情况下经常出现，而入口网关无法在多个命名空间中共享；</li><li>入口网关的创建和管理的职责没有划分界限，导致开发者不仅要配置网关路由，还需要自己创建和管理网关；</li></ul><h2 id="Kubernetes-Gateway-API"><a href="#Kubernetes-Gateway-API" class="headerlink" title="Kubernetes Gateway API"></a>Kubernetes Gateway API</h2><p>Gateway API 是一个 API 资源的集合 —— <code>GatewayClass</code>、<code>Gateway</code>、<code>HTTPRoute</code>、<code>TCPRoute</code>、<code>ReferenceGrant</code> 等。Gateway API 暴露了一个更通用的代理 API，可以用于更多的协议，而不仅仅是 HTTP，并为更多的基础设施组件建模，为集群运营提供更好的部署和管理选项。</p><p>另外 Gateway API 通过将资源对象分离，实现配置上的解耦，可以由不同的角色的人员来管理，其中的 API 对象如下图所示。</p><p><img src="https://img.darklorder.com/img/202308161519650.svg" alt="Gateway API 及角色"></p><p>下面是在 Istio 中使用 Gateway API 的示例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">gateway.networking.k8s.io/v1alpha2</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">gatewayClassName:</span> <span class="hljs-string">istio</span><br>  <span class="hljs-attr">listeners:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">default</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">&quot;*.example.com&quot;</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br>    <span class="hljs-attr">allowedRoutes:</span><br>      <span class="hljs-attr">namespaces:</span><br>        <span class="hljs-attr">from:</span> <span class="hljs-string">All</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">gateway.networking.k8s.io/v1alpha2</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">HTTPRoute</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">parentRefs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-ingress</span><br>  <span class="hljs-attr">hostnames:</span> [<span class="hljs-string">&quot;httpbin.example.com&quot;</span>]<br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">matches:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">PathPrefix</span><br>        <span class="hljs-attr">value:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">backendRefs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">httpbin</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>与 Ingress 类似，Gateway 使用 <code>gatewayClassName</code> 声明其使用的控制器，该控制器需要平台管理员创建，并允许客户端对 <code>*.example.com</code> 域名的请求。应用开发者可以在其服务所在的命名空间中，在此示例中是 <code>default</code> 创建路由规则，并通过 <code>parentRefs</code> 绑定到 Gateway 上，当然这必须是在 Gateway 明确允许其绑定的情况下（通过 <code>allowRoutes</code> 字段中的规则设置）。</p><p>当你应用上面的配置后，Istio 会自动为你创建一个负载均衡网关，下图展示了 Gateway API 的工作流程。</p><p><img src="https://img.darklorder.com/img/202308161520321.svg" alt="Gateway API 工作流程"></p><p>详细流程如下：</p><ol><li>基础设施供应商提供了 <code>GatewayClass</code> 和 Gateway 控制器；</li><li>平台运维部署 Gateway（可以部署多个，或使用不同的 <code>GatewayClass</code>）；</li><li>Gateway Controller 会持续监视 Kubernetes  API Server 中的 <code>GatewayClass</code> 和 <code>Gateway</code> 对象的变动；</li><li>Gateway Controller 会根据集群运维的配置来创建对应的网关；</li><li>应用开发者应用 xRoute 并绑定服务上；</li><li>如果在云中，客户端会访问该入口网关的负载均衡器；</li><li>网关将根据流量请求中的匹配条件将路由到对应的后端服务；</li></ol><p>从以上步骤中我们可以看出 Gateway API 相比 Ingress 有了明确的角色划分，而且路由规则可以与网关配置解耦，这大大增加了管理的灵活性。</p><p>下图展示了流量接入网关后经过处理的流程。</p><p><img src="https://img.darklorder.com/img/202308161520146.svg" alt="网关处理流程图"></p><p>从图中我们可以看出路由是与网关绑定的，路由一般与其后端服务部署在同一个命名空间中，如果在不同的命名空间中时，需要在 <a href="https://gateway-api.sigs.k8s.io/api-types/referencegrant/"><code>ReferenceGrant</code></a> 中明确赋予该路由跨命名空间的引用权限，例如下面的 <code>foo</code> 命名空间中的 HTTPRoute <code>foo</code> 可以引用 <code>bar</code> 命名空间中的 <code>bar</code> 服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">HTTPRoute</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">foo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">matches:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/bar</span><br>    <span class="hljs-attr">forwardTo:</span><br>      <span class="hljs-attr">backend:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">bar</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">bar</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReferenceGrant</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bar</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">bar</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">from:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">networking.gateway.k8s.io</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">HTTPRoute</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">foo</span><br>  <span class="hljs-attr">to:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br></code></pre></td></tr></table></figure><p>目前，Gateway API 仅支持 <code>HTTPRoute</code>，<code>TCPRoute</code>、<code>UDPRoute</code>、<code>TLSRoute</code> 和 <code>GRCPRoute</code> 还在实验阶段。Gateway API 已经得到了大量的网关和服务网格项目的支持，请<a href="https://gateway-api.sigs.k8s.io/implementations/">在 Gateway 官方文档中查看支持状况</a>。</p><h2 id="入口网关与服务网格"><a href="#入口网关与服务网格" class="headerlink" title="入口网关与服务网格"></a>入口网关与服务网格</h2><p>服务网格主要关注的是东西向流量，即 Kubernetes 集群内部的流量，但是大部分服务网格同样提供了入口网关功能，例如 Istio。但是 Istio 的功能和 API 过于复杂，在本文中我们就以 SMI 为例来说明入口网关和服务网格的关系。</p><p><a href="https://smi-spec.io/">SMI</a>（Service Mesh Interface）是 CNCF 的孵化项目，开源与 2019 年，它定义了独立于供应商的在 Kubernetes 中运行的服务网格通用标准。</p><p>下图说明 Gateway API 与服务网格 API 的重叠点。</p><p><img src="https://img.darklorder.com/img/202308161520390.svg" alt="Gateway API 与 SMI 有部分重合"></p><p>从图中我们可以看到 Gateway API 与 SMI 在流量规范部分有明显的重叠。这些重叠导致同样的功能，需要在 Gateway API 和服务网格中重复实现。</p><h3 id="Istio-服务网格"><a href="#Istio-服务网格" class="headerlink" title="Istio 服务网格"></a>Istio 服务网格</h3><p>当然，并不是所有的服务网格是完全符合 SMI 标准，Istio 是目前最流行的服务网格实现，它提供了丰富的流量管理功能，但是没有对这些功能制定单独的策略 API，而是耦合在 <code>VirtualService</code> 和 <code>DestinationRule</code> 中，如下所示。</p><p><strong>VirtualService</strong></p><ul><li>路由：金丝雀发布、基于用户身、URI、Header 等匹配路由等；</li><li>错误注入：HTTP 错误代码注入、HTTP 延时注入；</li><li>流量切分：基于百分比的流量切分路由；</li><li>流量镜像：将一定百分比的流量镜像发送到其他集群；</li><li>超时：设置超时时间，超过设置的时间请求将失败；</li><li>重试：设置重试策略，如触发条件、重试次数、间隔时间等；</li></ul><p><strong>DestinationRule</strong></p><ul><li>负载均衡：设置负载均衡策略，如简单负载均衡、区域感知负载均衡、区域权重负载均衡；</li><li>熔断（Circuit Breaking）：通过异常点检测（Outlier Detection）和连接池设置将异常节点从负载均衡池中剔除；</li></ul><p><code>VirtualService</code> 主要处理路由相关功能，而 <code>DestinationRule</code> 负责集群节点的开合和负载均衡。</p><h3 id="Gateway-API-融合-Kubernetes-和服务网格的入口网关"><a href="#Gateway-API-融合-Kubernetes-和服务网格的入口网关" class="headerlink" title="Gateway API 融合 Kubernetes 和服务网格的入口网关"></a>Gateway API 融合 Kubernetes 和服务网格的入口网关</h3><p>正如上文所述，Gateway API 与服务网格之间有部分功能交集，为了减少重复开发，促成对 Gateway API 与服务网格之间共同关注点的建模，Gateway API 工作组提出了 <a href="https://gateway-api.sigs.k8s.io/contributing/gamma/">GAMMA</a>（Gateway API Mesh Management and Administration）倡议。</p><p>在该倡议的倡导下，那些在不同网关实现中的细节各不相同的高级流量管理功能，例如超时、重试、健康检查等，全部通过<a href="https://gateway-api.sigs.k8s.io/references/policy-attachment/">策略附件</a>（Policy Attachment）的方式将由各个提供商来实现。你可以通过通过 <code>targetRef</code> 字段指定策略附件所附加到的资源对象，例如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.acme.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RetryPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">override:</span><br>    <span class="hljs-attr">maxRetries:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">default:</span><br>    <span class="hljs-attr">maxRetries:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">targetRef:</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">gateway.networking.k8s.io/v1alpha2</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">HTTPRoute</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span><br></code></pre></td></tr></table></figure><p>在这里例子中重试策略被附加到了名为 <code>foo</code> 和 <code>HTTPRoute</code> 上。策略附件附加到不同的资源对象上，其生效的优先级也不同，例如 GatewayClass 是集群级的资源，如果策略附件覆盖在它上面的话，将优先生效。</p><p>你可以给附加策略指定 <code>override</code> 和 <code>default</code> 值，其在入口和网格内不同资源上的层次结构的优先级是如下图所示。</p><p><img src="https://img.darklorder.com/img/202308161521504.svg" alt="Kubernetes 入口与网格中的覆盖和默认值的优先级"></p><p>目前，Gateway API 正在探索用来处理网格流量，并提出了一些<a href="https://docs.google.com/document/d/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU/edit#heading=h.6ks49gf06yii">设计方案</a>。</p><h2 id="Envoy-Gateway"><a href="#Envoy-Gateway" class="headerlink" title="Envoy Gateway"></a>Envoy Gateway</h2><p>2022 年 10 月 Envoy Gateway 首个开源版本 <a href="/blog/envoy-gateway-release/">v0.2 发布</a>，这是一个基于 Envoy 代理的遵循 Gateway API 而创建的网关，<a href="https://tetrate.io/">Tetrate</a> 是该项目的核心发起者之一。Envoy Gateway 的目标是降低用户采用 Envoy 作为 API 网关的障碍，以吸引更多用户采用 Envoy。它通过入口和 L4&#x2F;L7 流量路由，表达式、可扩展、面向角色的 API 设计，使其成为供应商建立 API 网关增值产品的基础。</p><p>早在 Envoy Gateway 发布之前，Envoy 作为最流行了云原生代理之一，已被大规模采用，有多款 Gateway 软件基于 Envoy 构建，Istio 服务网格使用它作为默认的 sidecar 代理，并通过 xDS 协议来配置这些分布式代理。在 Envoy Gateway 中，它同样使用 xDS 来配置 Envoy 机群，下图展示了 Envoy Gateway 的架构。</p><p><img src="https://img.darklorder.com/img/202308161521590.svg" alt="Envoy Gateway 架构图"></p><p>基础设施供应商会为你提供 <code>GatewayGlass</code>，你可以通过创建一个 Gateway 声明来创建一个 Envoy Gateway，你在 Gateway 中的路由和策略附件会通过 xDS 协议发送给 Envoy 机群。</p><p>关于 Envoy Gateway 的进一步介绍，请阅读：</p><ul><li><a href="https://lib.jimmysong.io/blog/hands-on-with-envoy-gateway/">使用 Envoy Gateway 0.2 体验新的 Kubernetes Gateway API</a></li><li><a href="https://lib.jimmysong.io/blog/envoy-gateway-to-the-future/">面向未来的网关：新的 Kubernetes Gateway API 和 Envoy Gateway 0.2 介绍</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Gateway API 作为下一代 Kubernetes Ingress API，为 Kubernetes 网关供应商提供一定程度上的 API 规范，在保证其可移植性的前提下丰富了入口网关的功能，同时通过关注点分离方便不同角色的人员对网关进行管理。最后 GAMMA 倡议正在促进服务网格的入口网关与 Gateway API 的融合，策略附件可能将 Gateway API 的功能进一步扩展到东西向网关，我们拭目以待。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://lib.jimmysong.io/kubernetes-handbook/service-discovery/gateway/">Gateway API - lib.jimmysong.io</a></li><li><a href="https://atbug.com/explore-k8s-gateway-api-policy-attachment/">一文搞懂 Kubernetes Gateway API 的 Policy Attachment - atbug.com</a></li><li><a href="https://atbug.com/why-smi-collaborating-in-gateway-api-gamma/">SMI 与 Gateway API 的 GAMMA 倡议意味着什么？- atbug.com</a></li><li><a href="https://kccncna19.sched.com/#">Evolving the Kubernetes Ingress APIs to GA and Beyond - Christopher M Luciano, IBM &amp; Bowei Du, Google</a></li></ul><p><strong>参考资料</strong><br><a href="https://jimmysong.io/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/">Gateway API：Kubernetes 和服务网格入口中网关的未来 · Jimmy Song</a></p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完美自杀方法</title>
    <link href="/2022/11/11/Perfect-Suicide-Method/"/>
    <url>/2022/11/11/Perfect-Suicide-Method/</url>
    
    <content type="html"><![CDATA[<ul><li>洗一个热水澡 </li><li>泡一杯热牛奶 加点蜂蜜 </li><li>把空调开到舒适的温度 </li><li>喝下牛奶 躺到床上 </li><li>等你睁开眼看见太阳升起就是你已经死了并轮回了</li></ul><p>用新身份新心情去重新活吧 嘘 —直是孟婆搞错 不小心让你的下一世和上一世有点像而已.</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes部署疑难解答的可视化指南</title>
    <link href="/2022/11/01/troubleshooting-deployments/"/>
    <url>/2022/11/01/troubleshooting-deployments/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://img.darklorder.com/img/202308161223176.png" alt="A visual guide on troubleshooting Kubernetes deployments"></p><p><strong>参考资料</strong><br><a href="https://learnk8s.io/troubleshooting-deployments">A visual guide on troubleshooting Kubernetes deployments</a></p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生 2.0 白皮书</title>
    <link href="/2022/10/01/Cloud-native-white-paper/"/>
    <url>/2022/10/01/Cloud-native-white-paper/</url>
    
    <content type="html"><![CDATA[<p>企业 IT 建设的三阶段两转变，进入云原生阶段</p><span id="more"></span><p>简单来看，企业 IT 建设所依赖的基础资源经历了从服务器到云化资源的发展历程，正在快速进入云原生阶段。</p><p>服务器阶段 ：其特点是以硬件设备为中心，业务应用随不同厂商设备、操作系统、虚拟化软件的差异化进行定制；设备的安装、调试，应用的部署、运维基本靠人力完成，自动化程度低，缺乏统一的设备和应用管理能力。后期随着虚拟化软件的出现，资源的利用率、扩缩容器的灵活性方面得到一定的提升，但并未从根本上解决基础设施与软件割裂、运维复杂的难题。</p><p>云化阶段：传统模式下分布离散的设备，被统一起来，实现了各类资源如计算、存储、网络的池化，通过统一的虚拟化软件平台，为上层业务软件提供统一的资源管理接口，实现资源管理能力的自动化，屏蔽一部分基础设施的差异，使得应用的通用性增强，但因为虚拟化软件平台差异化较大，尤其是各厂商的一些商业化增强，无法在厂商间进行能力共享，应用还是无法以完全标准化的模式构建，应用部署还是以资源为中心。</p><p>云原生阶段：在这一阶段，企业的关注点从以资源为中心转移到以应用为中心，包括应用敏捷交付、快速弹性、平滑迁移、无损容灾等。因此，企业开始考虑如何将基础设施与业务平台融合，为业务应用提供标准的运行、监控、治理平台，并将业务的通用能力下沉到平台侧，更好的帮助企业实现应用的自动化。</p><p><strong>企业IT数字化转型的“三阶段两转变”</strong></p><img src="https://img.darklorder.com/img/202307311440454.png"/><p><strong>参考资料</strong><br>云原生2.0白皮书</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式计算中的八大谬论</title>
    <link href="/2022/10/01/The-Eight-Fallacies-of-Distributed-Computing/"/>
    <url>/2022/10/01/The-Eight-Fallacies-of-Distributed-Computing/</url>
    
    <content type="html"><![CDATA[<p>分布式计算中的八大谬论</p><span id="more"></span><img src="https://img.darklorder.com/img/202307070417934.jpeg"/><p>构建分布式系统是一项复杂的工作。架构，设计，编码和测试对分布式系统的成功都至关重要。任何一点的失败都可能导致性能下降，故障频发，费用超标以及最终导致客户流失。在20世纪90年代Sun Microsystems的Peter Deutsch，James Gosling和其他人总结出了分布式计算的八个谬论。随着时间的推移，IT人员对这些谬论的认识可能已经消退，所以想要提醒下大家。</p><h3 id="八大谬论是："><a href="#八大谬论是：" class="headerlink" title="八大谬论是："></a><strong>八大谬论是：</strong></h3><p><strong>网络可靠。 The network is reliable.</strong><br><strong>延迟为零。 Latency is zero.</strong><br><strong>带宽是无限的。 Bandwidth is infinite.</strong><br><strong>网络是安全的。 The network is secure.</strong><br><strong>拓扑不会改变。 Topology doesn’t change.</strong><br><strong>只有一个管理员。 There is one administrator.</strong><br><strong>运输成本为零。 Transport cost is zero.</strong><br><strong>网络是同质的。The network is homogeneous.</strong></p><h4 id="网络可靠"><a href="#网络可靠" class="headerlink" title="网络可靠"></a>网络可靠</h4><p>在局域内，网络可能看起来坚如磐石。毕竟，现在网络组件多久失败一次？即使单个组件发生故障，也确实存在大量冗余？那么，随着网络变得越来越复杂，网络管理就越容易出错，大多数都是配置错误。在某些情况下，多达三分之一的网络更改会导致影响网络可靠性的错误。软件和硬件都可能出现故障，尤其是路由器，它们占所有故障的四分之一左右。“不间断”电源也可能会中断，人们可能会发生不明智的设备配置更改，并且可能存在网络拥塞，拒绝服务（DoS）攻击以及软件和固件升级或修补程序失败。网络遭受自然灾害和非自然灾害，设计一个对这类东西具有弹性的网络需要技巧。广域链接超出您的控制范围，很容易出错。</p><p>最近几个月，Azure上的事件令人痛苦，而且这种失败率是主要云服务提供商的典型特征。对于移动应用程序，各种各样的事情都可能会出错：网络请求将以不可预测的间隔失败，目标将不可用，数据将到达目的地但无法发回确认，数据将在传输中损坏或到达不完整。移动应用程序必须在网络可靠性范围的可怕范围内具有弹性，但所有分布式应用程序必须能够应对所有这些可能性，并且网络节点必须能够应对服务器故障。</p><h4 id="延迟为零"><a href="#延迟为零" class="headerlink" title="延迟为零"></a>延迟为零</h4><p>延迟与带宽不同。延迟是等待响应所花费的时间。除了明显的处理延迟外，还有网络延迟，包括传播延迟，节点延迟和拥塞延迟。传播延迟随距离增加：约为30 ms。欧洲和美国之间。路径中的节点数决定了节点延迟。</p><p>通常，开发人员在内部网中构建分布式系统，这些系统具有无关紧要的延迟，因此进行频繁的细粒度网络调用几乎不会受到惩罚。这种设计错误只有在投入实时系统时才会变得明显。</p><p>高延迟的一个令人不安的影响是它不是恒定的。在糟糕的网络上，偶尔可以在几秒钟内计算出来。就其性质而言，无法保证网络服务单个数据包的顺序，甚至不能保证请求进程仍然存在。延迟会让事情变得更糟。此外，在应用程序通过发送多个同时请求进行补偿的情况下，可以通过对其的响应来加剧暂时高延迟。</p><h4 id="带宽是无限的"><a href="#带宽是无限的" class="headerlink" title="带宽是无限的"></a>带宽是无限的</h4><p>虽然大多数现代电缆可以处理几乎无限的带宽，但我们还没有找到如何构建足够快的互连设备（集线器，交换机，路由器等）以保证所有连接用户的高带宽。典型的企业内部网仍将具有限制带宽的区域。</p><p>随着公共网络带宽的增加，网络对使用视频和音频的服务的使用也一样快，而视频和音频曾经使用过广播技术。诸如社交媒体之类的新用途往往会吸收不断增加的带宽。此外，主要城市以外的许多地方都存在“最后一英里”的限制，并且丢包的可能性也在增加。</p><p>一般而言，我们需要谨慎地假设高带宽是一种普遍的体验。无论网络带宽如何令人印象深刻，它都无法接近共同托管进程可以通信的速度。</p><h4 id="网络是安全的"><a href="#网络是安全的" class="headerlink" title="网络是安全的"></a>网络是安全的</h4><p>令人遗憾的是仍然遇到具有基本安全漏洞的基于网络的系统。网络攻击逐年增加，并且在好奇心，恶意和犯罪方面已经超越了它们的原始根源，成为国际冲突和政治“行动”的一部分。网络攻击是IT生活的一部分：对开发人员来说很无聊，但却是必不可少的。部分问题是网络入侵检测往往是低优先级，因此我们并不总是意识到成功的网络攻击。</p><p>传统上，漏洞通常是配置不当的防火墙的结果。大多数防火墙都会经常被检测出来，因为你会立即发现你是否愚蠢地禁用它们。然而，这只是破坏网络和防火墙的一种方式中的一种，只是防御的一部分。Wi-Fi通常是一个弱点，使用自己的设备（BYOD）可以允许通过受损设备进行入侵，虚拟化和软件定义网络（SDN）也是如此。越来越多的DevOps对快速变化的基础设施的需求使得更难以保持必要的控制措施。企业网络中的僵尸网络是一个持续存在的问题，以及通过业务合作伙伴的入侵。</p><p>您需要假设网络是敌对的，并且安全性必须深入。这意味着将安全性构建到分布式应用程序及其主机的基本设计中。</p><p>通过纵深防御，分布式系统的任何部分都需要具有访问其他网络资源的安全方式。</p><p>安全带来了自身的复杂性。这将来自维护不同用户帐户，权限，证书，帐户等的管理开销。一个主要的云网络中断是由于权限在更新之前到期而导致的。</p><h4 id="拓扑不会改变"><a href="#拓扑不会改变" class="headerlink" title="拓扑不会改变"></a>拓扑不会改变</h4><p>网络拓扑不断变化，速度非常快。由于“网络敏捷性”的压力越来越大，这是不可避免的，以便与快速变化的业务需求保持同步。</p><p>无论您在何处部署应用程序，都必须假设大部分网络拓扑都可能无法控制。网络管理员将一次进行更改，原因可能不符合您的利益。他们将移动服务器并更改网络拓扑以获得性能或安全性，并在服务器和网络故障的情况下进行路由更改。</p><p>因此，依赖特定端点或路由的持久性是错误的。必须始终从任何分布式设计中抽象出网络的物理结构。</p><h4 id="只有一个管理员"><a href="#只有一个管理员" class="headerlink" title="只有一个管理员"></a>只有一个管理员</h4><p>除非系统完全存在于小型LAN中，否则将有不同的管理员与网络的各种组件相关联。他们将拥有不同程度的专业知识，不同的职责和优先事项。</p><p>如果出现导致服务失败的问题，这将很重要。您的服务级别协议将要求在一定时间内做出响应。第一阶段将是确定问题。除非有问题的网络部分的管理员是您的开发团队的一部分，否则这可能并不容易。不幸的是，这不太可能。在许多网络中，问题可能完全是另一个组织的责任。如果云组件是应用程序的重要组成部分，并且云中断，则无法确定优先级。你所能做的就是等待。</p><p>如果网络中有许多管理员，那么协调升级到网络或应用程序就更加困难，特别是当涉及到几个忙碌的人时。升级和部署必须协调完成，涉及的人数越多，这就变得越困难！</p><h4 id="运输成本为零"><a href="#运输成本为零" class="headerlink" title="运输成本为零"></a>运输成本为零</h4><p>运输成本是指通过网络传输数据的总体成本。我们可以参考时间和计算机资源，或者我们可以参考财务成本。</p><p>将数据从应用程序层传输到传输层需要CPU和其他资源。需要对结构化信息进行序列化（编组）或解析以将数据传输到线路上。这种性能影响可能大于带宽和延迟时间，因为XML的冗长和复杂性使得XML占用JSON的两倍。</p><p>金融运输成本不仅包括创建网络的硬件和安装成本，还包括监控和维护网络服务器，服务和基础设施的成本，以及如果发现带宽不足，或者您的服务器实际上无法处理足够的并发请求。我们还需要考虑租用线路和云服务的成本，这些成本由所使用的带宽支付</p><h4 id="网络是同质的"><a href="#网络是同质的" class="headerlink" title="网络是同质的"></a>网络是同质的</h4><p>今天的同质网络是罕见的，甚至比首次发现谬论时更为罕见！网络可能连接计算机和其他设备，每个设备具有不同的操作系统，不同的数据传输协议，并且所有设备都与来自各种供应商的网络组件相连。</p><p>但是，异构网络没有什么特别的错误，除非它涉及需要专门支持，设备或驱动程序的专有数据传输协议。从应用程序的角度来看，如果数据以开放标准格式（如CSV，XML或JSON）传输，并且使用行业标准的查询数据（如ODBC）的方法，则会有很大帮助。</p><p>如果所有组件都来自一个供应商，则可靠性更高，因为测试覆盖范围可能更大，但实际情况是组件的丰富组合。这意味着互操作性应该从任何分布式系统的设计开始就内置。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>虽然这个指导是在二十年前制定的，但我们今天仍在犯这些错误。这些错误显示为不安全的端点，由于大型对象的序列化导致的超时，丢失的事务，性能降低等等。避免这些错误意味着在每次设计和代码审查中需要考虑这些谬论。</p><p><strong>参考资料</strong><br><a href="https://dandelioncloud.cn/article/details/1526804530352373762/">分布式计算中的八大谬论-蒲公英云</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云原生</title>
    <link href="/2022/09/30/Cloud-Native/"/>
    <url>/2022/09/30/Cloud-Native/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>K8S | Ceph | Prometheus | 分布式路链追踪 | Envoy | Istio | Knative | GitOps</strong></p><img src="https://img.darklorder.com/img/202308030631850.png"/><p><strong>参考资料</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker面试题</title>
    <link href="/2022/09/18/Docker-Interview-Questions/"/>
    <url>/2022/09/18/Docker-Interview-Questions/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>参考资料</strong><br><a href="https://">XXXX</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器十诫</title>
    <link href="/2022/09/16/10-things-to-avoid-in-docker-containers/"/>
    <url>/2022/09/16/10-things-to-avoid-in-docker-containers/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://img.darklorder.com/img/202308151811281.jpeg"></p><p>当你刚开始使用容器时，会发现容器能解决许多问题，而且好处很多：</p><ul><li>首先：容器是不可变的 —— 操作系统、库版本、配置、文件夹以及应用全都包裹在容器内。你可以确保，在 QA 阶段测试的一张图片，肯定会在生产环境中出现，并且行为保持一致。</li><li>其次：容器是轻量级的 —— 容器的内存占用很小。容器只会给主进程分配内存，因此无需十几万个 MB 的内存空间。</li><li>最后：容器速度很快 —— 启动容器就跟启动典型的 linux 进程一样快。无需好几分钟，一个新的容器可以在几秒内启动完毕。</li></ul><p>然而，许多用户仍然只是将容器视为典型的虚拟机。他们忘记了容器的一个重要特征：<strong>容器是可丢弃的</strong>。</p><p>围绕容器的咒语：“容器是临时的”。</p><p><img src="https://img.darklorder.com/img/202308151811693.png"></p><p>鉴于这一特征，用户必须转变他们使用以及管理容器时的心态。下面，笔者将介绍为了充分利用 Docker 容器的好处，用户应该<strong>避免</strong>的十个陷阱：</p><p><strong>1）不要在容器内存储数据</strong> —— 容器可以被停止、销毁或者取代。运行在容器中的应用1.0版本应该能够轻易地被1.1版本所取代，且不产生任何影响或数据丢失。因此，如果你需要存储数据，请将其存储在卷组(volume)中。在这种情况下，你要格外小心两个容器向同一卷组写入数据的情况，因为这很容易导致数据污染。总之，要确保自己的应用向共享的数据存储区填写数据。</p><p><strong>2）不要将应用分开发布</strong> —— 有些人会将容器视为虚拟机，他们中的大部分人认为，应该在现有的运行容器中部署应用。在开发阶段，因为需要不断地修改配置并调试应用，这样做无可厚非。但是，当持续交付管道行进至 QA 与生产阶段时，不应该把镜像和应用分开。记住：容器是<strong>不可变</strong>的。</p><p><strong>3）不要创建太大的镜像</strong> —— 镜像越大，越难以分发。确保只留有运行应用或进程所需的文件和库。不要安装不必要的包或运行“update”(yum update)指令下载太多文件到新的镜像层。</p><p>更新：关于这条建议，有一篇解释更为详尽的文章：<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://developers.redhat.com/blog/2016/03/09/more-about-docker-images-size/">《保持小巧：细究 Docker 镜像大小》</a></p><p><strong>4）不要使用单层镜像</strong> —— 为了有效利用分层的文件系统，总是为操作系统创建基础镜像层，此外，分别为<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https://github.com/jboss-dockerfiles/base/blob/master/Dockerfile">用户名定义</a>、<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https://github.com/jboss-dockerfiles/wildfly/blob/master/Dockerfile">运行时安装</a>、配置、以及自己的应用创建不同的镜像层。这样一来，重现、管理以及传送镜像会变得更为简单。</p><p><strong>5）不用为运行中的容器创建镜像</strong> —— 换句话说，不要使用 “docker commit” 指令创建镜像。这种创建镜像的方法是不可重现的，应该完全避免。相反，总是使用 Dockerfile 或任何 S2I (source-to-image，源码到镜像) —— 完全可重现的方法来创建镜像。这样一来，如果你将 Dockerfile 保存在源码存储控制库(git)内，就可以追踪其后续变化。</p><p><strong>6）不要单独使用“latest(最新)”标签</strong> —— 最新标签就像 Maven 用户眼中的 “SNAPSHOT(快照)”。因为容器本身的分层式文件系统，我们鼓励使用标签。但是，你可不想在几个月后正打算创建镜像时，却惊讶地发现应用无法运行，而原因居然是一个父层(Dockerfile 中的 FROM)已经被无法向后兼容的新版取代，或是创建缓存中检索出的“最新”版本是错的。此外，由于你无法追踪当前运行镜像的版本，“最新”标签也不应该在生产环境中部署容器时使用。</p><p><strong>7）不要在一个容器内运行多个进程</strong> —— 容器在运行单一进程(http 后台进程、应用服务器、数据库)时几乎无可挑剔，但是，如果运行多个进程，你可能会在管理、检索日志以及独个更新进程时遇到麻烦。</p><p><strong>8）不要在镜像中存储凭证</strong> —— 使用环境变量。不要将镜像中的任何用户名或密码写死。使用环境变量从容器外部检索这些信息。<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https://github.com/docker-library/postgres/blob/443c7947d548b1c607e06f7a75ca475de7ff3284/9.5/docker-entrypoint.sh">Postgress 镜像</a>就是践行该准则的好榜样。</p><p><strong>9）不要以 root 用户运行进程</strong> —— “默认情况下，docker 容器以 root 权限运行。(…)随着 Docker 的不断完善，更多<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://blog.oneapm.com/tags-%25E5%25AE%2589%25E5%2585%25A8.html">安全</a>的默认选项会逐渐出现。就当下而言，要求 root 权限对有些用户而言比较危险，可能无法在所有环境中实现。你的镜像应该使用 USER 指令为容器确定一个非 root 运行权限。”（摘自<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://www.projectatomic.io/docs/docker-image-author-guidance/">《Docker 镜像作者指南》</a>）</p><p><strong>10）不要依赖 IP 地址</strong> —— 每个容器都有其内部 IP 地址，该地址可能因为启动或停止容器而发生改变。如果你的应用或微服务需要与另一个容器交换消息，应该使用环境变量在容器间传送合适的主机名与端口号。</p><p><strong>参考资料</strong><br><a href="http://developerblog.redhat.com/2016/02/24/10-things-to-avoid-in-docker-containers/">OneAPM 官方博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器并不能解决一切问题</title>
    <link href="/2022/09/15/Containers-dont-solve-everything/"/>
    <url>/2022/09/15/Containers-dont-solve-everything/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>我们的行业在过去十年中取得了令人难以置信的进步，这在一定程度上要归功于 Docker、Docker Compose 和 Kubernetes 等技术。然而，我们仍在研究如何在我们所处的多样化环境中进行开发。</p><p>容器化在开发和运维领域掀起了一场风暴。在过去，部署是高度依赖于特定技术的，通常需要对每个项目进行大量不可重复的工程工作。你是否部署到 VPS？你是否在分发虚拟机镜像？静态可执行文件？需要特定解释器的脚本? 根据你对这些问题的回答，你可能已经使用了 Capistrano、Puppet、shell 脚本、Ansible、deb 或 rpm 包、cloud-init 脚本、专有云技术、upstart、systemd、init 等很多技术。在部署阶段，系统管理和开发之间的界限就变得模糊了，DevOps 的原则就诞生了。随着 DevOps 开始成熟，业界发展出了应用开发的最佳实践，比如 12 因素应用程序方法论，但许多实现细节仍然是依赖于特定技术的。</p><h3 id="1、进入-Docker"><a href="#1、进入-Docker" class="headerlink" title="1、进入 Docker"></a><strong>1、进入 Docker</strong></h3><p><img src="https://img.darklorder.com/img/202308151728741.png"></p><p>使用 Docker 打包和部署</p><p>然后 Docker 出现了，并通过如下简单的规则使应用程序的部署产品化：如果你的应用程序可以打包成一个容器，那么它就可以部署在任何地方。容器并不是什么新鲜事——毕竟，谷歌已经使用它们很多年了。Unix 黑客也曾出于类似目的使用 Solaris Zones 和 FreeBSD jail。然而，在 Docker 出现之前，还没有一个很好的方式可以轻松地将应用程序打包到一个可移植的容器中。Docker 彻底改变了我们部署应用程序的方式。</p><p>Docker 解决了许多重要的部署问题，所以接下来要问的问题是 Docker 是否为开发提供了任何优势。拥有一个看起来（至少大体看起来）像生产环境的开发环境有很多好处。如果你在生产环境中部署 Docker 容器，那么在开发过程中在容器中运行代码也是合理的。此外，Docker 还解决了版本依赖关系的问题。例如，如果你有一个应用程序需要 MySQL 5.3，而另一个应用程序需要 MySQL 5.7，那么你就不需要在本地运行两个版本，也不需要在各自的虚拟机中运行每个版本。你可以为每个版本使用一个容器，它们可以在几秒钟内启动和停止。</p><p>使用 Docker Compose 进行开发</p><p><img src="https://img.darklorder.com/img/202308151728306.png"></p><p>2013 年底，Docker Compose（当时称为 fig）进入了这个领域。Docker Compose 有一个简单的前提：与使用一次性脚本启动和停止应用程序及其在开发中的依赖不同，你把它们描述为 YAML 文件中的 Docker 容器，并让 Docker Compose 管理它们的生命周期。它提供了一些额外的细节，如为 12 因素应用程序提供日志采集、环境变量以及基本容器网络。简而言之，Docker Compose 对那些想要使用容器化的方法开发 12 因素应用程序的开发人员来说是一种完美工具。</p><p>乍一看，Docker Compose 似乎是本地开发的理想解决方案——在许多情况下，它确实是。然而，就像它的名字一样，它只关注那些一切都在 Docker 内部运行的开发工作流。在某些情况下，这样做很好。例如，如果你在 Node.JS 中编写一个依赖于 Postgres 的 API，那么你可以在 nodejs 容器中运行代码（可能在它前面有一个文件监视器），在 Postgres 容器中运行 Postgres。然而，并不是所有的开发工作流都可以被容器化。无论是为了性能、易于与主机操作系统特性集成，还是其他许多原因，有时最好将开发环境的某些部分作为本地进程运行，而将其他部分作为容器运行。你仍然需要拼凑一个解决方案，以将非 Docker 部分与一些 Docker 容器进行集成。</p><p>此外，考虑到 Docker 依赖于 Linux 内核特定的特性来实现容器，macOS、Windows、FreeBSD 和其他操作系统的用户仍然需要虚拟化层。我们想要通过使用容器来摆脱的一系列复杂的网络、文件同步和虚拟机管理等问题仍然存在。当然，它们通常是可以工作的——直到出现问题，这时我们就只剩下谷歌、Stack Overflow 和 GitHub 来帮助我们找到解决方案。</p><h3 id="2、现代开发：云和微服务"><a href="#2、现代开发：云和微服务" class="headerlink" title="2、现代开发：云和微服务"></a><strong>2、现代开发：云和微服务</strong></h3><p><img src="https://img.darklorder.com/img/202308151728069.png"></p><p>云原生开发的复杂性</p><p>快进到 2021 年，大多数生产级应用也依赖于云基础设施，这些基础设施不能作为本地 Docker 容器运行，因此我们面临一系列新的问题，每个问题都需要权衡：</p><ul><li><p>我们是否将云服务存根？这种方法成本低、性能好，但除了非常简单的服务外，维护本地存根所需工程量很高。</p></li><li><p>每个开发人员是否都有自己的每个云资源实例？这通常代价高昂，公司必须支付很高的成本来保留很少使用的基础设施。无服务器产品通常比预留产品有更好的成本模型，但仍然必须考虑成本。</p></li><li><p>开发人员是否共享共同的开发基础设施？在此选项中，基础设施成本降低了，但通常需要额外的工程量，以便多个应用程序可以共享相同的数据库和其他有状态服务而不会发生冲突。换句话说，每个应用程序都必须支持多租户。</p></li></ul><p>以上选项在不同的场景中都是可行的，但这里要说的是采用 Docker 或者 Docker Compose 并不能解决问题——甚至不能指出哪个选项是最好的！现代开发环境编排器必须具有云感知能力并支持不同的运行时架构。目前，基础设施即代码工具最接近解决这个问题，但由于它们专注于生产部署，因此无法与本地开发环境顺利集成。</p><p>除了云服务，微服务还具有它们自身的复杂性，这些复杂性是“仅仅使用 Docker”无法解决的。任何采用了微服务策略的大型组织都会迅速发展到任何开发人员都可以在其笔记本电脑上运行该组织所有服务的地步。像 Telepresence 这样的工具有助于将本地容器连接到远程 Kubernetes 集群中运行的容器，但我们仍然缺乏能够跨本地和远程环境透明地处理服务发现、代理和身份验证等问题的高级工具。而且，现有的工具大多是以 kubernetes 为中心的，这给很多开发人员增加了使用难度。</p><h3 id="3、下一步是什么？"><a href="#3、下一步是什么？" class="headerlink" title="3、下一步是什么？"></a><strong>3、下一步是什么？</strong></h3><p>我们的行业在过去十年中取得了令人难以置信的进步，这在一定程度上要归功于 Docker、Docker Compose 和 Kubernetes 等技术。然而，我们仍在研究如何在我们所处的多样化环境中进行开发。下一代开发工具必须能够处理本地进程、Docker 容器、云服务，甚至其他团队的微服务的构建和运行。针对所有这些问题，我们还没有答案，但我们正在构建 exo，以帮助像我们这样的开发者克服本地开发的复杂性。</p><p><strong>参考资料</strong><br><a href="https://blog.deref.io/containers-dont-solve-everything/">容器并不能解决一切问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器进入的4种方式</title>
    <link href="/2022/09/14/Docker-container-into-the-running-of-four-ways/"/>
    <url>/2022/09/14/Docker-container-into-the-running-of-four-ways/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Docker容器进入的4种方式"><a href="#Docker容器进入的4种方式" class="headerlink" title="Docker容器进入的4种方式"></a>Docker容器进入的4种方式</h2><hr><p>在使用Docker创建了容器之后，大家比较关心的就是如何进入该容器了，其实进入Docker容器有好几多种方式，这里我们就讲一下常用的几种进入Docker容器的方法。</p><p>进入Docker容器比较常见的几种做法如下：</p><ul><li>使用docker attach</li><li>使用SSH</li><li>使用nsenter</li><li>使用exec</li></ul><h3 id="一、使用docker-attach进入Docker容器"><a href="#一、使用docker-attach进入Docker容器" class="headerlink" title="一、使用docker attach进入Docker容器"></a>一、使用docker attach进入Docker容器</h3><p>Docker提供了attach命令来进入Docker容器。</p><p>接下来我们创建一个守护态的Docker容器，然后使用docker attach命令进入该容器。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -itd ubuntu:<span class="hljs-number">14.04</span> <span class="hljs-regexp">/bin/</span>bash  <br></code></pre></td></tr></table></figure><p>然后我们使用docker ps查看到该容器信息，接下来就使用docker attach进入该容器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker attach <span class="hljs-number">44f</span>c0f0582d9  <br></code></pre></td></tr></table></figure><p>可以看到我们已经进入到该容器中了。</p><p>但在，使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。</p><p>因为这个原因，所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令。</p><h3 id="二、使用SSH进入Docker容器"><a href="#二、使用SSH进入Docker容器" class="headerlink" title="二、使用SSH进入Docker容器"></a>二、使用SSH进入Docker容器</h3><p>在生产环境中排除了使用docker attach命令进入容器之后，相信大家第一个想到的就是ssh。在镜像（或容器）中安装SSH Server，这样就能保证多人进入容器且相互之间不受干扰了，相信大家在当前的生产环境中（没有使用Docker的情况）也是这样做的。但是使用了Docker容器之后不建议使用ssh进入到Docker容器内。关于为什么不建议使用，请参考如下文章：</p><p><a href="http://www.oschina.net/translate/why-you-dont-need-to-run-sshd-in-docker?cmp">为什么不需要在 Docker 容器中运行 sshd</a></p><h3 id="三、使用nsenter进入Docker容器"><a href="#三、使用nsenter进入Docker容器" class="headerlink" title="三、使用nsenter进入Docker容器"></a>三、使用nsenter进入Docker容器</h3><p>在上面两种方式都不适合的情况下，还有一种比较方便的方法，即使用nsenter进入Docker容器。关于什么是nsenter请参考如下文章：</p><p><a href="https://github.com/jpetazzo/nsenter">https://github.com/jpetazzo/nsenter</a></p><p>在了解了什么是nsenter之后，系统默认将我们需要的nsenter安装到主机中</p><p>如果没有安装的话，按下面步骤安装即可（注意是主机而非容器或镜像）</p><p>具体的安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"> wget https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"> tar -xzvf util-linux-2.24.tar.gz</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"> <span class="hljs-built_in">cd</span> util-linux-2.24/</span>  <br><span class="hljs-meta prompt_">$</span><span class="language-bash"> ./configure --without-ncurses</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"> make nsenter</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"> sudo <span class="hljs-built_in">cp</span> nsenter /usr/local/bin</span><br></code></pre></td></tr></table></figure><p>安装好nsenter之后可以查看一下该命令的使用。</p><p><img src="https://img.darklorder.com/img/202308221521097.png"></p><p>nsenter可以访问另一个进程的名称空间。所以为了连接到某个容器我们还需要获取该容器的第一个进程的PID。可以使用docker inspect命令来拿到该PID。</p><p>docker inspect命令使用如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"> sudo docker inspect --<span class="hljs-built_in">help</span></span> <br></code></pre></td></tr></table></figure><p>inspect命令可以分层级显示一个镜像或容器的信息。比如我们当前有一个正在运行的容器</p><p>可以使用docker inspect来查看该容器的详细信息。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker inspect <span class="hljs-number">44</span>fc0f0582d9  <br></code></pre></td></tr></table></figure><p>由其该信息非常多，此处只截取了其中一部分进行展示。如果要显示该容器第一个进行的PID可以使用如下方式</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ sudo docker inspect -f </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.State.Pid</span>&#125;&#125;</span><span class="language-xml"> 44fc0f0582d9  </span><br></code></pre></td></tr></table></figure><p>在拿到该进程PID之后我们就可以使用nsenter命令访问该容器了。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">$ sudo nsenter </span><span class="hljs-literal">--</span><span class="hljs-comment">target 3326 </span><span class="hljs-literal">--</span><span class="hljs-comment">mount </span><span class="hljs-literal">--</span><span class="hljs-comment">uts </span><span class="hljs-literal">--</span><span class="hljs-comment">ipc </span><span class="hljs-literal">--</span><span class="hljs-comment">net </span><span class="hljs-literal">--</span><span class="hljs-comment">pid</span><br><span class="hljs-comment">$ sudo nsenter </span><span class="hljs-literal">--</span><span class="hljs-comment">target 3326 </span><span class="hljs-literal">--</span><span class="hljs-comment">mount </span><span class="hljs-literal">--</span><span class="hljs-comment">uts </span><span class="hljs-literal">--</span><span class="hljs-comment">ipc </span><span class="hljs-literal">--</span><span class="hljs-comment">net </span><span class="hljs-literal">--</span><span class="hljs-comment">pid</span><br></code></pre></td></tr></table></figure><p>其中的3326即刚才拿到的进程的PID</p><p>当然，如果你认为每次都输入那么多参数太麻烦的话，网上也有许多做好的脚本供大家使用。</p><p>地址如下：</p><p><a href="http://yeasy.gitbooks.io/docker_practice/content/container/enter.html">http://yeasy.gitbooks.io/docker_practice&#x2F;content&#x2F;container&#x2F;enter.html</a></p><p><a href="http://www.tuicool.com/articles/eYnUBrR">http://www.tuicool.com/articles/eYnUBrR</a></p><h3 id="四、使用docker-exec进入Docker容器"><a href="#四、使用docker-exec进入Docker容器" class="headerlink" title="四、使用docker exec进入Docker容器"></a><strong>四、使用docker exec进入Docker容器</strong></h3><p>除了上面几种做法之外，docker在1.3.X版本之后还提供了一个新的命令exec用于进入容器，这种方式相对更简单一些，下面我们来看一下该命令的使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"> sudo docker <span class="hljs-built_in">exec</span> --<span class="hljs-built_in">help</span></span>   <br></code></pre></td></tr></table></figure><p>接下来我们使用该命令进入一个已经在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"> sudo docker ps</span>  <br><span class="hljs-meta prompt_">$</span><span class="language-bash"> sudo docker <span class="hljs-built_in">exec</span> -it 775c7c9ee1e1 /bin/bash</span><br></code></pre></td></tr></table></figure><p><strong>参考资料</strong><br><a href="https://www.cnblogs.com/xhyan/p/6593075.html">Docker容器进入的4种方式-純黑色-博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile的最佳实践</title>
    <link href="/2022/09/11/Best-practices-for-writing-Dockerfiles/"/>
    <url>/2022/09/11/Best-practices-for-writing-Dockerfiles/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker通过读取Dockerfile文件中的指令自动构建镜像。Dockerfile文件为一个文本文件，里面包含构建镜像所需的所有的命令。Dockerfile文件遵循特定的格式和指令集 Docker镜像由只读层组成，每个层都代表一个Dockerfile指令。这些层是堆叠的，每个层都是前一层变化的增量。示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">18.04</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make /app</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> python /app/app.py</span><br></code></pre></td></tr></table></figure><p>每个指令构建一层：<br>FROM 根据ubuntu18.04docker镜像创建一个层<br>COPY 将Docker客户端当前的目录文件添加到镜像中<br>RUN 使用make构建应用程序<br>CMD 指定在容器中运行的命令</p><p>通过镜像启动一个容器的时候，会在基础层上添加一个可写层。对正在运行的容器所做的所有更改（例如，写入新文件，修改现有文件和删除文件）都将写入此可写容器层。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="1-创建临时容器"><a href="#1-创建临时容器" class="headerlink" title="1.创建临时容器"></a>1.创建临时容器</h3><p>通过Dockerfile文件定义的镜像，产生的容器尽可能的是临时的。所谓的临时，意思是，容器可停止，销毁，重建和替代为最小设置和配置。</p><h3 id="2-理解构建上下文"><a href="#2-理解构建上下文" class="headerlink" title="2.理解构建上下文"></a>2.理解构建上下文</h3><p>在我们构建镜像的时候，一般情况下，会使用</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker build -t name:<span class="hljs-keyword">tag</span> <span class="hljs-title">.</span><br></code></pre></td></tr></table></figure><p>当你发出一个docker build命令时，当前目录将作为构建的上下文。Dockerfile默认存放在此目录下。但是，你可以通过-f选项指定一个不同的目录。不论Dockerfile文件实际存放在何处。当前目录中的所有文件和目录的递归内容都将作为构建上下文发送到Docker守护程序。</p><p>示例： 创建一个用于构建上下文的目录，并cd进入该目录下。写入”Hello”字符串到一个文本文件中，命名为hello并创建一个Dockerfile文件运行cat命令，通过<code>.</code>构建上下文构建镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> myproject &amp;&amp; <span class="hljs-built_in">cd</span> myproject<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; hello<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;FROM busybox\nCOPY /hello /\nRUN cat /hello&quot;</span> &gt; Dockerfile<br>docker build -t helloapp:v1 .<br></code></pre></td></tr></table></figure><p>将Dockerfile和hello移到不同的目录下，构建第二版镜像（不依赖于上次构建的缓存）。使用-f 指定Dockerfile文件的目录，并指定构建的上下文目录。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">mkdir</span> -p dockerfiles <span class="hljs-built_in">context</span><br>mv Dockerfile dockerfiles &amp;&amp; mv hello <span class="hljs-built_in">context</span><br>docker build --no-cache -t helloapp:v2 -f dockerfiles/Dockerfile <span class="hljs-built_in">context</span><br></code></pre></td></tr></table></figure><p>构建镜像时，不经意包含不必要的文件将会导致一个臃肿的构建上下文和一个臃肿的镜像，这将导致构建镜像时长增加，提交到仓库和从仓库拉取时长，容器运行时大小都将增加。构建镜像时可以看到构建上下文的大小。</p><h4 id="通过-dockerignore文件排除"><a href="#通过-dockerignore文件排除" class="headerlink" title="通过.dockerignore文件排除"></a>通过.dockerignore文件排除</h4><p>要排除与构建无关的文件（不重构源存储库），请使用.dockerignore文件。此文件支持类似于.gitignore文件的排除模式</p><h4 id="使用多级构建"><a href="#使用多级构建" class="headerlink" title="使用多级构建"></a>使用多级构建</h4><p>多级构建允许你大幅减小最终图像的大小而无需努力减少中间层和文件的数量。由于图像是在构建过程的最后阶段构建的，因此可以通过利用构建缓存来最小化图像层。例如，如果您的构建包含多个图层，则可以从较不频繁更改（以确保构建缓存可重用）到更频繁更改的顺序对它们进行排序：</p><ul><li>build程序所需的工具安装</li><li>安装升级库依赖</li><li>生产应用程序</li></ul><p>示例： 一个go应用程序的Dockerfile文件如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.11</span>-alpine AS build<br><br># Install tools required <span class="hljs-keyword">for</span> <span class="hljs-keyword">project</span><br># Run `docker build --no-cache .` to update <span class="hljs-keyword">dependencies</span><br>RUN apk add --no-cache git<br>RUN go get github.com<span class="hljs-regexp">/golang/</span>dep<span class="hljs-regexp">/cmd/</span>dep<br><br># List <span class="hljs-keyword">project</span> <span class="hljs-keyword">dependencies</span> with Gopkg.toml and Gopkg.lock<br># These layers are only re-built when Gopkg files are updated<br><span class="hljs-keyword">COPY</span> Gopkg.lock Gopkg.toml <span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/project/</span><br>WORKDIR <span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/project/</span><br># Install library <span class="hljs-keyword">dependencies</span><br>RUN dep ensure -vendor-only<br><br># <span class="hljs-keyword">Copy</span> the entire <span class="hljs-keyword">project</span> and build it<br># <span class="hljs-keyword">This</span> layer is rebuilt when a <span class="hljs-keyword">file</span> changes in the <span class="hljs-keyword">project</span> directory<br><span class="hljs-keyword">COPY</span> . <span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/project/</span><br>RUN go build -o <span class="hljs-regexp">/bin/</span><span class="hljs-keyword">project</span><br><br># <span class="hljs-keyword">This</span> results in a single layer image<br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build <span class="hljs-regexp">/bin/</span><span class="hljs-keyword">project</span> <span class="hljs-regexp">/bin/</span><span class="hljs-keyword">project</span><br>ENTRYPOINT [<span class="hljs-string">&quot;/bin/project&quot;</span>]<br>CMD [<span class="hljs-string">&quot;--help&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="不要安装不必要的包"><a href="#不要安装不必要的包" class="headerlink" title="不要安装不必要的包"></a>不要安装不必要的包</h4><p>为了降低复杂性，依赖性，文件大小和构建时间，请避免安装额外的或不必要的软件包，因为它们可能“很好”。例如，您不需要在数据库映像中包含文本编辑器。</p><h4 id="解耦应用程序"><a href="#解耦应用程序" class="headerlink" title="解耦应用程序"></a>解耦应用程序</h4><p>每个容器应该只有一个关注点。将应用程序解耦到多个容器可以更容易地水平伸缩和重用容器。例如，web应用程序堆栈可能由三个独立的容器组成，每个容器都有自己独特的映像，以解耦的方式管理web应用程序、数据库和内存缓存。</p><p>将每个容器限制为一个进程是一个很好的经验法则，但它不是一个硬性规则。 例如，不仅可以使用init进程生成容器，而且某些程序可能会自行生成其他进程。 例如，Celery可以生成多个工作进程，Apache可以为每个请求创建一个进程。</p><p>使用你最好的判断来保持容器尽可能的干净和模块化。如果容器彼此依赖，可以使用Docker容器网络来确保这些容器能够通信。</p><h4 id="减少图层的数量"><a href="#减少图层的数量" class="headerlink" title="减少图层的数量"></a>减少图层的数量</h4><p>在旧版本的Docker中，最大限度地减少图像中的图层数量以确保它们具有高性能非常重要。添加了以下特性来减少这种限制:</p><ul><li>只用RUN,COPY,ADD指令会创建层，其他指令创建临时中间层，并不增加构建的大小。</li><li>在可能的情况下，使用多阶段构建，并仅将所需的工件复制到最终图像中。这允许您在中间构建阶段中包含工具和调试信息，而不会增加最终图像的大小</li></ul><h4 id="多行参数排序"><a href="#多行参数排序" class="headerlink" title="多行参数排序"></a>多行参数排序</h4><p>只要有可能，通过按字母顺序排序多行参数来缓解以后的更改。这有助于避免重复包并使列表更容易更新。这也使PR更容易阅读和审查。 在反斜杠（\）之前添加空格也有帮助。</p><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y \<br>  bzr \<br>  cvs \<br>  git \<br>  mercurial \<br>  subversion<br></code></pre></td></tr></table></figure><h4 id="缓存利用"><a href="#缓存利用" class="headerlink" title="缓存利用"></a>缓存利用</h4><p>构建映像时，Docker会逐步执行Dockerfile中的指令，按指定的顺序执行每个指令。 在检查每条指令时，Docker会在其缓存中查找可以重用的现有映像，而不是创建新的（重复）映像。</p><p>如果你不想使用缓存，可以在docker build命令中使用<code>--no-cache=true</code>选项，然而，如果你让Docker使用缓存，理解什么时候使用，什么时候不能，使用一个匹配的镜像将非常重要，Docker遵循的基本规则概述如下：</p><ul><li>从已在缓存中的父镜像开始，接下来的指令将对比所有的子镜像看是否有一个使用相同的指令构建而成，如果没有，缓存则是无效的。</li><li>在大多数情况下，只需将Dockerfile中的指令与其中一个子映像进行比较就足够了。然而，某些指示需要更多的检查和解释。</li><li>对于ADD和COPY指令，将检查映像中文件的内容，并为每个文件计算校验和。 在这些校验和中不考虑文件的最后修改时间和最后访问时间。 在高速缓存查找期间，将校验和与现有映像中的校验和进行比较。 如果文件中的任何内容（例如内容和元数据）发生了任何更改，则缓存将失效。</li><li>除了ADD和COPY命令之外，高速缓存检查不会查看容器中的文件以确定高速缓存匹配。 例如，在处理RUN apt-get -y update命令时，不检查容器中更新的文件以确定是否存在缓存命中。 在这种情况下，只需使用命令字符串本身来查找匹配项。</li></ul><p>一旦缓存无效，Dockerfile命令将产生新的镜像而不使用缓存。</p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><code>FROM &lt;image&gt; [AS &lt;name&gt;]</code></p><p>或者</p><p><code>FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></p><p>或者</p><p><code>FROM &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code></p><ul><li>FROM指令初始化新的构建阶段并为后续指令设置基本映像。因此，有效的Dockerfile必须以FROM指令开头.</li><li>FROM可以出现多次在同一个Dockerfile文件中，为了创建多个镜像，或者使用一个作为另一个镜像的依赖，只要在每个新的FROM执行之前记录上一个镜像的ID。每个FROM指令都会清空之前命令创建的任何状态。</li><li>可选的，每个FROM指令都可以通过<code>AS name</code>提供一个名词,该名词可以在子FROM指令和COPY –from&lt;name|index&gt;指令中指待该镜像。</li><li>tag和digest值是可选的，如果省略他们，将使用latest版本，如果未找到将会抛出异常。 尽可能的使用官方镜像作为基础镜像。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM golang:1.10.3 as builder<br>WORKDIR /app/<br>RUN <span class="hljs-built_in">mkdir</span> -p src/github.com \ <br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p src/golang.org \<br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p src/gopkg.in \<br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p src/qiniupkg.com \<br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p src/google.golang.org \<br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p src/go4.org<br></code></pre></td></tr></table></figure><p>了解ARG和FROM如何互动： FROM指令支持在第一个FROM之前通过任意ARG指令声明变量 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span>  CODE_VERSION=latest<br><span class="hljs-keyword">FROM</span> base:$&#123;CODE_VERSION&#125;<br><span class="hljs-keyword">CMD</span><span class="language-bash">  /code/run-app</span><br><br><span class="hljs-keyword">FROM</span> extras:$&#123;CODE_VERSION&#125;<br><span class="hljs-keyword">CMD</span><span class="language-bash">  /code/run-extras</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>你可以为你的镜像添加labels，用来组织镜像，记录证书信息，或者其他原因，对应每个label，增加以LABEL开头的行，和一个或者多个键值对。下面的示例中展示的是不同形式的：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"># <span class="hljs-keyword">Set</span> <span class="hljs-keyword">one</span> or <span class="hljs-keyword">more</span> individual labels<br><span class="hljs-keyword">LABEL</span> com.example.<span class="hljs-keyword">version</span>=<span class="hljs-string">&quot;0.0.1-beta&quot;</span><br><span class="hljs-keyword">LABEL</span> vendor1=<span class="hljs-string">&quot;ACME Incorporated&quot;</span><br><span class="hljs-keyword">LABEL</span> vendor2=ZENITH\ Incorporated<br><span class="hljs-keyword">LABEL</span> com.example.release-date=<span class="hljs-string">&quot;2015-02-12&quot;</span><br><span class="hljs-keyword">LABEL</span> com.example.<span class="hljs-keyword">version</span>.is-production=<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>上面的也可以写成如下形式：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># Set multiple labels at once, using line-continuation characters to break long lines</span><br>LABEL vendor=ACME<span class="hljs-string">\</span> Incorporated <span class="hljs-string">\</span><br>      com.example.<span class="hljs-keyword">is</span>-beta= <span class="hljs-string">\</span><br>      com.example.<span class="hljs-keyword">is</span>-production=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">\</span><br>      com.example.version=<span class="hljs-string">&quot;0.0.1-beta&quot;</span> <span class="hljs-string">\</span><br>      com.example.release-date=<span class="hljs-string">&quot;2015-02-12&quot;</span><br></code></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><ul><li>RUN</li><li>RUN [“executable”, “param1”, “param2”]</li></ul><p>RUN指令将执行任何命令在当前镜像的一个新层上并提交结果。提交后的镜像将会在下一步中使用。</p><p>在使用反斜杠分隔的多行上拆分长或复杂的RUN语句，以使Dockerfile更具可读性，可理解性和可维护性。</p><p><code>RUN apt-get update &amp;&amp; apt-get install -y</code>这些命令不要分开，</p><p>示例：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">RUN apt-get update &amp;&amp; apt-get install -y <span class="hljs-string">\</span><br>    aufs-tools <span class="hljs-string">\</span><br>    automake <span class="hljs-string">\</span><br>    build-essential <span class="hljs-string">\</span><br>    curl <span class="hljs-string">\</span><br>    dpkg-sig <span class="hljs-string">\</span><br>    libcap-dev <span class="hljs-string">\</span><br>    libsqlite3-dev <span class="hljs-string">\</span><br>    mercurial <span class="hljs-string">\</span><br>    reprepro <span class="hljs-string">\</span><br>    ruby1.<span class="hljs-number">9.1</span> <span class="hljs-string">\</span><br>    ruby1.<span class="hljs-number">9.1</span>-dev <span class="hljs-string">\</span><br>    s3cmd=<span class="hljs-number">1.1</span>.* <span class="hljs-string">\</span><br> &amp;&amp; rm -rf <span class="hljs-regexp">/var/lib/apt/lists/</span>*<br><br></code></pre></td></tr></table></figure><p>上面的这个指令是建议这样使用的，最后的执行用于清除安装过程中的缓存。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></p><p><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code></p><p><code>CMD command param1 param2</code></p><p><strong>一个Dockerfile文件中，只能有一个CMD指令，如果出现多个，只有最后一个起作用。</strong></p><p>CMD的主要目的是为执行容器提供默认值。 这些默认值可以包含可执行文件，</p><p>也可以省略可执行文件，在这种情况下，您还必须指定ENTRYPOINT指令。</p><p>如果CMD用于为ENTRYPOINT指令提供默认参数，则应使用JSON数组格式指定CMD和ENTRYPOINT指令。exec表单被解析为JSON数组，这意味着您必须使用双引号（“）来围绕单词而不是单引号（’）。</p><p>CMD指令应该被用于运行被镜像包含的软件，并使用提供的参数。CMD指令应尽可能的使用CMD [“executable”, “params1”,”params2”…].因此，如果镜像是一个服务，比如Apache，应这样运行CMD [“apache2”, “-DFOREGROUND”].事实上，这种形式的指令被建议使用在以服务为基础的镜像上。</p><p>大多数情况，CMD应该提供一个交互式的shell。例如bash.python.perl.示例： <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>, <code>CMD [&quot;python&quot;]</code>,或者<code>CMD [&quot;php&quot; &quot;-a&quot;]</code>.以这种形式的指令，意味着当你执行如这样的命令时<code>docker run -it python</code>,你将进入一个可用的shell里面，CMD指令在和ENTRYPOINT指令结合使用时，将很少使用<code>CMD [&quot;param&quot;, &quot;param&quot;]</code>这种形式，除非你和客户都很熟悉ENTRYPOINT是如何工作的。</p><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> busybox as <span class="hljs-keyword">final</span><br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=builder <span class="hljs-regexp">/app/</span>src <span class="hljs-regexp">/opt/</span>app/src<br>EXPOSE <span class="hljs-number">8080</span><br>WORKDIR  <span class="hljs-regexp">/opt/</span>app/<br>CMD [<span class="hljs-string">&quot;./server&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></p><p>EXPOSE指令通知Docker容器在运行时侦听指定的网络端口。 您可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认为TCP。EXPOSE指令实际上不会发布端口。 它在构建映像的人和运行容器的人之间起到一种文档的作用，关于哪些端口要发布。要在运行容器时实际发布端口，请在docker run上使用-p标志发布和映射一个或多个端口，或使用-P标志发布所有公开的端口并将它们映射到高阶端口。默认情况下，EXPOSE假定为TCP。 您还可以指定UDP：</p><p><code>EXPOSE 80/udp</code></p><p>要同时在TCP和UDP上公开，需要包含两行:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> <span class="hljs-number">80</span>/tcp<br><span class="hljs-attribute">EXPOSE</span> <span class="hljs-number">80</span>/udp<br></code></pre></td></tr></table></figure><p>在这种情况下，如果将-P与docker run一起使用，则端口将为TCP公开一次，对UDP公开一次。 请记住，-P在主机上使用短暂的高阶主机端口，因此TCP和UDP的端口不同。</p><p>无论EXPOSE设置如何，您都可以使用-p标志在运行时覆盖它们。 例如: <code>docker run -p 80:80/tcp -p 80:80/udp ...</code></p><p>要在主机系统上设置端口重定向，请参阅使用-P标志。 docker network命令支持创建用于容器之间通信的网络，而无需公开或发布特定端口，因为连接到网络的容器可以通过任何端口相互通信。</p><p>EXPOSE指令指示容器侦听连接的端口。 因此，您应该为您的应用程序使用通用的传统端口。 例如，包含Apache Web服务器的映像将使用EXPOSE 80，而包含MongoDB的映像将使用EXPOSE 27017等.</p><p>对于外部访问，您的用户可以使用标志执行docker run，该标志指示如何将指定端口映射到他们选择的端口。 对于容器链接，Docker为从收件人容器返回源的路径提供环境变量.</p><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> busybox as <span class="hljs-keyword">final</span><br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=builder <span class="hljs-regexp">/app/</span>src <span class="hljs-regexp">/opt/</span>app/src<br>EXPOSE <span class="hljs-number">8080</span><br>WORKDIR  <span class="hljs-regexp">/opt/</span>app/<br>CMD [<span class="hljs-string">&quot;./server&quot;</span>]<br></code></pre></td></tr></table></figure><p>这样我们在<code>docker ps</code> 的时候就会发现</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">44af1f00f971</span>        server_number1:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>    <span class="hljs-string">&quot;./server&quot;</span>               <span class="hljs-number">3</span> hours ago         Up <span class="hljs-number">14</span> seconds      <span class="hljs-number">8080</span>/tcp                             server_number1_1<br><span class="hljs-attribute">b372192ef894</span>        server_number2:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>     <span class="hljs-string">&quot;./server&quot;</span>             <span class="hljs-number">3</span> hours ago         Up <span class="hljs-number">15</span> seconds      <span class="hljs-number">8080</span>/tcp                             server_number2_1<br><span class="hljs-attribute">9ffa14236ab1</span>        nginx:latest        <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   <span class="hljs-number">3</span> hours ago         Up <span class="hljs-number">21</span> seconds       <span class="hljs-number">0.0.0.0:80</span>-&gt;<span class="hljs-number">80</span>/tcp                   server_nginx_1<br><span class="hljs-attribute">7b73c43a97d3</span>        redis:<span class="hljs-number">3</span>.<span class="hljs-number">2</span>           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">3</span> hours ago         Up <span class="hljs-number">21</span> seconds       <span class="hljs-number">0.0.0.0:6379</span>-&gt;<span class="hljs-number">6379</span>/tcp               server_redis_1<br><span class="hljs-attribute">8df25db59837</span>        mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span>           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">4</span> hours ago         Up <span class="hljs-number">21</span> seconds       <span class="hljs-number">33060</span>/tcp, <span class="hljs-number">0.0.0.0:33306</span>-&gt;<span class="hljs-number">3306</span>/tcp   server_mysql_1<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> ...<br></code></pre></td></tr></table></figure><p>ENV指令将环境变量设置为值。 此值将在构建阶段中的所有后续指令的环境中，并且也可以在许多内联替换。</p><p>ENV指令有两种形式。 第一种形式ENV ，将单个变量设置为一个值。 第一个空格后面的整个字符串将被视为 - 包括空格字符。 该值将针对其他环境变量进行解释，因此如果未对其进行转义，则将删除引号字符。</p><p>第二种形式ENV &#x3D; …允许一次设置多个变量。 请注意，第二种形式在语法中使用等号（&#x3D;），而第一种形式则不然。 与命令行解析一样，引号和反斜杠可用于在值内包含空格。</p><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> golang:1.10.3 as builder<br><span class="hljs-built_in">RUN</span> yum install -y gcc \<br>    &amp;&amp; yum install -y gcc-c++ kernel-devel make<br>ENV GOPATH /go<br>ENV PATH <span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$GOPATH</span>/bin<br></code></pre></td></tr></table></figure><p>为了使新软件更易于运行，您可以使用ENV更新容器安装的软件的PATH环境变量。例如： <code>ENV PATH /usr/local/nginx/bin:$PATH</code>确保<code>CMD [&quot;nginx&quot;]</code>正常运行。</p><p>ENV指令对于提供特定于您希望容纳的服务的必需环境变量也很有用，例如Postgres的PGDATA。 最后，ENV还可用于设置常用版本号，以便更容易维护版本迭代，如以下示例所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ENV PG_MAJOR <span class="hljs-number">9.3</span><br>ENV PG_VERSION <span class="hljs-number">9.3</span><span class="hljs-number">.4</span><br>RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …<br>ENV <span class="hljs-type">PATH</span> /usr/<span class="hljs-keyword">local</span>/postgres-$PG_MAJOR/bin:$<span class="hljs-type">PATH</span><br></code></pre></td></tr></table></figure><p>类似于在程序中使用常量变量（与硬编码值相反），此方法允许您更改单个ENV指令以自动神奇地修改容器中的软件版本。</p><p>每条ENV线都会创建一个新的中间层，就像RUN命令一样。 这意味着即使您在将来的图层中取消设置环境变量，它仍然会在此图层中保留，并且可以转储其值。 您可以通过创建如下所示的Dockerfile来测试它，然后构建它。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine<br><span class="hljs-keyword">ENV</span> ADMIN_USER=<span class="hljs-string">&quot;mark&quot;</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$ADMIN_USER</span> &gt; ./mark</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">unset</span> ADMIN_USER</span><br></code></pre></td></tr></table></figure><p><code>$ docker run --rm test sh -c &#39;echo $ADMIN_USER&#39;</code>一样会输出mark</p><p>要防止这种情况，并且实际上取消设置环境变量，请使用带有shell命令的RUN命令，在单个图层中设置，使用和取消设置变量all。 您可以将命令与; 要么 ＆＆。 如果您使用第二种方法，并且其中一个命令失败，则docker构建也会失败。 这通常是一个好主意。 使用\作为Linux Dockerfiles的行继续符可以提高可读性。 您还可以将所有命令放入shell脚本中，并使用RUN命令运行该shell脚本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">export</span> ADMIN_USER=<span class="hljs-string">&quot;mark&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$ADMIN_USER</span> &gt; ./mark \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">unset</span> ADMIN_USER</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> sh</span><br></code></pre></td></tr></table></figure><p><code>docker run --rm test sh -c &#39;echo $ADMIN_USER&#39;</code>不会输出mark</p><h3 id="ADD-or-COPY"><a href="#ADD-or-COPY" class="headerlink" title="ADD or COPY"></a>ADD or COPY</h3><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><ul><li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li><li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li></ul><p><code>--chown</code>功能仅用于Dockerfile构建linux容器.在windows容器上无效。</p><p>ADD指令从复制新文件，目录或远程文件URL，并将它们添加到路径的镜像文件系统中。 每个可能包含通配符，匹配将使用Go的filepath.Match规则完成。 例如：</p><p>是绝对路径，或相对于WORKDIR的路径，源将在目标容器中复制到该路径中。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">ADD</span> test relativeDir/          # adds <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-keyword">to</span> `WORKDIR`/relativeDir/<br><span class="hljs-built_in">ADD</span> test /absoluteDir/         # adds <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-keyword">to</span> /absoluteDir/<br></code></pre></td></tr></table></figure><p>添加包含特殊字符（例如[和]）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。 例如，要添加名为arr [0] .txt的文件，请使用以下命令：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ADD arr[[]<span class="hljs-number">0</span>].txt <span class="hljs-regexp">/mydir/</span>    # <span class="hljs-keyword">copy</span> a <span class="hljs-keyword">file</span> named <span class="hljs-string">&quot;arr[0].txt&quot;</span> to <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure><p>所有新文件和目录都是使用UID和GID为0创建的，除非可选的–chown标志指定给定用户名，组名或UID &#x2F; GID组合以请求添加内容的特定所有权。 –chown标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。 提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则容器的根文件系统&#x2F; etc &#x2F; passwd和&#x2F; etc &#x2F; group文件将分别用于执行从名称到整数UID或GID的转换。 以下示例显示了–chown标志的有效定义：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">ADD</span> <span class="hljs-attribute">--chown</span>=55:mygroup files* /somedir/<br><span class="hljs-built_in">ADD</span> <span class="hljs-attribute">--chown</span>=bin files* /somedir/<br><span class="hljs-built_in">ADD</span> <span class="hljs-attribute">--chown</span>=1 files* /somedir/<br><span class="hljs-built_in">ADD</span> <span class="hljs-attribute">--chown</span>=10:11 files* /somedir/<br></code></pre></td></tr></table></figure><p>如果容器根文件系统不包含&#x2F; etc &#x2F; passwd或&#x2F; etc &#x2F; group文件，并且在–chown标志中使用了用户名或组名，则构建将在ADD操作上失败。 使用数字ID不需要查找，也不依赖于容器根文件系统内容.</p><p>在是远程文件URL的情况下，目标将具有600的权限。如果正在检索的远程文件具有HTTP Last-Modified标头，则该标头的时间戳将用于设置目标上的mtime 文件。 但是，与ADD期间处理的任何其他文件一样，mtime将不包含在确定文件是否已更改且应更新缓存中。</p><p>ADD遵守以下规则：</p><ul><li>路径必须位于构建的上下文中; 你不能添加..&#x2F;something &#x2F; something，因为docker构建的第一步是将上下文目录（和子目录）发送到docker守护进程。</li><li>如果是URL且不以尾部斜杠结尾，则从URL下载文件并将其复制到。</li><li>如果是URL并且以尾部斜杠结尾，则从URL推断文件名，并将文件下载到<code>&lt;dest&gt; /&lt;filename&gt;</code>。 例如，<code>ADD http://example.com/foobar /</code>将创建文件<code>/foobar</code>。 URL必须具有非常重要的路径，以便在这种情况下可以发现适当的文件名（<a href="https://link.juejin.cn/?target=http://example.com%25E5%25B0%2586%25E4%25B8%258D%25E8%25B5%25B7%25E4%25BD%259C%25E7%2594%25A8%25EF%25BC%2589" title="http://example.com%E5%B0%86%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%89">example.com将不起作用）</a></li><li>如果是目录，则复制目录的全部内容，包括文件系统元数据。不复制目录本身，只复制其内容。</li><li>如果是可识别的压缩格式（identity，gzip，bzip2或xz）的本地tar存档，则将其解压缩为目录。 远程URL中的资源不会被解压缩。 复制或解压缩目录时，它与tar -x具有相同的行为，结果是：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.无论在目的地路径上存在什么，<br><span class="hljs-attribute">2</span>.源树的内容，在逐个文件的基础上解决了有利于“<span class="hljs-number">2</span>.”的冲突。<br></code></pre></td></tr></table></figure><ul><li>如果是任何其他类型的文件，则将其与元数据一起单独复制。 在这种情况下，如果以尾部斜杠&#x2F;结尾，则将其视为目录，的内容将写入 &#x2F; base（）。</li><li>如果直接或由于使用通配符指定了多个资源，则必须是目录，并且必须以斜杠&#x2F;结尾。</li><li>如果不以尾部斜杠结束，则将其视为常规文件，的内容将写入。</li><li>如果不存在，则会在其路径中创建所有缺少的目录。</li></ul><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li></ul><p><code>--chown</code>功能仅用于Dockerfile构建linux容器.在windows容器上无效。</p><p>COPY指令从复制新文件或目录，并将它们添加到路径的容器的文件系统中。</p><p>可以指定多个资源，但文件和目录的路径将被解释为相对于构建上下文的源。</p><p>每个可能包含通配符，匹配将使用Go的filepath.Match规则完成。 例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">COPY</span> hom* /mydir/        # adds <span class="hljs-keyword">all</span> files starting <span class="hljs-keyword">with</span> &quot;hom&quot;<br><span class="hljs-keyword">COPY</span> hom?.txt /mydir/    # ? <span class="hljs-keyword">is</span> replaced <span class="hljs-keyword">with</span> <span class="hljs-keyword">any</span> single <span class="hljs-type">character</span>, e.g., &quot;home.txt&quot;<br></code></pre></td></tr></table></figure><p>是绝对路径，或相对于WORKDIR的路径，源将在目标容器中复制到该路径中。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> test relativeDir<span class="hljs-regexp">/   # adds &quot;test&quot; to `WORKDIR`/</span>relativeDir/<br><span class="hljs-keyword">COPY</span> test <span class="hljs-regexp">/absoluteDir/</span>  # adds <span class="hljs-string">&quot;test&quot;</span> to <span class="hljs-regexp">/absoluteDir/</span><br></code></pre></td></tr></table></figure><p>复制包含特殊字符（例如[和]）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。 例如，要复制名为arr [0] .txt的文件，请使用以下命令：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> arr[[]<span class="hljs-number">0</span>].txt <span class="hljs-regexp">/mydir/</span>    # <span class="hljs-keyword">copy</span> a <span class="hljs-keyword">file</span> named <span class="hljs-string">&quot;arr[0].txt&quot;</span> to <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure><p>除非可选的–chown标志指定给定用户名，组名或UID &#x2F; GID组合以请求复制内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。 –chown标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。 提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则容器的根文件系统&#x2F; etc &#x2F; passwd和&#x2F; etc &#x2F; group文件将分别用于执行从名称到整数UID或GID的转换。 以下示例显示了–chown标志的有效定义：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=55:mygroup files* /somedir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=bin files* /somedir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=1 files* /somedir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=10:11 files* /somedir/</span><br></code></pre></td></tr></table></figure><p>如果容器根文件系统不包含&#x2F; etc &#x2F; passwd或&#x2F; etc &#x2F; group文件，并且在–chown标志中使用了用户名或组名，则构建将在COPY操作上失败。 使用数字ID不需要查找，也不依赖于容器根文件系统内容。</p><p>可选地，COPY接受一个标志–from &#x3D; &lt;name | index&gt;，可用于将源位置设置为先前的构建阶段（使用FROM .. AS 创建），而不是由发送的构建上下文 用户。 该标志还接受为使用FROM指令启动的所有先前构建阶段分配的数字索引。 如果找不到具有指定名称的构建阶段，则尝试使用具有相同名称的图像。</p><p>COPY遵守以下规则：</p><ul><li>路径必须位于构建的上下文中; 你不能COPY ..&#x2F;something &#x2F; something，因为docker构建的第一步是将上下文目录（和子目录）发送到docker守护进程。</li><li>如果是目录，则复制目录的全部内容，包括文件系统元数据。不复制目录本身，只复制其内容。</li><li>如果是任何其他类型的文件，则将其与元数据一起单独复制。 在这种情况下，如果以尾部斜杠&#x2F;结尾，则将其视为目录，的内容将写入 &#x2F; base（）。</li><li>如果直接或由于使用通配符指定了多个资源，则必须是目录，并且必须以斜杠&#x2F;结尾。</li><li>如果不以尾部斜杠结束，则将其视为常规文件，的内容将写入。</li><li>如果不存在，则会在其路径中创建所有缺少的目录。</li></ul><p>尽管ADD和COPY在功能上相似，但一般来说，COPY是优选的。 那是因为它比ADD更透明。 COPY仅支持将本地文件基本复制到容器中，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。因此，ADD的最佳用途是将本地tar文件自动提取到图像中，如<code>ADD rootfs.tar.xz /</code>中所示.</p><p>如果在Dockerfile中有多个步骤使用不同的文件，请针对每个文件，单独执行COPY指令，而不是放在一起执行COPY,这确保了每一步构建的缓存在当前步骤使用，如果特定的文件改变了。 示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> requirements.txt <span class="hljs-regexp">/tmp/</span><br>RUN pip install --requirement <span class="hljs-regexp">/tmp/</span>requirements.txt<br><span class="hljs-keyword">COPY</span> . <span class="hljs-regexp">/tmp/</span><br></code></pre></td></tr></table></figure><p>与放置在COPY之前相比，RUN步骤的缓存失效次数更少。 由于图像大小很重要，因此强烈建议不要使用ADD从远程URL获取包。 你应该使用curl或wget代替。 这样，您可以删除提取后不再需要的文件，也不必在图像中添加其他图层。 例如，你应该避免做以下事情：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ADD http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/big.tar.xz /u</span>sr<span class="hljs-regexp">/src/</span>things/<br>RUN tar -xJf <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/things/</span>big.tar.xz -C <span class="hljs-regexp">/usr/</span>src/things<br>RUN make -C <span class="hljs-regexp">/usr/</span>src/things all<br></code></pre></td></tr></table></figure><p>替代为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">RUN mkdir -p <span class="hljs-regexp">/usr/</span>src/things \<br>    &amp;&amp; curl -SL http:<span class="hljs-regexp">//</span>example.com/big.tar.xz \<br>    | tar -xJC <span class="hljs-regexp">/usr/</span>src/things \<br>    &amp;&amp; make -C <span class="hljs-regexp">/usr/</span>src/things all<br></code></pre></td></tr></table></figure><p>对于不需要ADD的tar自动提取功能的其他项目（文件，目录），应始终使用COPY。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><ul><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec form, preferred)</li><li><code>ENTRYPOINT command param1 param2</code></li></ul><p>ENTRYPOINT允许您配置将作为可执行文件运行的容器。 例如，以下将使用其默认内容启动nginx，侦听端口80： <code>docker run -i -t --rm -p 80:80 nginx</code></p><p>exec形式的ENTRYPOINT中的命令行参数将会追加到<code>docker run &lt;image&gt;</code>所有元素的后面。并且会覆盖CMD指令指定的参数。这允许将参数传递给入口点。 <code>docker run &lt;image&gt; -d</code>会将-d参数传递给入口点。 您可以使用<code>docker run --entrypoint</code>标志覆盖ENTRYPOINT指令。</p><p>shell表单可以防止使用任何CMD或run命令行参数，但缺点是<code>ENTRYPOINT</code>将作为<code>/bin/sh -c</code>的子命令启动，它不传递信号。 这意味着可执行文件不是容器的<code>PID 1</code> - 并且不会收到Unix信号 - 因此您的可执行文件不会从<code>docker stop &lt;container&gt;</code>接收<code>SIGTERM</code>。</p><p>Dockerfile文件中只有最后一个ENTRYPOINT指令会起作用.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>你可以使用exec 形式的ENTRYPOINT来设置相对稳定的默认的命令和参数，并使用任意形式的CMD指令来设置额外的默认的可能会变化的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">FROM</span> ubuntu<br>ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;-b&quot;</span>]</span><br>CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;-c&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>当你运行容器的时候，可以发现top是唯一的进程 <code>docker run -it --rm --name test top -H</code></p><p>为了未来测试结果，你可使用<code>docker exec</code></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ docker exec -it test ps aux<br>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root        <span class="hljs-number"> 1 </span> 2.6  0.1 <span class="hljs-number"> 19752 </span><span class="hljs-number"> 2352 </span>?        Ss+  08:24   0:00 top -b -H<br>root        <span class="hljs-number"> 7 </span> 0.0  0.1 <span class="hljs-number"> 15572 </span><span class="hljs-number"> 2164 </span>?        R+   08:25   0:00 ps aux<br></code></pre></td></tr></table></figure><p>并且您可以优雅地请求停止<code>top</code>使用<code>docker stop test</code>。</p><p>下面的示例展示了使用<code>ENTRYPOINT</code>来运行Apache在前端</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> debian:stable<br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y --force-yes apache2<br>EXPOSE 80 443<br>VOLUME [<span class="hljs-string">&quot;/var/www&quot;</span>, <span class="hljs-string">&quot;/var/log/apache2&quot;</span>, <span class="hljs-string">&quot;/etc/apache2&quot;</span>]<br>ENTRYPOINT [<span class="hljs-string">&quot;/usr/sbin/apache2ctl&quot;</span>, <span class="hljs-string">&quot;-D&quot;</span>, <span class="hljs-string">&quot;FOREGROUND&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>可为ENTRYPOINT指定一个字符串,他将在<code>/bin/sh -c</code>中执行，这种形式使用shell处理替换环境变量，并会忽略CMD或者docker run 命令行参数。为了正确有效的执行<code>docker stop</code>,需要记住以<code>exec</code>开头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">FROM</span> ubuntu<br>ENTRYPOINT exec <span class="hljs-attribute">top</span> -<span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>当运行这个镜像的时候，可以看到<code>PID 1</code>的进程</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">$</span> <span class="hljs-variable">docker</span> <span class="hljs-variable">run</span> <span class="hljs-operator">-</span><span class="hljs-variable">it</span> <span class="hljs-operator">--</span><span class="hljs-variable">rm</span> <span class="hljs-operator">--</span><span class="hljs-variable">name</span> <span class="hljs-variable">test</span> <span class="hljs-variable">top</span><br><span class="hljs-variable">Mem</span><span class="hljs-operator">:</span> <span class="hljs-number">1704520</span><span class="hljs-built_in">K</span> <span class="hljs-variable">used</span><span class="hljs-operator">,</span> <span class="hljs-number">352148</span><span class="hljs-built_in">K</span> <span class="hljs-variable">free</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span> <span class="hljs-variable">shrd</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span> <span class="hljs-variable">buff</span><span class="hljs-operator">,</span> <span class="hljs-number">140368121167873</span><span class="hljs-built_in">K</span> <span class="hljs-variable">cached</span><br><span class="hljs-variable">CPU</span><span class="hljs-operator">:</span>   <span class="hljs-number">5</span><span class="hljs-operator">%</span> <span class="hljs-variable">usr</span>   <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">sys</span>   <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">nic</span>  <span class="hljs-number">94</span><span class="hljs-operator">%</span> <span class="hljs-variable">idle</span>   <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">io</span>   <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">irq</span>   <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">sirq</span><br><span class="hljs-variable">Load</span> <span class="hljs-variable">average</span><span class="hljs-operator">:</span> <span class="hljs-number">0.08</span> <span class="hljs-number">0.03</span> <span class="hljs-number">0.05</span> <span class="hljs-number">2</span><span class="hljs-operator">/</span><span class="hljs-number">98</span> <span class="hljs-number">6</span><br>  <span class="hljs-variable">PID</span>  <span class="hljs-variable">PPID</span> <span class="hljs-variable">USER</span>     <span class="hljs-variable">STAT</span>   <span class="hljs-variable">VSZ</span> <span class="hljs-operator">%</span><span class="hljs-variable">VSZ</span> <span class="hljs-operator">%</span><span class="hljs-variable">CPU</span> <span class="hljs-variable">COMMAND</span><br>    <span class="hljs-number">1</span>     <span class="hljs-number">0</span> <span class="hljs-variable">root</span>     <span class="hljs-variable">R</span>     <span class="hljs-number">3164</span>   <span class="hljs-number">0</span><span class="hljs-operator">%</span>   <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">top</span> <span class="hljs-operator">-</span><span class="hljs-variable">b</span><br></code></pre></td></tr></table></figure><p>当执行docker stop命令时，可正常退出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ /usr/bin/time docker stop test<br><span class="hljs-keyword">test</span><br><span class="hljs-keyword"></span>real0m 0.20s<br>user0m 0.02s<br>sys0m 0.04s<br></code></pre></td></tr></table></figure><p>如果你忘记以exec开头，如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">FROM</span> ubuntu<br>ENTRYPOINT <span class="hljs-attribute">top</span> -<span class="hljs-selector-tag">b</span><br>CMD <span class="hljs-attr">--ignored-param1</span><br><br></code></pre></td></tr></table></figure><p>运行；</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ docker run -it --name test top --ignored-param2<br>Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached<br>CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq<br>Load average: 0.01 0.02 0.05 2/101 7<br>  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND<br>   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 0 </span>root     S    <span class="hljs-number"> 3168 </span>  0%   0% /bin/sh -c top -b cmd cmd2<br>   <span class="hljs-number"> 7 </span>   <span class="hljs-number"> 1 </span>root     R    <span class="hljs-number"> 3164 </span>  0%   0% top -b<br><br></code></pre></td></tr></table></figure><p>可以看到top输出表明ENTRYPOINT指令并未作为PID1的进程运行。 这个时候运行docker stop，容器不会正常退出，stop指令会强制发出一个<code>SIGKILL</code>信号在数分钟以后。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ docker exec -it test ps aux<br>PID   USER     COMMAND<br>    1 root     /bin/sh -c top -b cmd cmd2<br>    7 root     top -b<br>    8 root     ps aux<br>$ /usr/bin/time docker stop test<br><span class="hljs-keyword">test</span><br><span class="hljs-keyword"></span>real0m 10.19s<br>user0m 0.04s<br>sys0m 0.03s<br></code></pre></td></tr></table></figure><h4 id="理解CMD和ENTRYPOINT指令如何整合"><a href="#理解CMD和ENTRYPOINT指令如何整合" class="headerlink" title="理解CMD和ENTRYPOINT指令如何整合"></a>理解CMD和ENTRYPOINT指令如何整合</h4><p>这两个指令都定义了当运行一个容器的时候，应运行什么命令，在合同使用时需遵守以下规则：</p><ul><li>Dockerfile应至少指定一个CMD或ENTRYPOINT命令。</li><li>使用容器作为可执行文件时，应定义ENTRYPOINT。</li><li>CMD应该用作为ENTRYPOINT命令定义默认参数或在容器中执行ad-hoc命令的方法。</li><li>使用备用参数运行容器时，将覆盖CMD。</li></ul><p>下表显示了针对不同ENTRYPOINT &#x2F; CMD组合执行的命令：</p><table><thead><tr><th>null</th><th>No ENTRYPOINT</th><th>ENTRYPOINT exec_entry p1_entry</th><th>ENTRYPOINT [“exec_entry”, “p1_entry”]</th></tr></thead><tbody><tr><td>No CMD</td><td>error, not allowed</td><td>&#x2F;bin&#x2F;sh -c exec_entry p1_entry</td><td>exec_entry p1_entry</td></tr><tr><td>CMD [“exec_cmd”, “p1_cmd”]</td><td>exec_cmd p1_cmd</td><td>&#x2F;bin&#x2F;sh -c exec_entry p1_entry</td><td>exec_entry p1_entry exec_cmd p1_cmd</td></tr><tr><td>CMD [“p1_cmd”, “p2_cmd”]</td><td>p1_cmd p2_cmd</td><td>&#x2F;bin&#x2F;sh -c exec_entry p1_entry</td><td>exec_entry p1_entry p1_cmd p2_cmd</td></tr><tr><td>CMD exec_cmd p1_cmd</td><td>&#x2F;bin&#x2F;sh -c exec_cmd p1_cmd</td><td>&#x2F;bin&#x2F;sh -c exec_entry p1_entry</td><td>exec_entry p1_entry &#x2F;bin&#x2F;sh -c exec_cmd p1_cmd</td></tr></tbody></table><p>如果CMD是从基础镜像中定义，设置ENTRYPOINT将会重置CMD为一个空的值，在这种情况下，CMD需要指定一个值在该镜像定义的时候。</p><p>ENTRYPOINT的最佳使用是用来设置镜像的主命令。允许该映像像该命令一样运行（然后使用CMD作为默认标志）。</p><p>让我们以一个命令行工具s3cmd的镜像的例子开始：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;s3cmd&quot;</span>]</span><br>CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;--help&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>现在可以使用下面的命令运行来展示命令行的帮助信息： <code>docker run s3cmd</code></p><p>或者使用正确的参数来执行命令： <code>docker run s3cmd ls s3://mybucket</code></p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME [&quot;/data&quot;]</code></p><p>VOLUME指令使用指定的名称创建一个挂载点，持有外部挂载的本地主机或者其他容器的卷。其值可以为一个JSON数组，<code>VOLUMN [&quot;/var/log&quot;]</code>,或者一个字符串，例如<code>VOLUMN /var/log</code>或者<code>VOLUMN /var/log /var/db</code>.</p><p>docker run命令使用基本映像中指定位置存在的任何数据初始化新创建的卷。 例如，请考虑以下Dockerfile片段：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /myvol</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span> &gt; /myvol/greeting</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /myvol</span><br></code></pre></td></tr></table></figure><p>此Dockerfile会生成一个映像，该映像会导致docker run在<code>/myvol</code>上创建新的挂载点，并将greeting文件复制到新创建的卷中。</p><p>关于指定卷的说明: 特别注意以下几点关于Dockerfile文件中的卷</p><ul><li>基于windows容器的卷：当使用windows类型的容器时，容器中的卷需是一下中的一种：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 不存在或空目录<br><span class="hljs-bullet">2.</span> C以外的驱动器<br></code></pre></td></tr></table></figure><ul><li>从Dockerfile中更改卷:如果任何构建步骤在声明后更改卷内的数据，那么这些更改将被丢弃。</li><li>JSON形式：该列表被解析为JSON数组。 您必须用双引号（“）而不是单引号（’）括起来。</li><li>主机目录在容器运行时声明：主机目录（mountpoint）本质上是依赖于主机的。 这是为了保持图像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。 因此，您无法从Dockerfile中安装主机目录。 VOLUME指令不支持指定host-dir参数。 您必须在创建或运行容器时指定安装点。</li></ul><p>VOLUME指令应用于公开由docker容器创建的任何数据库存储区域，配置存储或文件&#x2F;文件夹。 强烈建议您将VOLUME用于图像的任何可变和&#x2F;或用户可维修部分。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">&lt;user</span>&gt;[:<span class="hljs-tag">&lt;group&gt;</span>] <span class="hljs-keyword">or</span><br><span class="hljs-keyword">USER</span> <span class="hljs-title">&lt;UID</span>&gt;[:<span class="hljs-tag">&lt;GID&gt;</span>]<br></code></pre></td></tr></table></figure><p>USER指令用于设置用户名或者UID，可选的用户组或者GID.当运行镜像的时候，以便在运行映像时以及Dockerfile中跟随它的任何RUN，CMD和ENTRYPOINT指令时使用。</p><p>在Windows上，如果用户不是内置帐户，则必须先创建用户。 这可以使用作为Dockerfile一部分调用的net user命令来完成。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> microsoft/windowsservercore<br><span class="hljs-comment"># Create Windows user in the container</span><br><span class="hljs-built_in">RUN</span> net<span class="hljs-built_in"> user </span>/<span class="hljs-built_in">add</span> patrick<br><span class="hljs-comment"># Set it for subsequent commands</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">USER </span>patrick<br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR /path/to/workdir</code></p><p>WORKDIR指令为Dockerfile中的任何RUN，CMD，ENTRYPOINT，COPY和ADD指令设置工作目录。如果WORKDIR 目录不存在，即使它未在任何后续Dockerfile指令中使用，也将创建它。WORKDIR指令可以在Dockerfile中多次使用。 如果提供了相对路径，则它将相对于先前WORKDIR指令的路径。 例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><p>此Dockerfile中最终<code>pwd</code>命令的输出为<code>/a/b/c</code>。 WORKDIR指令可以解析先前使用ENV设置的环境变量。 您只能使用Dockerfile中显式设置的环境变量。 例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> DIRPATH /path<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$DIRPATH</span>/<span class="hljs-variable">$DIRNAME</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><p>此Dockerfile中最后一个<code>pwd</code>命令的输出将是<code>/path/$DIRNAME</code> 为了清晰和可靠，您应该始终使用WORKDIR的绝对路径。 此外，您应该使用WORKDIR而不是像<code>RUN CD ...&amp;&amp; do-something</code>，这些指令难以阅读，故障排除和维护。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>在当前Dockerfile构建完成后执行ONBUILD命令。 ONBUILD在从当前图像派生的任何子图像中执行。 将ONBUILD命令视为父Dockerfile为子Dockerfile提供的指令。</p><p>Docker构建在子Dockerfile中的任何命令之前执行ONBUILD命令。</p><p>ONBUILD对于将从给定图像构建的图像非常有用。 例如，您可以使用ONBUILD作为语言堆栈映像，在Dockerfile中构建使用该语言编写的任意用户软件，如Ruby的ONBUILD变体中所示。</p><p>从ONBUILD构建的图像应该获得一个单独的标记，例如：ruby：1.9-onbuild或ruby：2.0-onbuild。</p><p>将ADD或COPY放入ONBUILD时要小心。 如果新构建的上下文缺少正在添加的资源，则“onbuild”映像将发生灾难性故障。 如上所述，添加单独的标记有助于通过允许Dockerfile作者做出选择来缓解这种情况。</p><p><strong>参考资料</strong><br><a href="https://juejin.cn/post/6844903922830671885">Dockerfile的最佳实践-掘金</a><br><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles | Docker Docs</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker三剑客</title>
    <link href="/2022/09/11/Docker-Three-Swordsmen/"/>
    <url>/2022/09/11/Docker-Three-Swordsmen/</url>
    
    <content type="html"><![CDATA[<p>Compose、Machine 和 Swarm 是Docker 原生提供的三大编排工具。简称Docker三剑客。</p><span id="more"></span><h2 id="Docker-Compose-介绍"><a href="#Docker-Compose-介绍" class="headerlink" title="Docker Compose 介绍"></a>Docker Compose 介绍</h2><p>Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。</p><p>Docker-Compose 是 Docker 的一种编排服务，是一个用于在 Docker 上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。</p><p>通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><p>Docker Compose 工作原理图</p><p><img src="https://img.darklorder.com/img/202308251109146.png"></p><p>Compose 中有两个重要的概念：</p><ul><li>服务 (service) ：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (project) ：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li></ul><p>一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p><h2 id="Docker-Machine-介绍"><a href="#Docker-Machine-介绍" class="headerlink" title="Docker Machine 介绍"></a>Docker Machine 介绍</h2><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p><p>Docker Machine 是一个工具，它允许你在虚拟宿主机上安装 Docker Engine ，并使用 docker-machine 命令管理这些宿主机。你可以使用 Machine 在你本地的 Mac 或 Windows box、公司网络、数据中心、或像 AWS 或 Digital Ocean 这样的云提供商上创建 Docker 宿主机。</p><p>使用 docker-machine 命令，你可以启动、审查、停止和重新启动托管的宿主机、升级 Docker 客户端和守护程序、并配置 Docker 客户端与你的宿主机通信。</p><h3 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a><strong>为什么要使用它？</strong></h3><p>Docker Machine 使你能够在各种 Linux 上配置多个远程 Docker 宿主机。 此外，Machine 允许你在较早的 Mac 或 Windows 系统上运行 Docker，如上一主题所述。 Docker Machine 有这两个广泛的用例。</p><ul><li>我有一个较旧的桌面系统，并希望在 Mac 或 Windows 上运行 Docker</li></ul><p><img src="https://img.darklorder.com/img/202308251112595.png"></p><p>如果你主要在不符合新的 Docker for Mac 和 Docker for Windows 应用程序的旧 Mac 或 Windows 笔记本电脑或台式机上工作，则需要 Docker Machine 来在本地“运行Docker”（即Docker Engine）。在 Mac 或 Windows box 中使用 Docker Toolbox 安装程序安装 Docker Machine 将为 Docker Engine 配置一个本地的虚拟机，使你能够连接它、并运行 docker 命令。</p><ul><li>我想在远程系统上配置 Docker 宿主机</li></ul><p><img src="https://img.darklorder.com/img/202308251112370.png"></p><p>Docker Engine Linux 系统上原生地运行。如果你有一个 Linux 作为你的主系统，并且想要运行 docker 命令，所有你需要做的就是下载并安装 Docker Engine 。然而，如果你想要在网络上、云中甚至本地配置多个 Docker 宿主机有一个有效的方式，你需要 Docker Machine。</p><p>无论你的主系统是 Mac、Windows 还是 Linux，你都可以在其上安装 Docker Machine，并使用 docker-machine 命令来配置和管理大量的 Docker 宿主机。它会自动创建宿主机、在其上安装 Docker Engine 、然后配置 docker 客户端。每个被管理的宿主机（“machine”）是 Docker 宿主机和配置好的客户端的结合。</p><h3 id="Docker-Engine-和-Docker-Machine-有什么区别？"><a href="#Docker-Engine-和-Docker-Machine-有什么区别？" class="headerlink" title="Docker Engine 和 Docker Machine 有什么区别？"></a><strong>Docker Engine 和 Docker Machine 有什么区别？</strong></h3><p>当人们说“Docker”时，他们通常是指 Docker Engine，它是一个客户端 - 服务器应用程序，由 Docker 守护进程、一个REST API指定与守护进程交互的接口、和一个命令行接口（CLI）与守护进程通信（通过封装REST API）。Docker Engine 从 CLI 中接受docker 命令，例如<code>docker run &lt;image&gt;</code>、<code>docker ps</code> 来列出正在运行的容器、<code>docker images</code>来列出镜像，等等。</p><p><img src="https://img.darklorder.com/img/202308251112326.jpeg"></p><p>Docker Machine 是一个用于配置和管理你的宿主机（上面具有 Docker Engine 的主机）的工具。通常，你在你的本地系统上安装 Docker Machine。Docker Machine有自己的命令行客户端 docker-machine 和 Docker Engine 客户端 docker。你可以使用 Machine 在一个或多个虚拟系统上安装 Docker Engine。</p><p>这些虚拟系统可以是本地的（就像你在 Mac 或 Windows 上使用 Machine 在 VirtualBox 中安装和运行 Docker Engine 一样）或远程的（就像你使用 Machine 在云提供商上 provision Dockerized 宿主机一样）。Dockerized 宿主机本身可以认为是，且有时就称为，被管理的“machines”。</p><p><img src="https://img.darklorder.com/img/202308251112620.png"></p><h3 id="Docker-Machine-最主要有两个作用："><a href="#Docker-Machine-最主要有两个作用：" class="headerlink" title="Docker Machine 最主要有两个作用："></a>Docker Machine 最主要有两个作用：</h3><ul><li>使用 Docker Machine 方便在不同的环境中使用 Docker ，比如：Win&#x2F;Mac</li><li>使用 Docker Machine 方便在云环境下批量部署 Docker环境，比如：私有云，公有云批量安装Docker环境</li></ul><blockquote><p>virtualbox 安装很麻烦，我使用的虚拟机和云主机来做实验均没有安装成功，最后使用的是 Docker 官方提供的 Windows 安装包来完成的 virtualbox 相关操作。附 virtualbox 官网：<a href="https://link.zhihu.com/?target=https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p></blockquote><h2 id="Docker-Swarm-介绍"><a href="#Docker-Swarm-介绍" class="headerlink" title="Docker Swarm 介绍"></a>Docker Swarm 介绍</h2><p>实践中会发现，生产环境中使用单个 Docker 节点是远远不够的，搭建 Docker 集群势在必行。然而，面对 Kubernetes, Mesos 以及 Swarm 等众多容器集群系统，我们该如何选择呢？它们之中，Swarm 是 Docker 原生的，同时也是最简单，最易学，最节省资源的，比较适合中小型公司使用。</p><p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p><p>Docker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。</p><p><img src="https://img.darklorder.com/img/202308251114853.png"></p><h3 id="Docker-Swarm-优点"><a href="#Docker-Swarm-优点" class="headerlink" title="Docker Swarm 优点"></a>Docker Swarm 优点</h3><p><strong>任何规模都有高性能表现</strong></p><p>对于企业级的 Docker Engine 集群和容器调度而言，可拓展性是关键。任何规模的公司——不论是拥有五个还是上千个服务器——都能在其环境下有效使用 Swarm。 经过测试，Swarm 可拓展性的极限是在 1000 个节点上运行 50000 个部署容器，每个容器的启动时间为亚秒级，同时性能无减损。</p><p><strong>灵活的容器调度</strong></p><p>Swarm 帮助 IT 运维团队在有限条件下将性能表现和资源利用最优化。Swarm 的内置调度器（scheduler）支持多种过滤器，包括：节点标签，亲和性和多种容器部策略如 binpack、spread、random 等等。</p><p><strong>服务的持续可用性</strong></p><p>Docker Swarm 由 Swarm Manager 提供高可用性，通过创建多个 Swarm master 节点和制定主 master 节点宕机时的备选策略。如果一个 master 节点宕机，那么一个 slave 节点就会被升格为 master 节点，直到原来的 master 节点恢复正常。 此外，如果某个节点无法加入集群，Swarm 会继续尝试加入，并提供错误警报和日志。在节点出错时，Swarm 现在可以尝试把容器重新调度到正常的节点上去。</p><p><strong>和 Docker API 及整合支持的兼容性</strong> Swarm 对 Docker API 完全支持，这意味着它能为使用不同 Docker 工具（如 Docker CLI，Compose，Trusted Registry，Hub 和 UCP）的用户提供无缝衔接的使用体验。</p><p><strong>Docker Swarm 为 Docker 化应用的核心功能（诸如多主机网络和存储卷管理）提供原生支持。</strong>开发的 Compose 文件能（通过 docker-compose up ）轻易地部署到测试服务器或 Swarm 集群上。Docker Swarm 还可以从 Docker Trusted Registry 或 Hub 里 pull 并 run 镜像。</p><p><strong>综上所述，Docker Swarm 提供了一套高可用 Docker 集群管理的解决方案，完全支持标准的 Docker API，方便管理调度集群 Docker 容器，合理充分利用集群主机资源</strong>。</p><blockquote><p><strong>并非所有服务都应该部署在Swarm集群内。数据库以及其它有状态服务就不适合部署在Swarm集群内。</strong></p></blockquote><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 (node) 。节点分为管理 (manager) 节点和工作 (worker) 节点。</p><p>管理节点用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。</p><p>工作节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。下图展示了集群中管理节点与工作节点的关系。</p><p><img src="https://img.darklorder.com/img/202308251115465.png"></p><h3 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h3><p>任务 （Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。 服务 （Services） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li>replicated services 按照一定规则在各个工作节点上运行指定个数的任务。</li><li>global services 每个工作节点上运行一个任务</li></ul><p>两种模式通过 docker service create 的 –mode 参数指定。下图展示了容器、任务、服务的关系。</p><p><img src="https://img.darklorder.com/img/202308251115592.png"></p><p><strong>参考资料</strong><br><a href="https://zhuanlan.zhihu.com/p/34935579">Docker(四)：Docker 三剑客之 Docker Compose - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/35102874">Docker(五)：Docker 三剑客之 Docker Machine - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/35961230">Docker(六)：Docker 三剑客之 Docker Swarm - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfiles</title>
    <link href="/2022/09/10/Dockerfiles/"/>
    <url>/2022/09/10/Dockerfiles/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在使用Docker的过程中，除了官方镜像外，在某些场景下我们也会构建定制化的专属镜像 。例如：需要在现有镜像中添加功能、将开发的应用软件容器化等。</p><p>目前，Docker官方提供的构建方案有两种：1. 基于容器创建 ，2 基于Dockerfile创建。两种方案之间各有特点，通过本文我们可以对此进行了解。</p><h2 id="一-基于容器创建"><a href="#一-基于容器创建" class="headerlink" title="一. 基于容器创建"></a><strong>一. 基于容器创建</strong></h2><p>这种方式最直观明了，在操作上也非常简单，整个过程只需要三个步骤：</p><ul><li><p>创建容器</p></li><li><p>修改容器内容</p></li><li><p>将容器保存为镜像</p></li></ul><p>下面以Nginx的镜像为例来演示该方案。</p><p>1. 创建一个目标容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name nginx -d nginx</span><br></code></pre></td></tr></table></figure><p>2. 修改容器内容</p><p>使用docker  [container] exec 命令可进入容器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker exec -it nginx bash<br>root<span class="hljs-variable">@7d944b6e893f</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>在本示例中，我们在容器内安装一个进程查看工具，增加镜像的功能。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@11e7ee9aed3f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># apt-get update</span><br>root<span class="hljs-variable">@11e7ee9aed3f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># apt-get install -y procps</span><br></code></pre></td></tr></table></figure><p>安装完成后，执行exit退出容器</p><p>3. 将容器保存为镜像</p><p>使用docker [container] commit 指令，可将容器转换为镜像。格式为”docker [container] commit + &lt;container_name&gt; + &lt;image_name&gt;:<tag>”。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ docker commit nginx nginx-new:<span class="hljs-number">1.0</span><br>sha<span class="hljs-number">256</span>:<span class="hljs-keyword">c</span><span class="hljs-number">478994</span>adb<span class="hljs-number">8093</span>a<span class="hljs-number">4425</span>a<span class="hljs-number">7</span>ededa<span class="hljs-number">88</span>d<span class="hljs-number">651</span><span class="hljs-keyword">cc</span><span class="hljs-number">42352</span>af<span class="hljs-number">0</span>baa<span class="hljs-number">9e68</span>cafe<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">65</span>b<span class="hljs-number">411703</span><br></code></pre></td></tr></table></figure><p>查看镜像列表，可看到新的镜像已生成。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ docker images<br>REPOSITORY   <span class="hljs-keyword">TAG</span>       <span class="hljs-title">IMAGE</span> ID       CREATED         SIZE<br>nginx-new    <span class="hljs-number">1.0</span>       c478994adb80   <span class="hljs-number">2</span> minutes ago   <span class="hljs-number">162M</span>B<br>nginx        latest    <span class="hljs-number">605</span>c77e624dd   <span class="hljs-number">3</span> months ago    <span class="hljs-number">141M</span>B<br></code></pre></td></tr></table></figure><p>基于容器创建的方式虽然简单且直观，但并不被推荐使用。首先，这种方式需要创建容器且手工操作，这使得该方式的效率低下。其次，通过这种方式生成的镜像，使用者无法知道整个镜像的创建过程，导致可能发生安全方面的隐患。</p><p>对此，官方推荐的方式是使用Dockerfile 来构建镜像。</p><h2 id="二-基于Dockerfile创建"><a href="#二-基于Dockerfile创建" class="headerlink" title="二. 基于Dockerfile创建"></a><strong>二. 基于Dockerfile创建</strong></h2><p>Dockerfile本身为一个文本文件，在文件中包含了镜像的创建指令，用户可以通过它快速构建定制化的镜像，这也是目前最常用的方式。</p><p>我们以上面的nginx镜像制作为例，来看一下Dockerfile的使用。</p><p>新建一个空目录（名称无要求），在目录内创建一个名为Dockerfile的文件，并写入以下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ vi Dockerfile<br><span class="hljs-keyword">FROM</span> nginx <br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y procps<br></code></pre></td></tr></table></figure><p>完成以后 ，执行docker [image] build命令生成镜像。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t nginx-new:<span class="hljs-number">2</span>.<span class="hljs-number">0</span> .<br></code></pre></td></tr></table></figure><p><strong>注释：</strong>docker [image] build命令用于生成镜像，使用 -t 参数为镜像打tag，tag用于描述镜像的版本信息，如果我们没有指定 tag的话，则默认tag为latest；nginx-new:2.0 为新的镜像名和tag，最后面的 “.” 表示当前目录为执行目录，命令将在当前目录中查看Dockerfile文件并执行。</p><p>命令运行结束后，查看镜像列表可看到已成功创建。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ docker images<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>nginx-<span class="hljs-keyword">new</span>    <span class="hljs-type">2</span>.<span class="hljs-number">0</span>       <span class="hljs-number">2</span>c99e0f4fc85   <span class="hljs-number">2</span> minutes ago   <span class="hljs-number">162</span>MB<br>nginx-<span class="hljs-keyword">new</span>    <span class="hljs-type">1</span>.<span class="hljs-number">0</span>       c478994adb80   <span class="hljs-number">6</span> minutes ago   <span class="hljs-number">162</span>MB<br>nginx        latest    <span class="hljs-number">605</span>c77e624dd   <span class="hljs-number">3</span> months ago    <span class="hljs-number">141</span>MB<br></code></pre></td></tr></table></figure><p>Dockerfile可以看成是docker commit的代码化过程，它的底层也是使用docker commit一层层的构建起新镜像。通过Dockerfile的方式构建镜像能带来显著的收益，首先是让镜像创建的流程变得自动化，这无疑会极大地提升效率和准确性；其次，Dockerfile可以与CI&#x2F;CD流水线结合使用，实现持续集成；同时，这种方式也使得镜像构建的过程变得透明，所见即所得。</p><p>Dockerfile的语法格式如下所示，左边为指令，右边为对应的参数，构建时会从上到下逐行执行。这种语法简单且容易理解，对于用户而言学习成本较低。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">INSTRUCTION arguments</span><br></code></pre></td></tr></table></figure><p>下面我们来学习一下常用的Dockerfile指令，根据功能可以简单分为两类：配置指令和操作指令。</p><h3 id="Dockerfile中的常用指令"><a href="#Dockerfile中的常用指令" class="headerlink" title="Dockerfile中的常用指令"></a><strong>Dockerfile中的常用指令</strong></h3><table><thead><tr><th align="left">指令</th><th align="left">功能简介</th></tr></thead><tbody><tr><td align="left">FROM</td><td align="left">指定构建新Image时使用的基础Image，通常必须是Dockerfile的第一个有效指令，但其前面也可以出现ARG指令</td></tr><tr><td align="left">LABEL</td><td align="left">附加到Image之上的元数据，键值格式</td></tr><tr><td align="left">ENV</td><td align="left">以键值格式设定环境变量，可被其后的指令所调用，且基于新生成的Image运行的Container中也会存在这些变量</td></tr><tr><td align="left">RUN</td><td align="left">以FROM中定义的Image为基础环境运行指定命令，生成结果将作为新Image的一个镜像层，并可由后续指令所使用</td></tr><tr><td align="left">CMD</td><td align="left">基于该Dockerfile生成的Image运行Container时，CMD能够指定容器中默认运行的程序，因而其只应该定义一次</td></tr><tr><td align="left">ENTRYPOINT</td><td align="left">类似于CMD指令的功能，但不能被命令行指定要运行的应用程序覆盖，且与CMD共存时，CMD的内容将作为该指令中定义的程序的参数</td></tr><tr><td align="left">WORKDIR</td><td align="left">为RUN、CMD、ENTRPOINT、COPY和ADD等指令设定工作目录</td></tr><tr><td align="left">COPY</td><td align="left">复制主机上或者前一阶段构建结果中（需要使用–from选项）文件或目录生成新的镜像层</td></tr><tr><td align="left">ADD</td><td align="left">与COPY指令的功能相似，但ADD额外也支持使用URL指定的资源作为源文件</td></tr><tr><td align="left">VOLUME</td><td align="left">指定基于新生成的Image运行Container时期望作为Volume使用的目录</td></tr><tr><td align="left">EXPOSE</td><td align="left">指定基于新生成的Image运行Container时期望暴露的端口，但实际暴露与否取决于“docker run”命令的选项，支持TCP和UDP协议</td></tr><tr><td align="left">USER</td><td align="left">为Dockerfile中该指令后面的RUN、CMD和ENTRYPOING指令中要运行的应用程序指定运行者身份UID，以及一个可选的GID</td></tr><tr><td align="left">ARG</td><td align="left">定义专用于build过程中的变量，但仅对该指标之后的调用生效，其值可由命令行选项“–build-arg”进行传递</td></tr><tr><td align="left">ONBUILD</td><td align="left">触发器，生效于由该Dockerfile构建出的新Image被用于另一个Dockerfile中的FROM指令作为基础镜像时</td></tr><tr><td align="left">STOPSIGNAL</td><td align="left">用于通知Container终止的系统调用信号</td></tr><tr><td align="left">HEALTHCHECK</td><td align="left">定义检测容器应用的健康状态的具体方法</td></tr><tr><td align="left">SHELL</td><td align="left">为容器定义运行时使用的默认shell程序，Linux系统默认使用 [“&#x2F;bin&#x2F;sh”,”-c”]，Windows默认使用 [“cmd”, “&#x2F;S”, “&#x2F;C”]</td></tr></tbody></table><h3 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a><strong>配置指令</strong></h3><ul><li>FROM指令</li></ul><p>格式：FROM &lt;image_name&gt; 或 FROM &lt;image_name&gt;:<tag></p><p>该指令作为Dockerfile的第一条指令，用于指定基于哪个基础镜像来制作新的镜像，这条指令是必须存在的。为了避免最终产生的镜像变得臃肿，推荐在满足需求的前提下，尽量采用精简型的镜像，如Alpine等作为基础镜像。</p><p>示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> python:<span class="hljs-number">3</span>.<span class="hljs-number">8</span>-alpine<br></code></pre></td></tr></table></figure><ul><li>MAINTAINER指令</li></ul><p>格式：MAINTAINER &lt;author_name&gt;</p><p>指定镜像的作者信息。</p><p>示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span>  Alex<br></code></pre></td></tr></table></figure><ul><li>EXPOSE指令<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">格式 ：格式为EXPOSE <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span> [<span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>]<br></code></pre></td></tr></table></figure></li></ul><p>用于声明容器内服务的监控端口，该指令只是起到声明作用，并不会自动完成端口映射。如果要映射端口，需要在启动容器时使用-p 参数指定。</p><p>示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><ul><li>ENV指令<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">格式 ：ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br></code></pre></td></tr></table></figure>指定容器的环境变量，该变量可以被RUN指令使用，并在容器启动后保持。</li></ul><p>示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ENV MY_NAME<span class="hljs-operator">=</span><span class="hljs-string">&quot;Alex&quot;</span><br></code></pre></td></tr></table></figure><ul><li>VOLUME指令</li></ul><p>格式：VOLUME  [“&#x2F;data”]</p><p>创建一个数据卷挂载点，一般用来存放数据库和需要持久化的数据等。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /mydata</span><br></code></pre></td></tr></table></figure><ul><li>WORKDIR指令<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">格式：WORKDIR <span class="hljs-tag">&lt;<span class="hljs-name">workdir</span>&gt;</span><br></code></pre></td></tr></table></figure>指定容器的工作目录，在它后面执行的指令将以 <workdir>做为当前工作目录。</li></ul><p>示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt</span><br></code></pre></td></tr></table></figure><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a><strong>操作指令</strong></h3><ul><li>RUN指令<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">格式：<span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt; </span><br></code></pre></td></tr></table></figure>指定在容器中运行的命令，经常用于安装软件包等操作。当执行RUN指令时，会生成一个新的镜像层来保存这些内容。为了减少镜像体积，可以用&amp;&amp; 将多个命令放到单个RUN指令中执行。</li></ul><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y procps<br></code></pre></td></tr></table></figure><ul><li>COPY指令<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">格式为：COPY <span class="hljs-tag">&lt;<span class="hljs-name">src</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dest</span>&gt;</span><br></code></pre></td></tr></table></figure>用于复制本机的文件或目录到容器中，<src>指定源文件路径，<dest>指定目的路径。</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span>  test.txt <span class="hljs-regexp">/opt/</span><br></code></pre></td></tr></table></figure><ul><li>ADD指令<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">格式：ADD <span class="hljs-tag">&lt;<span class="hljs-name">src</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dest</span>&gt;</span><br></code></pre></td></tr></table></figure>该指令与COPY相似，但如果<src>是tar文件的话，ADD会将其解压到<dest>。另外，<src>也可以指定为下载的url。</li></ul><p>示例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span>  test.tar.gz  /<span class="hljs-meta">opt</span>/<br></code></pre></td></tr></table></figure><ul><li>CMD指令</li></ul><p>格式：</p><p>CMD [“executable”,”param1”,”param2”] (官方推荐方式）</p><p>CMD [“param1”,”param2”]</p><p>CMD command param1 param2 </p><p>配置容器启动后默认运行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，则只有最后一条被执行。CMD可以在docker run 启动容器时被替换。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><ul><li>ENTRYPOINT指令</li></ul><p>格式：</p><p>ENTRYPOINT[“executable”，”param1”，”param2”]</p><p>ENTRYPOINT command param1 param2 </p><p>配置容器启动后运行的命令，与CMD指令相似，但区别在于ENTRYPOINT指令无法被覆盖。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>在理解Dockerfile相关的指令后，我们以一个Python程序为例，来实践一下将应用容器化的操作。</p><p>相关代码仓库地址：<a href="https://github.com/rui789/myapp.git">https://github.com/rui789/myapp.git</a></p><p>下载代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rui789/my</span>app.git<br></code></pre></td></tr></table></figure><p>编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$cd myapp<br>$ vi Dockerfile<br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.8</span>-alpine<br><span class="hljs-keyword">MAINTAINER</span> alex<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/myapp</span><br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt </span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;python /opt/myapp/main.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>运行命令开始构建 </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>docker build -t <span class="hljs-symbol">myapp:</span><span class="hljs-number">1.0</span> .<br></code></pre></td></tr></table></figure><p>查看镜像，已成功构建。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ docker images myapp<br>REPOSITORY   <span class="hljs-keyword">TAG</span>       <span class="hljs-title">IMAGE</span> ID       CREATED         SIZE<br>myapp        <span class="hljs-number">1.0</span>       <span class="hljs-number">903</span>ea6552f8b   <span class="hljs-number">2</span> minutes ago   <span class="hljs-number">53.7M</span>B<br></code></pre></td></tr></table></figure><p>使用docker [image] history命令可查看镜像在构建过程执行了哪些操作，这有利于使用者了解镜像的情况。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs leaf"> docker history myapp:1.0<br>IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT<br>903ea6552f8b   6 minutes ago   /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;pyth…   0B        <br>2097b72b5704   6 minutes ago   /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  EXPOSE 80                    0B        <br>......<br></code></pre></td></tr></table></figure><p>使用镜像创建容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-built_in">run</span> -d -p 80:80 myapp:1.0 <br>38ca1c8ae8ee12deff1db1df001ee2e47186de4637986bde3dc0582dd05fe0a6<br></code></pre></td></tr></table></figure><p>浏览器访问地址，可看到服务已正常运行</p><p><strong>参考资料</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzU2OTc4NDI2MQ==&mid=2247484427&idx=1&sn=f901d9f97cdb30339475e3e153b08380&chksm=fcf826a1cb8fafb722111fe38c09ecafc6096b875169864b0c1a294199ebca24a3f6737596de&scene=21#wechat_redirect">Docker容器实战六：构建定制化镜像</a><br><a href="https://www.runoob.com/docker/docker-dockerfile.html">Docker Dockerfile|菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker网络</title>
    <link href="/2022/09/08/Docker-Networking/"/>
    <url>/2022/09/08/Docker-Networking/</url>
    
    <content type="html"><![CDATA[<p>Docker网络架构主要由三部分组成：CNM，Libnetwork和Driver。</p><span id="more"></span><h2 id="Docker的默认网络类型"><a href="#Docker的默认网络类型" class="headerlink" title="Docker的默认网络类型"></a>Docker的默认网络类型</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@dk</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># </span><br>root<span class="hljs-variable">@dk</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># docker info -f &#x27;&#123;&#123;.Plugins.Network&#125;&#125;&#x27;   </span><br>[bridge host ipvlan macvlan null overlay]<br>root<span class="hljs-variable">@dk</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><ul><li>bridge（桥接）</li><li>host（主机）</li><li>ipvlan（三层模式划分vlan）</li><li>macvlan（二层模式划分vlan）</li><li>null（躺平：不与别人交互）</li><li>overlay（叠加网络）</li></ul><h2 id="Docker的网络模式"><a href="#Docker的网络模式" class="headerlink" title="Docker的网络模式"></a>Docker的网络模式</h2><p>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">root<span class="hljs-symbol">@dk</span>:~<span class="hljs-meta"># </span><br>root<span class="hljs-symbol">@dk</span>:~<span class="hljs-meta"># docker network ls</span><br>NETWORK ID     NAME      DRIVER    SCOPE<br>b44c04c3ee09   bridge    bridge    <span class="hljs-keyword">local</span><br><span class="hljs-number">231</span>d383cae90   host      host      <span class="hljs-keyword">local</span><br><span class="hljs-number">432</span>ab6b3b127   none      <span class="hljs-literal">null</span>      <span class="hljs-keyword">local</span><br>root<span class="hljs-symbol">@dk</span>:~<span class="hljs-meta"># </span><br></code></pre></td></tr></table></figure><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Host</td><td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</td></tr><tr><td>Bridge</td><td>此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</td></tr><tr><td>None</td><td>该模式关闭了容器的网络功能。</td></tr><tr><td>Container</td><td>创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</td></tr></tbody></table><img src="https://img.darklorder.com/img/202308251837508.png"/><ul><li><p>Closed container：只有loop接口，就是null类型</p></li><li><p>Bridged container A：桥接式类型，容器网络接入到docker0网络上</p></li><li><p>joined container A：联盟式网络，让两个容器有一部分名称空间隔离（User、Mount、Pid），这样两个容器间就拥有同一个网络接口，网络协议栈</p></li><li><p>Open container：开放式网络：直接共享物理机的三个名称空间（UTS、IPC、Net），世界使用物理主机的网卡通信，赋予容器管理物理主机网络的特权</p></li></ul><h2 id="容器网络第一个标准CNM"><a href="#容器网络第一个标准CNM" class="headerlink" title="容器网络第一个标准CNM"></a>容器网络第一个标准CNM</h2><p>围绕Docker生态，目前有两种主流的网络接口方案，即Docker主导的Container Network Model（CNM）和Kubernetes社区主推的Container Network Interface（CNI），其中CNM相对CNI较早提出。不管是CNM还是CNI，其最终目标都是以一致的编程接口，抽象网络实现。<strong>CNI和CNM并非是完全不可调和的两个模型</strong>，二者是可以进行转化的。</p><table><thead><tr><th>CNM阵营</th><th>CNI阵营</th></tr></thead><tbody><tr><td>Docker Libnetwork的优势就是Docker原生与Docker容器生命周期结合紧密，缺点是与Docker耦合度过高</td><td>CNI的优势是兼容其他容器技术（例如rkt）及上层编排系统 （Kubernetes&amp;Mesos），而且社区活跃势头迅猛，再加上Kubernetes主推</td></tr><tr><td>Docker Swarm overlay <br/>Macvlan &amp; IP network <br/>drivers <br/>Calico <br/>Contiv</td><td>Weave <br/>Macvlan <br/>flannel <br/>Calico <br/>Contiv <br/>Mesos CNI</td></tr></tbody></table><p>在顶层设计中，Docker 网络架构由 3 个主要部分构成：CNM、Libnetwork 和驱动。</p><ul><li>CNM： 是设计标准。在 CNM 中，规定了 Docker 网络架构的基础组成要素。</li><li>Libnetwork： 是 CNM 的具体实现，并且被 Docker 采用，Libnetwork 通过 Go 语言编写，并实现了 CNM 中列举的核心组件。</li><li>驱动：通过实现特定网络拓扑的方式来拓展该模型的能力。</li></ul><h2 id="容器网络模型（CNM）"><a href="#容器网络模型（CNM）" class="headerlink" title="容器网络模型（CNM）"></a>容器网络模型（CNM）</h2><p>在最初的版本中，Docker的网络功能集成在Docker Daemon的代码中，这使得整体架构变得臃肿且缺乏灵活性，无法适应复杂的网络需求。为此，Docker公司在后面提出了CNM（Container Network Model，可译为容器网络模型）规范，并将网络功能独立出来作为一个组件，即Libnetwork网络库。</p><p>Libnetwork的设计遵循着CNM规范，在该规范中包含着三个重要概念：Sandbox（沙盒）、Endpoint（端点）和 Network（网络）。</p><p><strong>1. Sandbox（沙盒）</strong></p><p>Sandbox可以看成是在容器中独立的网络空间，在里面包含了容器的网络栈配置，包括网络接口、路由表和DNS设置等。Sandbox的标准实现基于Linux中的Network Namespace特性。一个Sandbox可以包含多个Endpoint，并且连接到不同的网络中。</p><p><strong>2. Endpoint（端点）</strong></p><p>Endpoint的作用在于将容器连接到网络，Endpoint通常由一对Veth Pair（成对出现的一种虚拟网络设备接口）组成，其中一端在Sandbox中，另一端连接到网络中。</p><p><strong>3.Network（网络）</strong></p><p>可以连接多个Endpoint的一个子网。</p><p><strong>CNM示例图：</strong></p><p><img src="https://img.darklorder.com/img/202308282232623.png" alt="图片"></p><p>如图所示，三个容器中都有独立的Sandbox，而每个Sandbox中包含自己的Endpoint，并且通过Endpoint连接到网络。可以看到第二个容器有两个Endpoint，这使得其可以同时连接两个不同的网络。而容器1和容器3由于处于不同的网络中，彼此之间将无法直接通信 。</p><p>使用CNM规范的好处，在于容器可以不用关心网络的具体实现，只要能提供网络接入点给到容器接入即可。而对于网络的具体实现，则交由驱动来完成。这种方式解耦了容器与网络，容器可以接入不同类型的网络，而第三方只要按照CNM规范开发驱动，即可保证容器的无缝接入，架构的灵活性得到很大的提升。</p><h2 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h2><p>在安装完Docker后会自动创建三个网络，我们通过 docker network ls 命令可查看相关的网络信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ docker network ls<br>NETWORK ID     NAME      DRIVER    <span class="hljs-keyword">SCOPE</span><br>ad87b0b5afaa   bridge    bridge    <span class="hljs-keyword">local</span><br><span class="hljs-number">19</span>bd38b4d728   host      host      <span class="hljs-keyword">local</span><br>a83dd07d2ba1   <span class="hljs-keyword">none</span>      <span class="hljs-keyword">null</span>      <span class="hljs-keyword">local</span><br></code></pre></td></tr></table></figure><p>Docker默认创建的网络类型有bridge、host和null，在启动容器时，可以通过–network 选项指定使用的网络。如果不指定，则默认会使用bridge网络。</p><p><strong>1. bridge网络</strong></p><p>当启动docker时，会自动生成一个名为docker0的Linux bridge(网桥)。bridge可以看成是一个软件交换机，负责对挂载在它上面的接口进行包转发。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ifconfig docker0<br>docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255<br>        inet6 fe80::42:8bff:fe36:8c00  prefixlen<span class="hljs-number"> 64 </span> scopeid 0x20&lt;link&gt;<br>        ether 02:42:8b:36:8c:00  txqueuelen<span class="hljs-number"> 0 </span> (Ethernet)<br>        RX packets<span class="hljs-number"> 0 </span> bytes<span class="hljs-number"> 0 </span>(0.0 B)<br>        RX errors<span class="hljs-number"> 0 </span> dropped<span class="hljs-number"> 0 </span> overruns<span class="hljs-number"> 0 </span> frame 0<br>        TX packets<span class="hljs-number"> 5 </span> bytes<span class="hljs-number"> 446 </span>(446.0 B)<br>        TX errors<span class="hljs-number"> 0 </span> dropped<span class="hljs-number"> 0 </span>overruns<span class="hljs-number"> 0 </span> carrier<span class="hljs-number"> 0 </span> collisions 0<br></code></pre></td></tr></table></figure><p>运行brctl show 命令查看网桥信息，可以看到在没有启动任何容器的情况下，docker0的 “interfaces” 处为空，表明该网桥目前未挂载任何接口。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ <span class="hljs-keyword">brctl </span><span class="hljs-keyword">show</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bridge </span>name     <span class="hljs-keyword">bridge </span>id               STP enabled     interfaces<br>docker0         <span class="hljs-number">8000</span>.<span class="hljs-number">02425</span>cf9d61c       no<br></code></pre></td></tr></table></figure><p>现在，我们启动一个容器后，再次来查看网桥情况。可以看到，当前网桥已经挂载了一个接口，名称为veth1ec2b44。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-built_in">run</span> -d --name nginx -p 80:80 nginx:1.20-alpine<br>07a46c03d17b40545a090dab60eac9a75bfa8050c572ae2c330ca98700ce68d5<br><br>$ brctl show<span class="hljs-built_in"></span><br><span class="hljs-built_in">bridge </span>name    <span class="hljs-built_in"> bridge </span>id               STP enabled     interfaces<br>docker0         8000.02428b368c00       <span class="hljs-literal">no</span>              veth1ec2b44<br></code></pre></td></tr></table></figure><p>我们查看一下容器里面的网络配置，可以看到容器的网卡名称为eth0@if11，它与挂载到网桥的veth1ec2b44接口即是一对Veth Pair。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">$ docker exec nginx ip addr<br><span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN qlen <span class="hljs-number">1000</span><br>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">8</span> scope host lo<br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">10</span>: eth0@if11: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> UP <br>    link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:ac:<span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">02</span> brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.17</span>.<span class="hljs-number">0.2</span>/<span class="hljs-number">16</span> brd <span class="hljs-number">172.17</span>.<span class="hljs-number">255.255</span> scope <span class="hljs-keyword">global</span> eth0<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>前面我们说过，Veth Pair是成对的网络设备，此时的容器网络架构如下所示：</p><p><img src="https://img.darklorder.com/img/202308282236353.png" alt="图片"></p><p>Veth Pair就如一根网线的两端，其中一端收到的网络包会从另一端出去，这使得连接到同一个网桥的容器可以彼此通信，在容器与网桥间共同组成了一个虚拟局域网。</p><p><img src="https://img.darklorder.com/img/202308282232733.png" alt="图片"></p><p>当bridge网络被创建时，系统会为其分配一个子网段，用于容器使用。当容器接入时，会从IP池中分配IP给到容器网卡，而容器的网关则会指向bridge，也即是docker0的IP地址。</p><p><strong>2.  host网络</strong> </p><p>在启动容器时使用–network host指定为本机网络，则容器将与宿主机共享网络栈，此时容器会使用主机的IP以及其他网络配置。</p><p>如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pf">$ docker run -d --network host --name nginx2 nginx:<span class="hljs-number">1.20</span>-alpine<br><span class="hljs-number">6</span>f2023e6e714f9bb212bca9aec12dd7c3befd51a01d28216cea12c64136f6924<br><br>$ docker exec -it nginx2 ip addr            <br><span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN qlen <span class="hljs-number">1000</span><br>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">8</span> scope host lo<br>       valid_lft forever preferred_lft forever<br>    <span class="hljs-keyword">inet6</span> ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host <br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">2</span>: ens33: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc pfifo_fast <span class="hljs-keyword">state</span> UP qlen <span class="hljs-number">1000</span><br>    link/ether <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:<span class="hljs-number">29</span>:<span class="hljs-number">7</span>b:a8:<span class="hljs-number">71</span> brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">214.112</span>/<span class="hljs-number">24</span> brd <span class="hljs-number">192.168</span>.<span class="hljs-number">214.255</span> scope <span class="hljs-keyword">global</span> dynamic noprefixroute ens33<br>       valid_lft <span class="hljs-number">2592730</span>sec preferred_lft <span class="hljs-number">2592730</span>sec<br>    <span class="hljs-keyword">inet6</span> fe80::f992:e993:bd8e:<span class="hljs-number">2</span>de6/<span class="hljs-number">64</span> scope link noprefixroute <br>       valid_lft forever preferred_lft forever<br>......<br></code></pre></td></tr></table></figure><p>使用host网络时，对容器做端口映射将会无效， 容器会忽略 -p 所指定的端口，而直接在宿主机网络层面开启对应端口。例如，容器中如果开放了80端口，那么此时宿主机也将开放同样端口。</p><p>host网络相比bridge网络具有更高的性能，同时在容器有大量端口要开放的时候 ，也会省事很多。但同时也增加了不安全性，此时可在容器内对主机的网络栈进行操作，所以并不推荐使用。</p><p><strong>3. null网络</strong></p><p>null网络会禁用容器的网络栈，使得容器与外部隔离。在启动时通过 –network none 实现。此时，容器除lo外，将不再有其他网卡，完全与外部网络隔离。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ docker run -d --network none --name nginx3 nginx:<span class="hljs-number">1.20</span>-alpine<br><span class="hljs-number">513</span>e0ce37dab8dd6cb0b15fe0311af5ca7a050378ebcdb3b2c20d5a6bc39c2b5<br><br>$ docker exec -it nginx3 ifconfig<br><span class="hljs-keyword">lo</span>        Link encap:Local Loopback  <br>          inet addr:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>  Mask:<span class="hljs-number">255.0</span>.<span class="hljs-number">0.0</span><br>          UP LOOPBACK RUNNING  MTU:<span class="hljs-number">65536</span>  Metric:<span class="hljs-number">1</span><br>          RX packet<span class="hljs-variable">s:0</span> error<span class="hljs-variable">s:0</span> dropped:<span class="hljs-number">0</span> overrun<span class="hljs-variable">s:0</span> frame:<span class="hljs-number">0</span><br>          TX packet<span class="hljs-variable">s:0</span> error<span class="hljs-variable">s:0</span> dropped:<span class="hljs-number">0</span> overrun<span class="hljs-variable">s:0</span> carrier:<span class="hljs-number">0</span><br>          collision<span class="hljs-variable">s:0</span> txqueuelen:<span class="hljs-number">1000</span> <br>          RX byte<span class="hljs-variable">s:0</span> (<span class="hljs-number">0.0</span> B)  TX byte<span class="hljs-variable">s:0</span> (<span class="hljs-number">0.0</span> B)<br></code></pre></td></tr></table></figure><p>这种场景一般使用很少，只有在某些不需要与外界联网，并且对安全要求非常高的程序才有可能用到。</p><h2 id="外部网络访问"><a href="#外部网络访问" class="headerlink" title="外部网络访问"></a>外部网络访问</h2><p>docker0本身是作为宿主机的一个本地接口，因此，容器默认情况下可以访问到宿主机自身的网络。但当容器需要访问外部网络时，则需要宿主机做一层NAT转发。</p><p>在安装docker时，默认会启用Linux的包转发功能，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ sudo sysctl net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.ip_forward</span><br>net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.ip_forward</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>查看宿主机iptable的nat表上面的POSTROUTING链规则，可看到有一条转发规则。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ sudo iptables -t nat -nvL POSTROUTING<br>Chain POSTROUTING (policy <span class="hljs-keyword">ACCEPT</span> <span class="hljs-number">71</span> packets, <span class="hljs-number">5396</span> bytes)<br> pkts bytes target       prot  opt   <span class="hljs-keyword">in</span>   <span class="hljs-keyword">out</span>        source            destination         <br> <span class="hljs-number">0</span>     <span class="hljs-number">0</span>    MASQUERADE    <span class="hljs-keyword">all</span>   <span class="hljs-comment">--   *  !docker0   172.17.0.0/16      0.0.0.0/0</span><br></code></pre></td></tr></table></figure><p>该规则的作用是当docker0收到来自容器网段（172.17.0.0&#x2F;16)的网络包时，将其交给MASQUERADE处理。MASQUERADE与传统的SNAT相似，会将网络包的源IP替换为网卡IP，这样可以保证容器的网络包能够正常外出。</p><p>那么，外部网络又是如何访问容器的呢？在前面的学习中，我们知道启动容器时可以使用 -p 的方式，将容器的端口映射出来。在这个过程中，Docker会在本地添加相应的iptable规则，用于网络包的DNAT转换。</p><p>以本示例的容器为例，这里我们开放了80端口。当查看相关的iptable规则时，可看到多了一个关于80端口的DNAT规则。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ docker run -d --name nginx -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> nginx:<span class="hljs-number">1.20</span>-alpine<br><span class="hljs-number">07</span>a<span class="hljs-number">46</span><span class="hljs-keyword">c</span><span class="hljs-number">03</span>d<span class="hljs-number">17</span>b<span class="hljs-number">40545</span>a<span class="hljs-number">090</span>dab<span class="hljs-number">60</span>eac<span class="hljs-number">9</span>a<span class="hljs-number">75</span>bfa<span class="hljs-number">8050</span><span class="hljs-keyword">c</span><span class="hljs-number">572</span>ae<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">330</span>ca<span class="hljs-number">98700</span>ce<span class="hljs-number">68</span>d<span class="hljs-number">5</span><br><br>$ iptables -t nat -nvL  DOCKER<br>Chain DOCKER (<span class="hljs-number">2</span> references)<br> pkts bytes <span class="hljs-keyword">target</span>     prot opt in     out     source               destination         <br>......       <br>    <span class="hljs-number">0</span>     <span class="hljs-number">0</span> DNAT       tcp  --  <span class="hljs-title">!docker0</span> *       <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">0</span>            <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">0</span>            tcp dpt:<span class="hljs-number">80</span> <span class="hljs-keyword">to</span>:<span class="hljs-number">172.17</span>.<span class="hljs-number">0.2</span>:<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>该规则将访问到主机80端口的网络包，转发到容器地址（172.17.0.2）的80端口，以此实现外部网络对容器的访问。</p><p>此时，容器的整体网络架构如下图所示：</p><p><img src="https://img.darklorder.com/img/202308282231667.png" alt="图片"></p><p><strong>附录: Docker网络常用命令</strong></p><p><strong>1. 创建网络</strong>  </p><p>除了Docker默认生成的网络外，用户也可以创建自定义的网络。docker network create命令用于创建新的网络。</p><p>示例：此处创建一个名为mynet的bridge网络。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker<span class="hljs-built_in"> network </span>create -d<span class="hljs-built_in"> bridge </span>mynet<br>592da9b6f8197cb7f11bae42f83f4429d9a97371a4aaccd3701d2998181763e8<br></code></pre></td></tr></table></figure><p><strong>2. 列出所有网络</strong></p><p>docker network ls命令用于列出当前所有网络。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ docker network ls<br>NETWORK ID     NAME      DRIVER    <span class="hljs-keyword">SCOPE</span><br><span class="hljs-number">12</span>bb6c359b1c   bridge    bridge    <span class="hljs-keyword">local</span><br><span class="hljs-number">19</span>bd38b4d728   host      host      <span class="hljs-keyword">local</span><br><span class="hljs-number">12e7</span>db06ad9b   mynet     bridge    <span class="hljs-keyword">local</span><br>a83dd07d2ba1   <span class="hljs-keyword">none</span>      <span class="hljs-keyword">null</span>      <span class="hljs-keyword">local</span><br></code></pre></td></tr></table></figure><p><strong>3. 查看网络详情</strong></p><p>docker network inspect命令可查看一个网络的详细信息，包括接入的容器、网络配置等。</p><p>示例：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lasso">$ docker network inspect mynet<br><span class="hljs-meta">[</span><br>    &#123;<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;mynet&quot;</span>,<br>        <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;12e7db06ad9bf7aaaedb0cb33042ea48170d4ef2026da9964acba1cb984f441b&quot;</span>,<br>        <span class="hljs-string">&quot;Created&quot;</span>: <span class="hljs-string">&quot;2022-05-30T03:40:51.977036849-04:00&quot;</span>,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;bridge&quot;</span>,<br>        <span class="hljs-string">&quot;EnableIPv6&quot;</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-string">&quot;IPAM&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>,<br>            <span class="hljs-string">&quot;Options&quot;</span>: &#123;&#125;,<br>            <span class="hljs-string">&quot;Config&quot;</span>: <span class="hljs-meta">[</span><br>                &#123;<br>                    <span class="hljs-string">&quot;Subnet&quot;</span>: <span class="hljs-string">&quot;172.18.0.0/16&quot;</span>,<br>                    <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;172.18.0.1&quot;</span><br><span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p><strong>4. 连接网络</strong></p><p>docker network connect命令用于将容器连接到网络，通过该命令可以更改容器的接入网络。</p><p>示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ docker network connect mynet nginx<br></code></pre></td></tr></table></figure><p><strong>5. 删除网络</strong> </p><p>docker network rm 命令可用于删除指定网络。只有当网络没有容器连接时，才能正常删除。</p><p>示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network <span class="hljs-built_in">rm</span> mynet<br>mynet<br></code></pre></td></tr></table></figure><p><strong>参考资料</strong><br><a href="https://zhuanlan.zhihu.com/p/480034319?utm_id=0">《k8s网络指南》Chapter2-Docker网络模型简介-知乎</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU2OTc4NDI2MQ==&mid=2247484536&idx=1&sn=e317e4e07bc74ff8148e1cc9fa91bb74&chksm=fcf826d2cb8fafc474433f7918ad1de6c5937da631ee39d66c476d66b30c1b46c6d23eae8511&scene=21#wechat_redirect">Docker容器实战十：容器网络</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker存储卷</title>
    <link href="/2022/09/07/Docker-data-volume/"/>
    <url>/2022/09/07/Docker-data-volume/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h2><h2 id="COW机制（写时复制）"><a href="#COW机制（写时复制）" class="headerlink" title="COW机制（写时复制）"></a>COW机制（写时复制）</h2><p>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层。</p><p><strong>如果容器修改了镜像的原有文件，那么只读层的文件不会被修改，而是会被复制到读写层做修改，只读版本依然存在，只是被读写层中的副本隐藏起来了，这就是“写时复制(COW)”机制。</strong></p><p><img src="https://img.darklorder.com/img/202308161627460.png"></p><p>因为隔着很多层镜像，用上面这种方式，去访问一个文件，然后进行修改和删除等一类的操作，其效率会非常的低，<br>而要想绕过这种限制，我们可通过使用存储卷来实现。</p><h2 id="什么是存储卷"><a href="#什么是存储卷" class="headerlink" title="什么是存储卷"></a>什么是存储卷</h2><p>存储卷会把<strong>宿主机本地文件系统中的目录 与容器文件系统上的目录建立绑定关系</strong>。</p><p><strong>简单来说，当我们在容器中目录下写入数据时，因为目录绑定关系的存在，容器会将其内容直接写入到宿主机上的对应目录。</strong></p><p><img src="https://img.darklorder.com/img/202308161627538.png"></p><p>在宿主机上的这个与容器形成绑定关系的目录被称作存储卷。</p><h2 id="使用存储卷的好处"><a href="#使用存储卷的好处" class="headerlink" title="使用存储卷的好处"></a>使用存储卷的好处</h2><p><strong>①防止数据丢失</strong><br>当容器所有运行进程的有效数据都保存在存储卷时，如果容器关闭甚至被删除时，只要不删除容器绑定在宿主机上的目录，我们就不用担心数据丢失了，以此来实现数据脱离容器的生命周期，被持久保存的目的。</p><p><strong>②摆脱容器和主机的对应限制</strong><br>我们通过这种方式管理容器，容器就可以脱离主机的限制。任何一台主机安装docker以后，运行容器后，其数据可以置于一个共享存储文件系统上，比如nfs。</p><h2 id="为什么要用存储卷"><a href="#为什么要用存储卷" class="headerlink" title="为什么要用存储卷"></a>为什么要用存储卷</h2><p>关闭并重启容器，其数据不受影响，但删除Docker容器，则其更改将会全部丢失。<br>因此Docker存在的问题有：</p><ul><li>存储于联合挂载文件系统中，不易于宿主机访问</li><li>容器间数据共享不便（容器之间本身是隔离的）</li><li>删除容器其数据会丢失<br>使用存储卷就是来解决以上问题的。</li></ul><h2 id="存储卷管理方式"><a href="#存储卷管理方式" class="headerlink" title="存储卷管理方式"></a>存储卷管理方式</h2><p>存储卷（Data Volume）于容器初始化时被自动创建，由base image提供的卷中的数据会于此期间完成复制。</p><p>存储卷为Docker提供了独立于容器的数据管理机制，我们可以把镜像想象成静态文件，例如“程序”，把卷类比为动态内容，例如“数据”。所以镜像可以重复利用，而存储卷则可以共享。</p><p><strong>存储卷既实现了“程序(镜像)”和“数据(卷)”的分离，也实现了“程序(镜像)”和“制作镜像的主机”的分离，所以用户制作镜像时，无须再考虑镜像运行容器所在的主机环境。</strong></p><p><img src="https://img.darklorder.com/img/202308161627876.png"></p><h2 id="存储卷的分类"><a href="#存储卷的分类" class="headerlink" title="存储卷的分类"></a>存储卷的分类</h2><p>Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同：</p><ul><li><p><strong>绑定挂载卷</strong></p><ul><li>指向主机文件系统上，用户指定位置的卷(常用，就算容器删了，数据也不会丢失)</li></ul></li><li><p><strong>Docker 管理的卷</strong></p><ul><li>Docker 守护进程，在 Docker 所在的主机文件系统中，创建的卷（容器删了，数据也会消失）</li></ul></li></ul><p><img src="https://img.darklorder.com/img/202308161627408.png"></p><p><strong>bind mount与 docker managed volume对比</strong></p><table><thead><tr><th></th><th>bind mount</th><th>docker managed volume</th></tr></thead><tbody><tr><td>volume位置</td><td>可任意指定</td><td>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;…</td></tr><tr><td>对已有的mount point影响</td><td>隐藏并替换为volume</td><td>原有的数据复制到volume</td></tr><tr><td>是否支持单个文件</td><td>支持</td><td>不支持，只能是目录</td></tr><tr><td>权限控制</td><td>可设置为只读，默认为读写</td><td>无控制，均为读写权限</td></tr><tr><td>移植性</td><td>移植性弱，与host path绑定</td><td>移植性强，无需指定host目录</td></tr></tbody></table><h2 id="容器数据管理"><a href="#容器数据管理" class="headerlink" title="容器数据管理"></a>容器数据管理</h2><p>用户在使用Docker的过程中，往往需要能查看容器内应用产生的数据，或者需要把容器内的数据进行备份，甚至多个容器之间进行数据的共享，这必然涉及容器的数据管理操作。</p><p>容器中管理数据主要有两种方式：</p><ul><li>数据卷（Data Volumes）</li><li>数据卷容器（Data Volumes Containers）</li></ul><p>容器Volume使用语法：<br><strong>docker管理的卷（容器删除，数据同步丢失</strong>）<br><code>docker run -it --name CONTAINER_NAME -v VOLUMEDIR IMAGE_NAME</code></p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># 容器管理的卷的数据存储示例</span><br>[root@rookie ~]# docker ps -a<br>CONTAINER ID   IMAGE     COMMAND     CREATED      STATUS                    PORTS     NAMES<br><span class="hljs-number">98</span>b74ab02ea5   busybox   <span class="hljs-string">&quot;/bin/sh&quot;</span>   <span class="hljs-number">5</span> days ago   Exited (<span class="hljs-number">137</span>) <span class="hljs-number">5</span> days ago             xyx<br>[root@rookie ~]# docker start xyx<br>xyx<br>[root@rookie ~]# docker inspect  xyx   # 找到存储的目录<br>[root@rookie ~]# <span class="hljs-keyword">cd</span> /var/lib/docker/overlay2/<span class="hljs-number">3</span>da71eb0eaa2667d371eec65f35c77485925ba08b53e1bd60d80068b6a709238/<br>[root@rookie <span class="hljs-number">3</span>da71eb0eaa2667d371eec65f35c77485925ba08b53e1bd60d80068b6a709238]# ls<br>diff  link  lower  merged  work<br>[root@rookie <span class="hljs-number">3</span>da71eb0eaa2667d371eec65f35c77485925ba08b53e1bd60d80068b6a709238]# ls merged/<br>bin  dev  etc  home  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span><br><br># 容器内添加内容 容器外数据同步添加<br>[root@rookie ~]#<span class="hljs-title"> docker</span> exec -ti<span class="hljs-title"> xyx</span> /bin/sh<br>/ #<span class="hljs-title"> touch</span> 123 <br>/ #<span class="hljs-title"> ls</span><br>123<span class="hljs-title">   bin</span> <span class="hljs-title">  dev</span> <span class="hljs-title">  etc</span> <span class="hljs-title">  home</span> <span class="hljs-title"> proc</span> <span class="hljs-title"> root</span> <span class="hljs-title"> sys</span> <span class="hljs-title">  tmp</span> <span class="hljs-title">  usr</span> <span class="hljs-title">  var</span><br>[root@rookie 3da71eb0eaa2667d371eec65f35c77485925ba08b53e1bd60d80068b6a709238]#<span class="hljs-title"> ls</span> merged/<br>123<span class="hljs-title">  bin</span> <span class="hljs-title"> dev</span> <span class="hljs-title"> etc</span> <span class="hljs-title"> home</span> <span class="hljs-title"> proc</span> <span class="hljs-title"> root</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span><br><br><br># 删除容器 容器外数据同步消失<br>/ #<span class="hljs-title"> exit</span><br>[root@rookie ~]#<span class="hljs-title"> docker</span> ps<span class="hljs-title"> </span><br><span class="hljs-title">CONTAINER</span> ID<span class="hljs-title">   IMAGE</span> <span class="hljs-title">    COMMAND</span> <span class="hljs-title">    CREATED</span> <span class="hljs-title">     STATUS</span> <span class="hljs-title">        PORTS</span> <span class="hljs-title">    NAMES</span><br>98b74ab02ea5<span class="hljs-title">   busybox</span>   &quot;/bin/sh&quot;   5<span class="hljs-title"> days</span> ago<span class="hljs-title">   Up</span> 7<span class="hljs-title"> minutes</span> <span class="hljs-title">            xyx</span><br>[root@rookie ~]#<span class="hljs-title"> docker</span> rm -f<span class="hljs-title"> xyx</span><br>xyx<br><br>[root@rookie 3da71eb0eaa2667d371eec65f35c77485925ba08b53e1bd60d80068b6a709238]#<span class="hljs-title"> ls</span> <br>[root@rookie 3da71eb0eaa2667d371eec65f35c77485925ba08b53e1bd60d80068b6a709238]#<span class="hljs-title"> ls</span> merged/<span class="hljs-title"></span><br><span class="hljs-title">ls:</span> 无法访问&#x27;merged/&#x27;: 没有那个文件或目录<br><br></code></pre></td></tr></table></figure><p><strong>用户绑定的卷（容器删除，数据依旧保留）</strong><br><code>docker run -it --name CONTAINER_NAME -v HOSTDIR:VOLUMEDIR IMAGE_NAME</code></p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment">#让真机上的b0test目录与容器内的data目录绑定</span><br>[[root@rookie ~]# docker run -it --name b0 -v /root/b0test:/data busybox <br>/ # ls<br>bin   data  dev   etc   home  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> sys</span> <span class="hljs-title">  tmp</span> <span class="hljs-title">  usr</span> <span class="hljs-title">  var</span><br>/ #<span class="hljs-title"> ls</span> /data/<br>[root@rookie ~]#<span class="hljs-title"> ls</span> b0test/<br><br>#真机写入文件 容器同步添加<br>[root@rookie ~]#<span class="hljs-title"> echo</span> &quot;nihao&quot; &gt;<span class="hljs-title"> b0test/123</span><br>[root@rookie ~]#<span class="hljs-title"> ls</span> b0test/<br>123<br>[root@rookie ~]#<span class="hljs-title"> cat</span> b0test/123<span class="hljs-title"> </span><br><span class="hljs-title">nihao</span><br><br>/ #<span class="hljs-title"> cat</span> /data/123<span class="hljs-title"> </span><br><span class="hljs-title">nihao</span><br><br><br>#容器内创建文件 退出并删除容器 真机文件保留<br>/ #<span class="hljs-title"> cd</span> data/<br>/data #<span class="hljs-title"> touch</span> xieyanxin <br>/data #<span class="hljs-title"> ls</span><br>123<span class="hljs-title">        xieyanxin</span><br>/data #<span class="hljs-title"> exit</span><br><br>[root@rookie ~]#<span class="hljs-title"> docker</span> rm<span class="hljs-title"> b0</span><br>b0<br>[root@rookie ~]#<span class="hljs-title"> docker</span> ps -a<span class="hljs-title"> </span><br><span class="hljs-title">CONTAINER</span> ID<span class="hljs-title">   IMAGE</span> <span class="hljs-title">    COMMAND</span> <span class="hljs-title">  CREATED</span> <span class="hljs-title">  STATUS</span> <span class="hljs-title">   PORTS</span> <span class="hljs-title">    NAMES</span><br><br>[root@rookie ~]#<span class="hljs-title"> ls</span> b0test/<br>123<span class="hljs-title">  xieyanxin</span><br><br></code></pre></td></tr></table></figure><h2 id="在容器中使用数据卷"><a href="#在容器中使用数据卷" class="headerlink" title="在容器中使用数据卷"></a>在容器中使用数据卷</h2><p><strong>下面部署一个网站（源码来自于源码之家），然后使用apache镜像创建一个b1容器，并创建一个数据卷<code>/root/b1test</code>挂载到容器的<code>/usr/loacl/apache2/htdocs</code>目录下：</strong></p><h3 id="准备好数据卷的网站内容"><a href="#准备好数据卷的网站内容" class="headerlink" title="准备好数据卷的网站内容"></a>准备好数据卷的网站内容</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#下载源码 并解压缩 创建好数据卷 并把网站文件放到此目录</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># ls</span><br>anaconda-ks.cfg  sayTheMoney.github.io-master.zip<br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># dnf -y install unzip</span><br><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># mkdir b1test</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># mv sayTheMoney.github.io-master/* b1test/</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># ls b1test/</span><br>服务器之家.url                        android-chrome<span class="hljs-number">-512</span>x512.png  favicon.ico<br>★★精品过期已备案域名，即买即用★★.url  apple-touch-icon.png        <span class="hljs-keyword">global</span>.css<br>精品免费商业源码下载.url              build                       index.html<br>★★★★香港免备案云主机★★★★.url          favicon<span class="hljs-number">-16</span>x16.png           site.webmanifest<br>android-chrome<span class="hljs-number">-192</span>x192.png            favicon<span class="hljs-number">-32</span>x32.png           thumbnail.png<br><br></code></pre></td></tr></table></figure><h3 id="运行容器-挂载一个主机目录作为数据卷，查看效果"><a href="#运行容器-挂载一个主机目录作为数据卷，查看效果" class="headerlink" title="运行容器 挂载一个主机目录作为数据卷，查看效果"></a>运行容器 挂载一个主机目录作为数据卷，查看效果</h3><ul><li>注意<br>①这里的-P是允许外部访问容器需要暴露的端口；<br>②本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@rookie ~]# docker run -d --name b1 -v <span class="hljs-regexp">/root/</span>b1test:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache2/</span>htdocs -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span>  httpd <br><span class="hljs-number">084</span>e3104515cd581ef8e1857c3f4ad1b0d45c9cd5c6e1002c1010f3d5cd86313<br>[root@rookie ~]# docker ps -a <br>CONTAINER ID   IMAGE     COMMAND              CREATED         STATUS         PORTS                               NAMES<br><span class="hljs-number">084</span>e3104515c   httpd     <span class="hljs-string">&quot;httpd-foreground&quot;</span>   <span class="hljs-number">7</span> seconds ago   Up <span class="hljs-number">6</span> seconds   <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">80</span>-&gt;<span class="hljs-number">80</span><span class="hljs-regexp">/tcp, :::80-&gt;80/</span>tcp   b1<br>[root@rookie ~]# ifconfig ens33<br>ens33: flags=<span class="hljs-number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="hljs-number">1500</span><br>        inet <span class="hljs-number">192.168</span>.<span class="hljs-number">177.101</span>  netmask <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>  broadcast <span class="hljs-number">192.168</span>.<span class="hljs-number">177.255</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>真机访问查看效果</strong><br><img src="https://img.darklorder.com/img/202308161627107.png"></li></ul><p>此功能在测试的时候非常方便，我们可以放置一些程序或数据到本地目录中，然后在容器内运行和使用。</p><h3 id="另一种只读的方式跑这个容器（网站）"><a href="#另一种只读的方式跑这个容器（网站）" class="headerlink" title="另一种只读的方式跑这个容器（网站）"></a>另一种只读的方式跑这个容器（网站）</h3><ul><li><strong>Docker挂载数据卷的默认权限是读写(rw)，用户也可以通过(ro)指定为只读：</strong></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 先把容器停掉删除</span><br>[root<span class="hljs-variable">@rookie</span> ~]<span class="hljs-comment"># docker stop b1</span><br>b1<br>[root<span class="hljs-variable">@rookie</span> ~]<span class="hljs-comment"># docker rm b1 </span><br>b1<br><span class="hljs-comment">#加上ro  指定为只读</span><br>[root<span class="hljs-variable">@rookie</span> ~]<span class="hljs-comment"># docker run -d --name b1 -v /root/b1test:/usr/local/apache2/htdocs:ro -p 80:80  httpd </span><br>fc106bac4858f65209b75b06adc970cc05b3451ddafb2a9cdc270ab49b312294<br><span class="hljs-comment">#进入容器 试着创建文件 测试效果（此时可以访问 但无法修改内容）</span><br>[root<span class="hljs-variable">@rookie</span> ~]<span class="hljs-comment"># docker exec -it b1 /bin/bash</span><br>root<span class="hljs-variable">@fc106bac4858</span><span class="hljs-symbol">:/usr/local/apache2</span><span class="hljs-comment"># cd htdocs/</span><br>root<span class="hljs-variable">@fc106bac4858</span><span class="hljs-symbol">:/usr/local/apache2/htdocs</span><span class="hljs-comment"># ls</span><br> android-chrome<span class="hljs-number">-192</span>x192.png<br> android-chrome<span class="hljs-number">-512</span>x512.png<br> apple-touch-icon.png<br> build<br> favicon<span class="hljs-number">-16</span>x16.png<br> favicon<span class="hljs-number">-32</span>x32.png<br> favicon.ico<br> global.css<br> index.html<br> site.webmanifest<br> <br><span class="hljs-comment">#提示为只读 </span><br>root<span class="hljs-variable">@fc106bac4858</span><span class="hljs-symbol">:/usr/local/apache2/htdocs</span><span class="hljs-comment"># touch 123</span><br><span class="hljs-symbol">touch:</span> cannot touch <span class="hljs-string">&#x27;123&#x27;</span>: <span class="hljs-title class_">Read</span>-only file system  <br><br><span class="hljs-comment">#但容器外可以修改 且容器内数据也同步</span><br>[root<span class="hljs-variable">@rookie</span> ~]<span class="hljs-comment"># cd b1test/</span><br>[root<span class="hljs-variable">@rookie</span> b1test]<span class="hljs-comment"># touch xyx</span><br>[root<span class="hljs-variable">@rookie</span> b1test]<span class="hljs-comment"># ls </span><br>服务器之家.url                        favicon<span class="hljs-number">-16</span>x16.png<br>★★精品过期已备案域名，即买即用★★.url  favicon<span class="hljs-number">-32</span>x32.png<br>精品免费商业源码下载.url              favicon.ico<br>★★★★香港免备案云主机★★★★.url          global.css<br>android-chrome<span class="hljs-number">-192</span>x192.png            index.html<br>android-chrome<span class="hljs-number">-512</span>x512.png            site.webmanifest<br>apple-touch-icon.png                  thumbnail.png<br>build                                 xyx<br><br>root<span class="hljs-variable">@fc106bac4858</span><span class="hljs-symbol">:/usr/local/apache2/htdocs</span><span class="hljs-comment"># ls</span><br> android-chrome<span class="hljs-number">-192</span>x192.png<br> android-chrome<span class="hljs-number">-512</span>x512.png<br> apple-touch-icon.png<br> build<br> favicon<span class="hljs-number">-16</span>x16.png<br> favicon<span class="hljs-number">-32</span>x32.png<br> favicon.ico<br> global.css<br> index.html<br> site.webmanifest<br> thumbnail.png<br> xyx <br><br></code></pre></td></tr></table></figure><p><strong>加了:ro以后，外部可以修改数据，但容器内挂载的数据卷的数据就无法修改了。</strong></p><h3 id="挂载一个本地主机文件作为数据卷（不常用，通常是目录）"><a href="#挂载一个本地主机文件作为数据卷（不常用，通常是目录）" class="headerlink" title="挂载一个本地主机文件作为数据卷（不常用，通常是目录）"></a>挂载一个本地主机文件作为数据卷（不常用，通常是目录）</h3><p>-v选项也可以从主机挂载单个文件到容器中作为数据卷：<br>[root@rookie ~]# docker run -it –rm -v ~&#x2F;.bash_history:&#x2F;.bash_history centos &#x2F;bin&#x2F;bash</p><p>这样就可以记录在容器输入过的命令历史了。<br>如果直接挂载一个文件到容器，使用文件编辑工具，包括vi或者sed去修改文件内容的时候，可能会造成inode的改变，这样将会导致错误。所以<strong>推荐的方式是直接挂载文件所在的目录。</strong></p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要在容器之间共享一些持续更新的数据，可以使用数据卷容器。<strong>数据卷容器本质上还是一个普通的容器，但它可以用来专门提供数据卷 供其他容器挂载使用</strong>，方法如下：</p><ul><li><strong>①首先，创建一个数据卷容器xieyanxin ，并在其中创建一个数据卷挂载到&#x2F;dbdata：</strong></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@rookie ~</span>]<span class="hljs-meta"># docker run -itd --name xieyanxin -v /dbdata  busybox </span><br>b61ed4bf69e479a7cc45e5b0c7b2f10e7f4ad24c5ebacd1cc3a2947c0223be3f<br>[<span class="hljs-meta">root@rookie ~</span>]<span class="hljs-meta"># docker ps</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES<br>b61ed4bf69e4   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">3</span> seconds ago   Up <span class="hljs-number">2</span> seconds             xieyanxin<br><br><span class="hljs-meta"># 查看xieyanxin容器的dbdata目录是否存在</span><br>[<span class="hljs-meta">root@rookie ~</span>]<span class="hljs-meta"># docker exec -it xieyanxin /bin/sh</span><br>/ <span class="hljs-meta"># ls</span><br>bin     dev     home    root    tmp     <span class="hljs-keyword">var</span><br>dbdata  etc     proc    sys     usr<br><br><br></code></pre></td></tr></table></figure><ul><li><strong>②然后可以在其他容器中使用–volumes-from来挂载dbdata容器中的数据卷，例如创建xiaoxie1和xiaoxie2两个容器，并从xieyanxin容器挂载数据卷：</strong></li></ul><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tcl">[root@rookie ~]# docker run -itd --name xiaoxie2 --volumes-from xieyanxin busybox<br><span class="hljs-number">468</span>d1f865f3d0859ba468c8c0bbb751a07eb2703ae09c4cdd0915a8746a71b56<br>[root@rookie ~]# docker run -itd --name xiaoxie1 --volumes-from xieyanxin busybox<br>e301456fbb2298310bd2a741c6186c800e6e53ffe12dbb42824cba854d0c4ad3<br>[root@rookie ~]# docker ps -a<br>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES<br>e301456fbb22   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">6</span> seconds ago    Up <span class="hljs-number">5</span> seconds              xiaoxie1<br><span class="hljs-number">468</span>d1f865f3d   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">11</span> seconds ago   Up <span class="hljs-number">10</span> seconds             xiaoxie2<br>b61ed4bf69e4   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">4</span> minutes ago    Up <span class="hljs-number">4</span> minutes              xieyanxin<br><br><span class="hljs-comment"># 容器xiaoxie1和xiaoxie2都挂载同一个数据卷到相同的/dbdata目录</span><br>[root@rookie b1test]# docker <span class="hljs-keyword">exec</span> -it xiaoxie1 /bin/sh<br>/ # ls<br>bin     dev     home    root    tmp     var<br>dbdata  etc     <span class="hljs-keyword">proc</span><span class="hljs-title">    sys</span> <span class="hljs-title">    usr</span><br>[root@rookie ~]#<span class="hljs-title"> docker</span> exec -it<span class="hljs-title"> xiaoxie2</span> /bin/sh<br>/ #<span class="hljs-title"> ls</span><br>bin<span class="hljs-title">     dev</span> <span class="hljs-title">    home</span> <span class="hljs-title">   root</span> <span class="hljs-title">   tmp</span> <span class="hljs-title">    var</span><br>dbdata<span class="hljs-title">  etc</span> <span class="hljs-title">    proc</span> <span class="hljs-title">   sys</span> <span class="hljs-title">    usr</span><br><br></code></pre></td></tr></table></figure><p>也<strong>正是因为容器xiaoxie1和xiaoxie2都挂载同一个数据卷到相同的&#x2F;dbdata目录，xieyanxin，iaoxie1，xiaoxie2这三个容器任何一方在该目录下的写入，其他容器都可以看到</strong>。</p><p>例如，在xiaoxie1容器中创建一个guaguagua文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ <span class="hljs-comment"># cd /dbdata/</span><br>/dbdata <span class="hljs-comment"># echo &quot;nishihangua&quot; &gt; guaguagua</span><br>/dbdata <span class="hljs-comment"># ls</span><br>guaguagua<br></code></pre></td></tr></table></figure><p>在xieyanxin容器中查看：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@rookie ~</span>]<span class="hljs-meta"># docker exec -it xieyanxin /bin/sh</span><br>/ <span class="hljs-meta"># ls</span><br>bin     dev     home    root    tmp     <span class="hljs-keyword">var</span><br>dbdata  etc     proc    sys     usr<br>/ <span class="hljs-meta"># cat /dbdata/guaguagua </span><br>nishihangua<br></code></pre></td></tr></table></figure><ul><li><strong>③可以多次使用–volumes-from参数来从多个容器挂载多个数据卷。还可以从其他已挂载了容器卷的容器来挂载数据卷：</strong></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#xiaoxie999容器以xiaoxie1容器挂载数据卷  </span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker run -itd --name  xiaoxie999 --volumes-from xiaoxie1 busybox</span><br><span class="hljs-number">8</span>de8ea4edfdda1cac392e6e9c854ef3037af3c76b5ed2821915d5346b0bae638<br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES<br><span class="hljs-number">8</span>de8ea4edfdd   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">5</span> seconds ago    Up <span class="hljs-number">3</span> seconds              xiaoxie999<br>e301456fbb22   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">16</span> minutes ago   Up <span class="hljs-number">16</span> minutes             xiaoxie1<br><span class="hljs-number">468</span>d1f865f3d   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">16</span> minutes ago   Up <span class="hljs-number">16</span> minutes             xiaoxie2<br>b61ed4bf69e4   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">21</span> minutes ago   Up <span class="hljs-number">21</span> minutes             xieyanxin<br><br><span class="hljs-meta">#进入xiaoxie999容器创建 内容 ，到xieyanxin容器查看 </span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker exec -it xiaoxie999 /bin/sh</span><br>/ <span class="hljs-meta"># ls /dbdata/</span><br>guaguagua<br>/ <span class="hljs-meta"># cd /dbdata/</span><br>/dbdata <span class="hljs-meta"># echo <span class="hljs-string">&quot;xiaoxie999laila&quot;</span> &gt; 999</span><br>/dbdata <span class="hljs-meta"># ls</span><br><span class="hljs-number">999</span>        guaguagua<br>/dbdata <span class="hljs-meta"># exit</span><br><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker exec -it xieyanxin /bin/sh</span><br>/ <span class="hljs-meta"># cat /dbdata/999 </span><br>xiaoxie999laila<br></code></pre></td></tr></table></figure><ul><li><strong>④使用–volumes-from参数所挂载数据卷的容器自身并不需要保持在运行状态。</strong></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#停掉xieyanxin容器的运行状态</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker stop xieyanxin</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                        PORTS     NAMES<br><span class="hljs-number">8</span>de8ea4edfdd   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">7</span> minutes ago    Up <span class="hljs-number">7</span> minutes                            xiaoxie999<br>e301456fbb22   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">23</span> minutes ago   Up <span class="hljs-number">23</span> minutes                           xiaoxie1<br><span class="hljs-number">468</span>d1f865f3d   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">23</span> minutes ago   Up <span class="hljs-number">23</span> minutes                           xiaoxie2<br>b61ed4bf69e4   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">28</span> minutes ago   Exited (<span class="hljs-number">137</span>) <span class="hljs-number">44</span> seconds ago             xieyanxin  <span class="hljs-meta"># xieyanxin已停止</span><br><br><span class="hljs-meta">#去xiaoxie2查看 然后创建一个文件</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker exec -it xiaoxie2 /bin/sh</span><br>/ <span class="hljs-meta"># cd /dbdata/</span><br>/dbdata <span class="hljs-meta"># ls</span><br><span class="hljs-number">999</span>        guaguagua<br>/dbdata <span class="hljs-meta"># touch xiaoxie111</span><br>/dbdata <span class="hljs-meta"># ls</span><br><span class="hljs-number">999</span>         guaguagua   xiaoxie111<br>/dbdata <span class="hljs-meta"># exit</span><br><br><span class="hljs-meta">#去xiaoxie1查看 数据依旧是同步的</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker exec -it xiaoxie1 /bin/sh</span><br>/ <span class="hljs-meta"># ls /dbdata/</span><br><span class="hljs-number">999</span>         guaguagua   xiaoxie111<br></code></pre></td></tr></table></figure><ul><li>⑤如果删除了挂载的容器（包括xieyanxin、xiaoxie1和xiaoxie2），数据卷并不会被自动删除。<strong>如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</strong></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#删除xieyanxin并确认</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker rm -f xieyanxin</span><br>xieyanxin<br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES<br><span class="hljs-number">8</span>de8ea4edfdd   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">15</span> minutes ago   Up <span class="hljs-number">14</span> minutes             xiaoxie999<br>e301456fbb22   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">31</span> minutes ago   Up <span class="hljs-number">31</span> minutes             xiaoxie1<br><span class="hljs-number">468</span>d1f865f3d   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">31</span> minutes ago   Up <span class="hljs-number">31</span> minutes             xiaoxie2<br><br><span class="hljs-meta"># 去xiaoxie1 xiaoxie2 查看 数据卷关系依然存在</span><br>[root<span class="hljs-symbol">@rookie</span> b1test]<span class="hljs-meta"># docker exec -it xiaoxie1 /bin/sh</span><br>/ <span class="hljs-meta">#  cd /dbdata/</span><br>/dbdata <span class="hljs-meta"># touch xixi</span><br><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker exec -it xiaoxie2 /bin/sh</span><br>/ <span class="hljs-meta"># cd /dbdata/</span><br>/dbdata <span class="hljs-meta"># ls</span><br><span class="hljs-number">999</span>         guaguagua   xiaoxie111  xixi<br><br><span class="hljs-meta">#删除全部容器 只保留xiaoxie999</span><br> [root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES<br><span class="hljs-number">8</span>de8ea4edfdd   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">15</span> minutes ago   Up <span class="hljs-number">14</span> minutes             xiaoxie999<br>e301456fbb22   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">31</span> minutes ago   Up <span class="hljs-number">31</span> minutes             xiaoxie1<br><span class="hljs-number">468</span>d1f865f3d   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">31</span> minutes ago   Up <span class="hljs-number">31</span> minutes             xiaoxie2<br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker rm -f xiaoxie1</span><br>xiaoxie1<br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker rm -f xiaoxie2</span><br>xiaoxie2<br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES<br><span class="hljs-number">8</span>de8ea4edfdd   busybox   <span class="hljs-string">&quot;sh&quot;</span>      <span class="hljs-number">17</span> minutes ago   Up <span class="hljs-number">17</span> minutes             xiaoxie999<br><br><span class="hljs-meta">#找到xiaoxie999对应在真机上的目录</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker inspect xiaoxie999</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># cd /var/lib/docker/volumes/b1622bf1ecdac3cd92f938c8958b32ba93535a000befc0a913431f650ba810e2/_data</span><br>[root<span class="hljs-symbol">@rookie</span> _data]<span class="hljs-meta"># ls</span><br><span class="hljs-number">999</span>  guaguagua  xiaoxie111  xixi<br><br><span class="hljs-meta">#用docker rm（不加v）删除容器，在真机的目录上数据还是在</span><br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker rm -f xiaoxie999</span><br>xiaoxie999<br>[root<span class="hljs-symbol">@rookie</span> ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[root<span class="hljs-symbol">@rookie</span> _data]<span class="hljs-meta"># ls</span><br><span class="hljs-number">999</span>  guaguagua  xiaoxie111  xixi<br></code></pre></td></tr></table></figure><ul><li>用docker rm（不加v）删除数据卷容器时，数据依旧会保留 ，想要全部删除也很简单 ，docker rm -vm 命令指定删除的容器，全部删除就可以了。</li></ul><p><strong>参考资料</strong><br><a href="https://blog.csdn.net/m0_67758799/article/details/124512038">容器存储卷的介绍与使用_容器云 存储卷_先饮乌龙茶的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker镜像</title>
    <link href="/2022/09/06/Docker-Images/"/>
    <url>/2022/09/06/Docker-Images/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="Docker-Images"><a href="#Docker-Images" class="headerlink" title="Docker Images"></a>Docker Images</h3><p>运行容器时，基于Mount名称空间建立的隔离文件系统中的内容来自镜像</p><ul><li><p>Docker镜像是一个特殊的文件系统，它必须包含运行应用程序所需的一切——所有依赖项、配置、脚本、二进制文件等</p></li><li><p>镜像还包含容器的其他配置，例如环境变量、要运行的默认命令、和其他元数据</p></li><li><p>通常，镜像还要定义默认启动的应用</p></li></ul><p>Docker镜像由许多层（Layer）叠加而成</p><ul><li>依赖于特殊的存储驱动，例如aufs (高级联合文件系统)、devicemapper (centos又丑又笨)、overlay2等</li><li></li><li>尽管每种存储驱动程序实现的管理方式不尽相同，但它们都使用可堆叠的镜像层和写时复制（CoW）策略</li></ul><img src="https://img.darklorder.com/img/202111292153842.png" style="zoom:50%;" /><h3 id="Docker-Image-Layer"><a href="#Docker-Image-Layer" class="headerlink" title="Docker Image Layer"></a>Docker Image Layer</h3><p>位于下层的镜像称为父镜像(parent image)，最底层的称为基础镜像(base image)</p><p>最上层为“可读写”层，其下的均为“只读”层</p><img src="https://img.darklorder.com/img/202111281644358.jpeg" alt="See the source image" style="zoom: 80%;" /><h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>Registry是一个无状态、高度可扩展的服务器端应用程序，用于存储和分发Docker images。</p><img src="https://img.darklorder.com/img/202111281711188.png"/><p>Registry上的镜像存储于“仓库（Repository）”中，仓库可隶属于根名称空间或特定的名称空间</p><ul><li><p>每个镜像由“仓库名:标签名”标识</p></li><li><p>也可由镜像的Hash码标识</p></li></ul><table><thead><tr><th>Namespaces</th><th>Examples (<namespace>&#x2F;<name>)</th></tr></thead><tbody><tr><td>organization</td><td>readhat&#x2F;kubernetes，google&#x2F;kubernetes</td></tr><tr><td>login (user name)</td><td>alice&#x2F;application，bob&#x2F;application</td></tr><tr><td>role</td><td>devel&#x2F;database，test&#x2F;database，prod&#x2F;database</td></tr></tbody></table><p>Docker Registry中的镜像通常由开发人员制作，而后推送至“公共”或“私有”Registry上保存，供其他人员使用，例如“部署”到生产环境；</p><img src="https://img.darklorder.com/img/202111281721319.jpeg" alt="img" style="zoom: 80%;" /><p><strong>容器配置变更的几种方式</strong></p><ul><li><p>重新打镜像：Hard Coding（硬编码）</p></li><li><p>存储卷：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf –&gt; &#x2F;data&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</p></li><li><p>环境变量：entrypoint.sh</p></li><li><p>配置中心：appollo nacoss</p></li></ul><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><h3 id="什么是镜像层？"><a href="#什么是镜像层？" class="headerlink" title="什么是镜像层？"></a>什么是镜像层？</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。</p><p>每个镜像都由多个镜像层组成。这些镜像层都是只读的，从下往上，以栈的方式组合在一起，组成镜像的根文件系统。</p><h3 id="什么是容器层？"><a href="#什么是容器层？" class="headerlink" title="什么是容器层？"></a>什么是容器层？</h3><p>当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作容器层（Container layer），容器层之下的都叫镜像层（Image layers）。所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。</p><p>每个容器运行时都有自己的容器层，保存容器运行相关数据（所有文件变化数据），因为镜像层是只读的，所以多个容器可以共享同一个镜像。删除容器时，Docker Daemon会删除容器层，保留镜像层。</p><h3 id="各种ID的含义"><a href="#各种ID的含义" class="headerlink" title="各种ID的含义"></a>各种ID的含义</h3><h4 id="imageID"><a href="#imageID" class="headerlink" title="imageID"></a>imageID</h4><p>镜像的唯一标识，其数值根据该镜像的元数据配置文件采用sha256算法的计算获得。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@iZbp1bum6107bp8mgzkeunZ</span> ~]<span class="hljs-meta"># docker image inspect nginx | jq <span class="hljs-string">&quot;.[0].Id&quot;</span></span><br><span class="hljs-string">&quot;sha256:12766a6745eea133de9fdcd03ff720fa971fdaf21113d4bc72b417c123b15619&quot;</span><br></code></pre></td></tr></table></figure><h4 id="chainID"><a href="#chainID" class="headerlink" title="chainID"></a>chainID</h4><p>Docker内容寻址机制采用的索引ID，docker image inspect <image_id>查到的 RootFS 的 ID 都是 chainID， 每一个镜像的 RootFS 的最低层的 chainID 都可以在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;sha256&#x2F;目录下找到对应的文件夹。<br>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;sha256&#x2F;{chainID}目录下可以找到cacheID和diffID</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@iZbp1bum6107bp8mgzkeunZ ~]# docker image <span class="hljs-keyword">inspect</span> nginx | jq <span class="hljs-string">&quot;.[0].RootFS&quot;</span><br>&#123;<br>  <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;layers&quot;</span>,<br>  <span class="hljs-string">&quot;Layers&quot;</span>: [<br>    <span class="hljs-string">&quot;sha256:608f3a074261105f129d707e4d9ad3d41b5baa94887f092b7c2857f7274a2fce&quot;</span>,<br>    <span class="hljs-string">&quot;sha256:ea207a4854e73eca698e94f323fadb920bbc5fc2af83d4bda9f47fd33fa1a076&quot;</span>,<br>    <span class="hljs-string">&quot;sha256:33cf1b723f65c22ccc4660c44fe8b919b75e7bb9ffcfe80432bb75363be34a5b&quot;</span>,<br>    <span class="hljs-string">&quot;sha256:5c77d760e1f430188e860d79c2f4efa0f082f6831046e5584810bc5ead42dc5d&quot;</span>,<br>    <span class="hljs-string">&quot;sha256:fac199a5a1a59d93dd9b23d4c3445c39070ce0d94f94def585085476f89610cf&quot;</span>,<br>    <span class="hljs-string">&quot;sha256:ea4bc0cd4a9350584676b6aa3669984eb614f559229c11dc56a85140b49f0228&quot;</span><br>  ]<br>&#125;<br><br>[root@iZbp1bum6107bp8mgzkeunZ ~]# ls <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/im</span>age<span class="hljs-regexp">/overlay2/</span>layerdb<span class="hljs-regexp">/sha256/</span> | <span class="hljs-keyword">grep</span> <span class="hljs-number">608</span>f3a074261105f129d707e4d9ad3d41b5baa94887f092b7c2857f7274a2fce<br><span class="hljs-number">608</span>f3a074261105f129d707e4d9ad3d41b5baa94887f092b7c2857f7274a2fce<br><br>[root@iZbp1bum6107bp8mgzkeunZ ~]# ls <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/im</span>age<span class="hljs-regexp">/overlay2/</span>layerdb<span class="hljs-regexp">/sha256/</span><span class="hljs-number">608</span>f3a074261105f129d707e4d9ad3d41b5baa94887f092b7c2857f7274a2fce<br>cache-id  diff  <span class="hljs-keyword">size</span>  tar-split.json.gz<br></code></pre></td></tr></table></figure><h4 id="cacheID"><a href="#cacheID" class="headerlink" title="cacheID"></a>cacheID</h4><p>由宿主机随即生成的一个uuid，存放于&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;sha256&#x2F;{chainID}&#x2F;cache-id文件中（容器层不会有 cacheID），每一个 cacheID 都对应着一个镜像层，每一个 cacheID 对应着&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;${cache-id}目录</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@iZbp1bum6107bp8mgzkeunZ ~]# cat <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/im</span>age<span class="hljs-regexp">/overlay2/</span>layerdb<span class="hljs-regexp">/sha256/</span><span class="hljs-number">085831</span>b1436186cd069fbc921d93064bfe0f119cb99fb41360e20d004824e4a0/cache-id &amp;&amp; echo<br><span class="hljs-number">1710201</span>f3395fe390c5ddcd9a735654da29f2cfa77eb7263a98ed4ac73abe14f<br>[root@iZbp1bum6107bp8mgzkeunZ ~]# ls <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>overlay2/<span class="hljs-number">1710201</span>f3395fe390c5ddcd9a735654da29f2cfa77eb7263a98ed4ac73abe14f<br>committed  diff  link  lower  work<br></code></pre></td></tr></table></figure><h4 id="diffID"><a href="#diffID" class="headerlink" title="diffID"></a>diffID</h4><p>镜像层校验ID，是根据该镜像层的打包文件校验获得。存放于&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;sha256&#x2F;{chainID}&#x2F;diff。diffID 采用 SHA256 算法，基于镜像层文件包的内容计算得到。而 chainID 是基于内容存储的索引，它是根据当前层与所有上层镜像层的diffID计算出来的。</p><h4 id="containerID"><a href="#containerID" class="headerlink" title="containerID"></a>containerID</h4><p>容器的唯一标识，每一个容器对应一个&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;{container_id}目录。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@iZbp1bum6107bp8mgzkeunZ ~]# docker <span class="hljs-keyword">inspect</span> `docker ps | <span class="hljs-keyword">grep</span> nginx-hostname | awk <span class="hljs-string">&#x27;&#123;print$1&#125;&#x27;</span>` | jq <span class="hljs-string">&quot;.[0].Id&quot;</span><br><span class="hljs-string">&quot;e38891c4d9a6b2ca9048db18e12bd2b05fa3a8d68687ea7acedab288bebf6441&quot;</span><br>[root@iZbp1bum6107bp8mgzkeunZ ~]# ls -l <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>containers | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;e38891c4d9a6b2ca9048db18e12bd2b05fa3a8d68687ea7acedab288bebf6441&quot;</span><br>drwx--x--- <span class="hljs-number">4</span> root root <span class="hljs-number">4096</span> Nov  <span class="hljs-number">1</span> <span class="hljs-number">23</span>:<span class="hljs-number">52</span> e38891c4d9a6b2ca9048db18e12bd2b05fa3a8d68687ea7acedab288bebf6441<br></code></pre></td></tr></table></figure><h3 id="镜像的存储和管理方式"><a href="#镜像的存储和管理方式" class="headerlink" title="镜像的存储和管理方式"></a>镜像的存储和管理方式</h3><h4 id="镜像的设计"><a href="#镜像的设计" class="headerlink" title="镜像的设计"></a>镜像的设计</h4><p>一个镜像都由多个镜像层组成。</p><p>为了区别镜像层，Docker为每个镜像层都计算了UUID，根据镜像层中的数据使用加密哈希算法生成UUID。</p><p>所有镜像层和容器层都保存在宿主机的文件系统&#x2F;var&#x2F;lib&#x2F;docker&#x2F;中，由存储驱动进行管理。</p><p>在下载镜像时，Docker Daemon会检查镜像中的镜像层与宿主机文件系统中的镜像层进行对比，如果存在则不下载，只下载不存在的镜像层。</p><img src="https://img.darklorder.com/img/202308111424196.png"/><h4 id="栈层式管理镜像层"><a href="#栈层式管理镜像层" class="headerlink" title="栈层式管理镜像层"></a>栈层式管理镜像层</h4><p>docker 中存储驱动用于管理镜像层和容器层。不同的存储驱动使用不同的算法和管理方式。在容器和镜像管理中，使用的两大技术是<strong>栈式层管理和写时复制。</strong></p><p>Dockerfile中的每一条指令都会对应于Docker镜像中的一层，因此在docker build完毕之后，镜像的总大小将等于每一层镜像的大小总和。</p><p>每个镜像都由多个镜像层组成，从下往上以栈的方式组合在一起形成容器的根文件系统，Docker的存储驱动用于管理这些镜像层，对外提供单一的文件系统。Docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫 UnionFS（联合文件系统）。</p><blockquote><p><strong>由于联合文件系统的存在，容器文件系统内容的大小不等于Docker镜像大小。</strong></p><img src="https://img.darklorder.com/img/202308111429367.png"/><p>由于联合文件系统的存在，如果镜像层是相同的，则不同的镜像会共享该层。</p><p>如上图中，镜像A与镜像B就共享第二层镜像，使得A+B镜像文件大小并不等于A+B镜像占用宿主机存储空间容量的大小。</p><p>doker images命令列出的镜像体积总和并不能代表实际使用的磁盘空间，需要使用docker system df命令来代替。</p></blockquote><h4 id="UnionFS-（联合文件系统）"><a href="#UnionFS-（联合文件系统）" class="headerlink" title="UnionFS （联合文件系统）"></a>UnionFS （联合文件系统）</h4><p>联合文件系统（UnionFS）是一种<strong>分层</strong>、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p><blockquote><p><strong>分层的原因：</strong></p><p>分层最大的一个好处就是共享资源</p><p>有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像；</p><p>同时内存中也只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享。</p></blockquote><p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><blockquote><p>如图，在下载镜像时，也是一层一层下载的</p><img src="https://img.darklorder.com/img/202308111433968.png"/></blockquote><h3 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h3><p>要了解docker的镜像结构，需要先对linux的文件系统结构有所了解。</p><h4 id="linux文件系统结构"><a href="#linux文件系统结构" class="headerlink" title="linux文件系统结构"></a>linux文件系统结构</h4><p>Linux 文件系统由 bootfs和 rootfs 两部分组成。</p><p>bootfs(boot file system) 主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel(内核)，当 kernel 被加载到内存中后 bootfs 就被 umount (卸载)了。</p><p>rootfs (root file system) 包含的就是典型 Linux 系统中的 &#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件。rootfs就是各种Linux发行版。比如redcat、centOS。</p><img src="https://img.darklorder.com/img/202308111435559.png" style="zoom: 80%;" /><p><strong>docker镜像结构</strong></p><img src="https://img.darklorder.com/img/202111281644358.jpeg" alt="See the source image" style="zoom: 80%;" /><p>docker的分层镜像结构如图所示，镜像的最底层必须是一个启动文件系统（bootfs）的镜像层。bootfs的上层镜像称为根镜像（rootfs）或者基础镜像（Base Image），它一般是操作系统，比如centos、debian或者Ubuntu。</p><p>用户的镜像必须构建在基础镜像之上。如图所示， emacs镜像层就是在基础镜像上安装emacs创建出来的镜像，在此基础上安装apache又创建了新的镜像层。利用这个新的镜像层启动的容器里运行的是一个已经安装好emacs和apache的Debian系统。</p><h4 id="docker镜像分层的理解"><a href="#docker镜像分层的理解" class="headerlink" title="docker镜像分层的理解"></a>docker镜像分层的理解</h4><p>查看镜像分层方式可以通过docker image inspect [IMAGE] 命令。其中RootFS部分则是表示了分层信息。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@iZbp1bum6107bp8mgzkeunZ ~]<span class="hljs-comment"># docker image inspect redis</span><br>[<br>    &#123;<br>        <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;sha256:53aa81e8adfa939348cd4c846c0ab682b16dc7641714e36bfc57b764f0b947dc&quot;</span>,<br>        <span class="hljs-string">...</span><br>        <span class="hljs-string">...</span><br>        <span class="hljs-string">&quot;RootFS&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;layers&quot;</span>,<br>            <span class="hljs-string">&quot;Layers&quot;</span>: [<br>                <span class="hljs-string">&quot;sha256:ad6562704f3759fb50f0d3de5f80a38f65a85e709b77fd24491253990f30b6be&quot;</span>,<br>                <span class="hljs-string">&quot;sha256:49cba0f0997b2bb3a24bcfe71c7cbd6e9f6968ef7934e3ad56b0f1f9361b6b91&quot;</span>,<br>                <span class="hljs-string">&quot;sha256:309498e524b3e2da1f036d00cd5155e0b74cf9e1d964a3636c8ed63ca4a00d43&quot;</span>,<br>                <span class="hljs-string">&quot;sha256:f7c9b429437f7ada2d3d455ac4ea90ff38e0cb7ef2551b08d152264b74116309&quot;</span>,<br>                <span class="hljs-string">&quot;sha256:4dabdd56bbf16307e2328cb6ed1d42b0bb9b8f40551421271c0b38dc9a685dcc&quot;</span>,<br>                <span class="hljs-string">&quot;sha256:ea450ad6ef893e998f88a35dc9cc22f952c62b88d58f948344cf4eda1a6264fc&quot;</span><br>            ]<br>        &#125;,<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>所有的Docker镜像都起始于一个基础镜像层，当镜像修改或者新增新的内容时，就会在当前镜像层之上，创建新的镜像层。<strong>即在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。</strong> docker通过存储引擎（新版本采用快照机制）的方式实现镜像层堆栈，并保证多个镜像层对外展示为统一的文件系统。示例：</p><img src="https://img.darklorder.com/img/202308111438925.png"/><p>这个镜像中包含了三个镜像层，第一层有三个文件，第二层也有三个文件，第三层镜像中仅有一个文件，且这个文件是对第二层镜像中的文件5的一个更新版本。在这种情况下，上层镜像层中的文件会覆盖底层镜像层的文件，这样就使得文件的更新版本作为一个新的镜像层添加到镜像当中。</p><p>最后docker通过存储引擎将所有镜像层堆叠并合并，对外提供统一的视图。</p><img src="https://img.darklorder.com/img/202308111439188.png"/><p>Dockerfile中的操作对于镜像分层的影响：<strong>在镜像构建过程中需要向镜像写入数据的时候会产生分层，一个写操作指令产生一个分层。</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 实例，验证Dockerfile中的操作对于镜像分层的影响<br><br><span class="hljs-regexp">//</span> 第一步，简单编写一个Dockerfile，复制宿主机的文件到容器中，并且RUN 执行相关命令<br>[root@iZbp1bum6107bp8mgzkeunZ test]<span class="hljs-comment"># cat Dockerfile</span><br>FROM centos:<span class="hljs-number">7</span><br> <span class="hljs-comment"># 写指令-COPY、RUN</span><br>COPY * <span class="hljs-regexp">/root/</span>test/                   <br>RUN touch <span class="hljs-regexp">/etc/</span>pidstst.log \<br>    &amp;&amp; yum -y install sysstat<br>CMD <span class="hljs-regexp">/root/</span>test/process.sh<br><br><span class="hljs-regexp">//</span> 第二步，创建镜像<br>[root@iZbp1bum6107bp8mgzkeunZ test]<span class="hljs-comment"># docker build -f Dockerfile -t test .</span><br>Sending build context to Docker daemon  <span class="hljs-number">4.096</span>kB<br>Step <span class="hljs-number">1</span>/<span class="hljs-number">4</span> : FROM centos:<span class="hljs-number">7</span><br> ---&gt; eeb6ee3f44bd<br>Step <span class="hljs-number">2</span><span class="hljs-regexp">/4 : COPY * /</span>root<span class="hljs-regexp">/test/</span><br> ---&gt; <span class="hljs-number">897</span>bd9a5ead0<br>Step <span class="hljs-number">3</span><span class="hljs-regexp">/4 : RUN  touch /</span>etc/pidstst.log     &amp;&amp; yum -y install sysstat<br> ---&gt; Running <span class="hljs-keyword">in</span> <span class="hljs-number">4</span>b90b3c273b0<br>Step <span class="hljs-number">4</span><span class="hljs-regexp">/4 : CMD /</span>root<span class="hljs-regexp">/test/</span>test.sh<br> ---&gt; Running <span class="hljs-keyword">in</span> dd115ea2e7f7<br>Removing intermediate container dd115ea2e7f7<br> ---&gt; <span class="hljs-number">205226</span>fedbc6<br>Successfully built <span class="hljs-number">205226</span>fedbc6<br>Successfully tagged test:latest<br><br><span class="hljs-regexp">//</span> 查看创建的镜像<br>[root@iZbp1bum6107bp8mgzkeunZ docker]<span class="hljs-comment"># docker images</span><br>REPOSITORY           TAG       IMAGE ID       CREATED          SIZE<br>test                 latest    <span class="hljs-number">205226</span>fedbc6   <span class="hljs-number">12</span> minutes ago   <span class="hljs-number">407</span>MB<br><br><span class="hljs-regexp">//</span> 查看该镜像的分层结构信息<br><span class="hljs-regexp">//</span> 所有的Docker镜像都起始于一个基础镜像层，因此第一个layer为dockerfile中指定的基础镜像层<br><span class="hljs-regexp">//</span> 然后dockerfile中有多少个写指令，就会有多少个lay。 这里是三个layer，跟dockerfile中刚好对应上。<br>[root@iZbp1bum6107bp8mgzkeunZ docker]<span class="hljs-comment"># docker image inspect 205226fedbc6</span><br>...<br><span class="hljs-string">&quot;RootFS&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;layers&quot;</span>,<br>    <span class="hljs-string">&quot;Layers&quot;</span>: [<br>        <span class="hljs-string">&quot;sha256:174f5685490326fc0a1c0f5570b8663732189b327007e47ff13d2ca59673db02&quot;</span>,<br>        <span class="hljs-string">&quot;sha256:114bd86a861ccc7b8fcc9c5702529d3e2df0fa7ad3e753e0ad072362db417e7c&quot;</span>,<br>        <span class="hljs-string">&quot;sha256:9759cbc1af5e6651027f437b3e902ab08725eda7fcf16cdeb5acc45cefb90a5b&quot;</span><br>    ]<br>&#125;<br>...<br></code></pre></td></tr></table></figure><h3 id="写时复制策略（Copy-On-Write）"><a href="#写时复制策略（Copy-On-Write）" class="headerlink" title="写时复制策略（Copy On Write）"></a>写时复制策略（Copy On Write）</h3><blockquote><p>当某个容器修改了基础镜像的内容，比如 &#x2F;bin文件夹下的文件，这时其他容器的&#x2F;bin文件夹是否会发生变化呢？</p><p>答案是不会的。根据容器镜像的写时复制（Copy-on-Write）技术，某个容器对基础镜像的修改会被限制在单个容器内。</p></blockquote><p>写时复制策略采用了共享和复制技术，<strong>针对相同的数据系统只保留一份，所有操作都访问这一份数据。</strong> 当有操作需要修改或添加数据时，操作系统会把这部分数据复制到新的地方再进行修改或添加，而其他操作仍然访问原数据区数据，这项技术节约了镜像的存储空间，加快了系统启动时间。</p><img src="https://img.darklorder.com/img/202308111440457.png"/><p>如图所示，当需要对镜像中的文件进行修改时，会将文件复制到容器层进行修改，上层文件会覆盖原始镜像文件。<strong>注意：该文件存在于容器层，容器重启之后容器层重新建立，上一次容器运行时对于文件的修改全部丢失！</strong></p><p>只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p><h4 id="内容寻址原理"><a href="#内容寻址原理" class="headerlink" title="内容寻址原理"></a>内容寻址原理</h4><p>在docker中，内容寻址就是根据文件内容来索引对应的镜像和镜像层，实际上就是对于镜像层的内容计算和校验后生成一个内容哈希值，并作为这个镜像层的唯一ID。在构造镜像时，根据这个ID来索引镜像层。</p><h3 id="Docker-Overlay2-文件系统原理"><a href="#Docker-Overlay2-文件系统原理" class="headerlink" title="Docker Overlay2 文件系统原理"></a>Docker Overlay2 文件系统原理</h3><blockquote><p>overlayFS是被称为联合文件系统的其中一个解决方案。在2014年，发布了第一个版本并且合并到了Linux的内核3.18版本中，此时，在docker被称为是overlay文件驱动。后来在Linux 内核4.0 版本中进行了改进，称为overlay2。（overlay存在诸多性能和不稳定的问题，不推荐使用overlay，直接使用默认的overlay2即可）</p></blockquote><h4 id="overlay2工作原理"><a href="#overlay2工作原理" class="headerlink" title="overlay2工作原理"></a><strong>overlay2工作原理</strong></h4><p><img src="https://img.darklorder.com/img/202308161527037.png"></p><p>overlayfs 通过三个目录：lower 目录、upper 目录、以及 work 目录实现，其中 lower 目录可以是多个，work 目录为工作基础目录，挂载后内容会被清空，且在使用过程中其内容用户不可见，最后联合挂载完成给用户呈现的统一视图称为为 merged 目录。</p><ul><li>lowerdir对应底层文件系统，是能被上层文件系统upperdir所共享的只读层</li><li>workdir则可以理解为overlay2运作的一个工作目录，用于完成copy-on-write等操作</li><li>overlay2运作时（也就是容器启动时），会将lowerdir、upperdir和workdir联合挂载到merged目录，为使用者提供一个“<strong>统一视图</strong>”</li></ul><p>查看 <code>/var/lib/docker/overlay2/容器ID</code>目录结构，使用<code>mount | grep overlay</code>查看overlay的挂载情况。如图，确实此目录下的link、lower、work、diff等目录是通过挂载多个目录后，合并显示在一起的。<br><img src="https://img.darklorder.com/img/202308161527930.png"></p><h3 id="Overlay2-是如何存储文件的？"><a href="#Overlay2-是如何存储文件的？" class="headerlink" title="Overlay2 是如何存储文件的？"></a><strong>Overlay2 是如何存储文件的？</strong></h3><h4 id="镜像怎么存储的？"><a href="#镜像怎么存储的？" class="headerlink" title="镜像怎么存储的？"></a><strong>镜像怎么存储的？</strong></h4><p>1、为了更好的演示，使用一个纯净的环境：没有任何镜像和容器，&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2目录也是空的<br><img src="https://img.darklorder.com/img/202308161527822.png"><br>2、拉取一个nginx镜像，观察拉取过程：可以看到镜像一共被分为6层拉取。<br><img src="https://img.darklorder.com/img/202308161527361.png"><br>3、&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F; 目录下也多了6个文件夹<br><img src="https://img.darklorder.com/img/202308161527441.png"><br>4、首先来查看一下l目录，可以看到l目录是一堆软连接，把一些较短的随机串软连到镜像层的 diff 文件夹下，这样做是为了避免达到mount命令参数的长度限制<br><img src="https://img.darklorder.com/img/202308161528058.png"><br>5、<code>docker image inspect nginx</code> 查看nginx镜像的信息，每个镜像都会有一个<code>GraphDriver.Data</code>信息，这个信息指示了镜像是怎么存的<br><img src="https://img.darklorder.com/img/202308161528556.png"><br>6、将这6个文件夹全部展开，可以看到目录结构几乎都是一致的，需要重点关注的是diff文件夹和lower文件。<br>可以看到<code>5160f86fbe7acce3826ed5c7d1acdb351b931d67978b1c91138d86b7eef8d0ab</code>文件夹中不存在lower文件，说明它是最底层的，等于是根镜像，即docker pull时下载的第一层。<br>同时，<code>diff</code>文件夹下的文件，正是Linux文件目录结构。说明在nginx的dockerfile中，肯定有FROM centos的操作。<br><img src="https://img.darklorder.com/img/202308161528219.png"><br><strong>实例说明：<code>Dockerfile</code>的每一个命令都可能引起了系统的变化，它的每一个变化都会记录一层diff文件。</strong></p><h4 id="容器怎么存储的？"><a href="#容器怎么存储的？" class="headerlink" title="容器怎么存储的？"></a><strong>容器怎么存储的？</strong></h4><p>1、当前环境有一个nginx镜像，&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F; 目录下只有镜像层的存储目录。<br><img src="https://img.darklorder.com/img/202308161538342.png"><br>2、docker run 启动一个容器<br><img src="https://img.darklorder.com/img/202308161538353.png"><br>3、查看&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F; 目录，发现新增了两个目录：其中带<code>-init</code>的目录是只读的；没有init的容器目录才是容器的读写目录<br><img src="https://img.darklorder.com/img/202308161538349.png"><br>4、<code>link</code>和<code>lower</code>文件与镜像层的功能一致，<code>link</code>文件内容为该容器层的<code>短 ID</code>，<code>lower</code>文件为该层的所有父层镜像的<code>短 ID</code>。<code>diff</code>目录为容器的读写层，容器内修改的文件都会在<code>diff</code>中出现，<code>merged</code>目录为分层文件联合挂载后的结果，也是容器内的工作目录。<br><img src="https://img.darklorder.com/img/202308161538303.png"><br><img src="https://img.darklorder.com/img/202308161538307.png"><br>5、根据 docker inspect nginx获取到的<code>GraphDriver.Data</code>数据显示，merged目录，是lowerDir各个目录合并UpperDir各个目录后的结果。<br><img src="https://img.darklorder.com/img/202308161538321.png"><br>6、当我们进入容器创建文件时，文件也会出现在这里。<br><img src="https://img.darklorder.com/img/202308161538202.png"></p><p><strong>结论：</strong> overlay2将镜像层和容器层都放在单独的目录，并且有唯一 ID，每一层仅存储发生变化的文件，最终使用联合挂载技术将容器层和镜像层的所有文件统一挂载到容器中，使得容器中看到完整的系统文件。</p><p><strong>参考资料</strong><br><a href="http://static.kancloud.cn/chunyu/php_basic_knowledge/3083129">docker·PHP知识总结·看云</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker命令大全</title>
    <link href="/2022/09/05/Docker-command-manual/"/>
    <url>/2022/09/05/Docker-command-manual/</url>
    
    <content type="html"><![CDATA[<p>Docker命令大全</p><span id="more"></span><h1 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h1><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p><strong>docker run ：</strong> 创建一个新的容器并运行一个命令</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARG...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</p></li><li><p><strong>-d:</strong> 后台运行容器，并返回容器ID；</p></li><li><p><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</p></li><li><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</p></li><li><p><strong>-p:</strong> 指定端口映射，格式为：主机(宿主)端口:容器端口</p></li><li><p><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p></li><li><p><strong>--name&#x3D;”nginx-lb”:</strong> 为容器指定一个名称；</p></li><li><p><strong>--dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</p></li><li><p><strong>--dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</p></li><li><p><strong>-h “mars”:</strong> 指定容器的hostname；</p></li><li><p><strong>-e username&#x3D;”ritchie”:</strong> 设置环境变量；</p></li><li><p><strong>--env-file&#x3D;[]:</strong> 从指定文件读入环境变量；</p></li><li><p><strong>--cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”:</strong> 绑定容器到指定CPU运行；</p></li><li><p><strong>-m :</strong> 设置容器使用内存最大值；</p></li><li><p><strong>--net&#x3D;”bridge”:</strong> 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</p></li><li><p><strong>--link&#x3D;[]:</strong> 添加链接到另一个容器；</p></li><li><p><strong>--expose&#x3D;[]:</strong> 开放一个端口或一组端口；</p></li><li><p><strong>--volume , -v:</strong> 绑定一个卷</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name mynginx -d nginx:latest</span><br></code></pre></td></tr></table></figure><p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -P -d nginx:latest<br></code></pre></td></tr></table></figure><p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 &#x2F;data 映射到容器的 &#x2F;data。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -p 80:80 -v /data:/data -d nginx:latest</span><br></code></pre></td></tr></table></figure><p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></code></pre></td></tr></table></figure><p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行&#x2F;bin&#x2F;bash命令。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker run -it <span class="hljs-symbol">nginx:</span>latest /bin/bash<br>root<span class="hljs-variable">@b8573233d675</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><h2 id="start-x2F-stop-x2F-restart"><a href="#start-x2F-stop-x2F-restart" class="headerlink" title="start&#x2F;stop&#x2F;restart"></a>start&#x2F;stop&#x2F;restart</h2><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker start <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker stop <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker restart <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>启动已被停止的容器myrunoob</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> myrunoob<br></code></pre></td></tr></table></figure><p>停止运行中的容器myrunoob</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker stop myrunoob<br></code></pre></td></tr></table></figure><p>重启容器myrunoob</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker restart myrunoob</span><br></code></pre></td></tr></table></figure><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p><strong>docker kill</strong> :杀掉一个运行中的容器。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker kill <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-s :</strong> 向容器发送一个信号</li></ul><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>杀掉运行中的容器mynginx</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker kill -s <span class="hljs-title class_">KILL</span> mynginx<br>mynginx<br></code></pre></td></tr></table></figure><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><strong>docker rm ：</strong>删除一个或多个容器。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker rm <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-f :</strong> 通过 SIGKILL 信号强制删除一个运行中的容器。</p></li><li><p><strong>-l :</strong> 移除容器间的网络连接，而非容器本身。</p></li><li><p><strong>-v :</strong> 删除与容器关联的卷。</p></li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>强制删除容器 db01、db02：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> db01 db02<br></code></pre></td></tr></table></figure><p>移除容器 nginx01 对容器 db01 的连接，连接名 db：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">rm</span> -<span class="hljs-keyword">l</span> <span class="hljs-keyword">db</span> <br></code></pre></td></tr></table></figure><p>删除容器 nginx01, 并删除容器挂载的数据卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -v nginx01<br></code></pre></td></tr></table></figure><p>删除所有已经停止的容器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">a</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>更多内容查看：<a href="https://www.runoob.com/w3cnote/docker-clear-command.html">Docker 清理命令</a></p></blockquote><h2 id="pause-x2F-unpause"><a href="#pause-x2F-unpause" class="headerlink" title="pause&#x2F;unpause"></a>pause&#x2F;unpause</h2><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker <span class="hljs-attribute">pause</span> CONTAINER <span class="hljs-selector-attr">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker unpause <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>暂停数据库容器db01提供服务。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">docker <span class="hljs-keyword">pause</span> db01<br></code></pre></td></tr></table></figure><p>恢复数据库容器 db01 提供服务。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> unpause db01<br></code></pre></td></tr></table></figure><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p><strong>docker create ：</strong>创建一个新的容器但不启动它</p><p>用法同 <a href="https://www.runoob.com/docker/docker-run-command.html">docker run</a></p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker create <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARG...]</span><br></code></pre></td></tr></table></figure><p>语法同 <a href="https://www.runoob.com/docker/docker-run-command.html">docker run</a></p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker create  --name myrunoob  <span class="hljs-symbol">nginx:</span>latest      <br><span class="hljs-number">09</span>b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f<br></code></pre></td></tr></table></figure><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker exec <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> COMMAND <span class="hljs-comment">[ARG...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-d :</strong> 分离模式: 在后台运行</p></li><li><p><strong>-i :</strong> 即使没有附加也保持STDIN 打开</p></li><li><p><strong>-t :</strong> 分配一个伪终端</p></li></ul><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>在容器 mynginx 中以交互模式执行容器内 &#x2F;root&#x2F;runoob.sh 脚本:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">runoob@runoob:~$ docker exec -it mynginx <span class="hljs-regexp">/bin/</span>sh <span class="hljs-regexp">/root/</span>runoob.sh<br>http:<span class="hljs-regexp">//</span>www.runoob.com/<br></code></pre></td></tr></table></figure><p>在容器 mynginx 中开启一个交互模式的终端:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker exec -i -t  mynginx /bin/bash<br>root<span class="hljs-variable">@b1a0703e41e7</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p><p>查看已经在运行的容器 ID：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># docker ps -a </span><br><span class="hljs-string">...</span><br>9df70f9a0714        openjdk             <span class="hljs-string">&quot;/usercode/script.sh…&quot;</span> <br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>第一列的 9df70f9a0714 就是容器 ID。</p><p>通过 exec 命令对指定的容器执行 bash:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 9df70f9a0714 /bin/bash</span><br></code></pre></td></tr></table></figure><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><strong>docker ps :</strong> 列出容器</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> ps<span class="hljs-meta"> [OPTIONS]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a :</strong> 显示所有的容器，包括未运行的。</p></li><li><p><strong>-f :</strong> 根据条件过滤显示的内容。</p></li><li><p><strong>--format :</strong> 指定返回值的模板文件。</p></li><li><p><strong>-l :</strong> 显示最近创建的容器。</p></li><li><p><strong>-n :</strong> 列出最近创建的n个容器。</p></li><li><p><strong>--no-trunc :</strong> 不截断输出。</p></li><li><p><strong>-q :</strong> 静默模式，只显示容器编号。</p></li><li><p><strong>-s :</strong> 显示总的文件大小。</p></li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>列出所有在运行的容器信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$ docker ps<br><span class="hljs-attribute">CONTAINER</span> ID   IMAGE          COMMAND                ...  PORTS                    NAMES<br><span class="hljs-attribute">09b93464c2f7</span>   nginx:latest   <span class="hljs-string">&quot;nginx -g &#x27;daemon off&quot;</span> ...  <span class="hljs-number">80</span>/tcp, <span class="hljs-number">443</span>/tcp          myrunoob<br><span class="hljs-attribute">96f7f14e99ab</span>   mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>      <span class="hljs-string">&quot;docker-entrypoint.sh&quot;</span> ...  <span class="hljs-number">0.0.0.0:3306</span>-&gt;<span class="hljs-number">3306</span>/tcp   mymysql<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><p>状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><p>列出最近创建的5个容器信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$ docker ps -n <span class="hljs-number">5</span><br><span class="hljs-attribute">CONTAINER</span> ID        IMAGE               COMMAND                   CREATED           <br><span class="hljs-attribute">09b93464c2f7</span>        nginx:latest        <span class="hljs-string">&quot;nginx -g &#x27;daemon off&quot;</span>    <span class="hljs-number">2</span> days ago   ...     <br><span class="hljs-attribute">b8573233d675</span>        nginx:latest        <span class="hljs-string">&quot;/bin/bash&quot;</span>               <span class="hljs-number">2</span> days ago   ...     <br><span class="hljs-attribute">b1a0703e41e7</span>        nginx:latest        <span class="hljs-string">&quot;nginx -g &#x27;daemon off&quot;</span>    <span class="hljs-number">2</span> days ago   ...    <br><span class="hljs-attribute">f46fb1dec520</span>        <span class="hljs-number">5</span>c6e1090e771        <span class="hljs-string">&quot;/bin/sh -c &#x27;set -x \t&quot;</span>   <span class="hljs-number">2</span> days ago   ...   <br><span class="hljs-attribute">a63b4a5597de</span>        <span class="hljs-number">860</span>c279d2fec        <span class="hljs-string">&quot;bash&quot;</span>                    <span class="hljs-number">2</span> days ago   ...<br></code></pre></td></tr></table></figure><p>列出所有创建的容器ID。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">runoob@runoob:~$ docker ps -a -q<br><span class="hljs-number">09</span>b<span class="hljs-number">93464c2f7</span><br>b8<span class="hljs-number">573233d675</span><br>b1a<span class="hljs-number">0703e41e7</span><br>f46fb1dec520<br>a63b4a5597de<br><span class="hljs-number">6</span>a4aa42e947b<br>de7bb36e7968<br><span class="hljs-number">43</span>a<span class="hljs-number">432b73776</span><br><span class="hljs-number">664</span>a8ab1a585<br>ba52eb632bbd<br>...<br></code></pre></td></tr></table></figure><h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><p><strong>docker inspect :</strong> 获取容器&#x2F;镜像的元数据。</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">docker inspect [OPTIONS] NAME|<span class="hljs-type">ID</span> [NAME|<span class="hljs-type">ID</span>...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-f :</strong> 指定返回值的模板文件。</p></li><li><p><strong>-s :</strong> 显示总的文件大小。</p></li><li><p><strong>--type :</strong> 为指定类型返回JSON。</p></li></ul><h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>获取镜像mysql:5.6的元信息。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker inspect <span class="hljs-symbol">mysql:</span><span class="hljs-number">5.6</span><br>[<br>    &#123;<br>        <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;</span>,<br>        <span class="hljs-string">&quot;RepoTags&quot;</span>: [<br>            <span class="hljs-string">&quot;mysql:5.6&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;RepoDigests&quot;</span>: [],<br>        <span class="hljs-string">&quot;Parent&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;Comment&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;Created&quot;</span>: <span class="hljs-string">&quot;2016-05-24T04:01:41.168371815Z&quot;</span>,<br>        <span class="hljs-string">&quot;Container&quot;</span>: <span class="hljs-string">&quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;</span>,<br>        <span class="hljs-string">&quot;ContainerConfig&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Hostname&quot;</span>: <span class="hljs-string">&quot;b0cf605c7757&quot;</span>,<br>            <span class="hljs-string">&quot;Domainname&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;User&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;AttachStdin&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;AttachStdout&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;AttachStderr&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;ExposedPorts&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;3306/tcp&quot;</span>: &#123;&#125;<br>            &#125;,<br>...<br></code></pre></td></tr></table></figure><p>获取正在运行的容器mymysql的 IP。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">runoob@runoob:~$ docker inspect --format=&#x27;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">range</span> .NetworkSettings.Networks&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.IPAddress</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">end</span>&#125;&#125;</span><span class="language-xml">&#x27; mymysql</span><br><span class="language-xml">172.17.0.3</span><br></code></pre></td></tr></table></figure><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><strong>docker top :</strong> 查看容器中运行的进程信息，支持 ps 命令参数。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker <span class="hljs-attribute">top</span> <span class="hljs-selector-attr">[OPTIONS]</span> CONTAINER <span class="hljs-selector-attr">[ps OPTIONS]</span><br></code></pre></td></tr></table></figure><p>容器运行时不一定有&#x2F;bin&#x2F;bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>查看容器mymysql的进程信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~/mysql$ docker top mymysql<br><span class="hljs-attribute">UID</span>    PID    PPID    C      STIME   TTY  TIME       CMD<br><span class="hljs-attribute">999</span>    <span class="hljs-number">40347</span>  <span class="hljs-number">40331</span>   <span class="hljs-number">18</span>     <span class="hljs-number">00</span>:<span class="hljs-number">58</span>   ?    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">02</span>   mysqld<br></code></pre></td></tr></table></figure><p>查看所有运行容器的进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  `docker ps |grep Up|awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> \ &amp;&amp;docker top <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p><strong>docker attach :</strong> 连接到正在运行中的容器。</p><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker attach <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span><br></code></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy&#x3D;false来确保CTRL-D或CTRL-C不会关闭容器。</p><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">runoob@runoob:~$ docker attach --sig-proxy=false mynginx<br><span class="hljs-number">192.168.239.1</span> - - <span class="hljs-string">[10/Jul/2016:16:54:26 +0000]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.1&quot;</span> <span class="hljs-number">304</span> <span class="hljs-number">0</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot;</span> <span class="hljs-string">&quot;-&quot;</span><br></code></pre></td></tr></table></figure><h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p><strong>docker events :</strong> 从服务器获取实时事件</p><h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> events<span class="hljs-meta"> [OPTIONS]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-f ：</strong>根据条件过滤事件；</p></li><li><p><strong>--since ：</strong>从指定的时间戳后显示所有事件;</p></li><li><p><strong>--until ：</strong>流水时间显示到指定的时间为止；</p></li></ul><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><p>显示docker 2016年7月1日后的所有事件。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">runoob@runoob:~/mysql$ docker events  <span class="hljs-attribute">--since</span>=<span class="hljs-string">&quot;1467302400&quot;</span><br>2016-07-08T19:44:54.501277677+08:00<span class="hljs-built_in"> network </span>connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (<span class="hljs-attribute">container</span>=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, <span class="hljs-attribute">name</span>=bridge, <span class="hljs-attribute">type</span>=bridge)<br>2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (<span class="hljs-attribute">image</span>=nginx:latest, <span class="hljs-attribute">name</span>=elegant_albattani)<br>2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (<span class="hljs-attribute">height</span>=39, <span class="hljs-attribute">image</span>=nginx:latest, <span class="hljs-attribute">name</span>=elegant_albattani, <span class="hljs-attribute">width</span>=167)<br>2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (<span class="hljs-attribute">exitCode</span>=0, <span class="hljs-attribute">image</span>=nginx:latest, <span class="hljs-attribute">name</span>=elegant_albattani)<br><span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure><p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~/mysql$ docker events -f <span class="hljs-string">&quot;image&quot;</span>=<span class="hljs-string">&quot;mysql:5.6&quot;</span> --since=<span class="hljs-string">&quot;1467302400&quot;</span> <br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">38</span>:<span class="hljs-number">53</span>.<span class="hljs-number">975174837</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container start <span class="hljs-number">96</span>f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">51</span>:<span class="hljs-number">17</span>.<span class="hljs-number">022572452</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container kill <span class="hljs-number">96</span>f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql, signal=<span class="hljs-number">9</span>)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">51</span>:<span class="hljs-number">17</span>.<span class="hljs-number">132532080</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container die <span class="hljs-number">96</span>f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=<span class="hljs-number">137</span>, image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">51</span>:<span class="hljs-number">17</span>.<span class="hljs-number">514661357</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container destroy <span class="hljs-number">96</span>f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">57</span>:<span class="hljs-number">18</span>.<span class="hljs-number">551984549</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">57</span>:<span class="hljs-number">18</span>.<span class="hljs-number">557405864</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">57</span>:<span class="hljs-number">18</span>.<span class="hljs-number">844134112</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">57</span>:<span class="hljs-number">19</span>.<span class="hljs-number">140141428</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=<span class="hljs-number">1</span>, image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">58</span>:<span class="hljs-number">05</span>.<span class="hljs-number">941019136</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">58</span>:<span class="hljs-number">07</span>.<span class="hljs-number">965128417</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">58</span>:<span class="hljs-number">08</span>.<span class="hljs-number">188734598</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T00:<span class="hljs-number">58</span>:<span class="hljs-number">20</span>.<span class="hljs-number">010876777</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><span class="hljs-attribute">2016</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span>T01:<span class="hljs-number">06</span>:<span class="hljs-number">01</span>.<span class="hljs-number">395365098</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span>, name=mymysql)<br><br></code></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since&#x3D;”2016-07-01”。</p><h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p><strong>docker logs :</strong> 获取容器的日志</p><h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker logs <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-f :</strong> 跟踪日志输出</p></li><li><p><strong>--since :</strong> 显示某个开始时间的所有日志</p></li><li><p><strong>-t :</strong> 显示时间戳</p></li><li><p><strong>--tail :</strong> 仅列出最新N条容器日志</p></li></ul><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>跟踪查看容器mynginx的日志输出。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">runoob@runoob:~$ docker logs -f mynginx<br><span class="hljs-number">192.168.239.1</span> - - <span class="hljs-string">[10/Jul/2016:16:53:33 +0000]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.1&quot;</span> <span class="hljs-number">200</span> <span class="hljs-number">612</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot;</span> <span class="hljs-string">&quot;-&quot;</span><br><span class="hljs-number">2016</span>/<span class="hljs-number">07</span>/<span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">53</span>:<span class="hljs-number">33</span> <span class="hljs-string">[error]</span> <span class="hljs-number">5</span>#<span class="hljs-number">5</span>: *<span class="hljs-number">1</span> open() <span class="hljs-string">&quot;/usr/share/nginx/html/favicon.ico&quot;</span> failed (<span class="hljs-number">2</span>: No such file or directory), client: <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">239</span>.<span class="hljs-number">1</span>, server: localhost, request: <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /favicon.ico HTTP/1.1&quot;</span>, host: <span class="hljs-string">&quot;192.168.239.130&quot;</span>, referrer: <span class="hljs-string">&quot;http://192.168.239.130/&quot;</span><br><span class="hljs-number">192.168.239.1</span> - - <span class="hljs-string">[10/Jul/2016:16:53:33 +0000]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /favicon.ico HTTP/1.1&quot;</span> <span class="hljs-number">404</span> <span class="hljs-number">571</span> <span class="hljs-string">&quot;http://192.168.239.130/&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot;</span> <span class="hljs-string">&quot;-&quot;</span><br><span class="hljs-number">192.168.239.1</span> - - <span class="hljs-string">[10/Jul/2016:16:53:59 +0000]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.1&quot;</span> <span class="hljs-number">304</span> <span class="hljs-number">0</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot;</span> <span class="hljs-string">&quot;-&quot;</span><br>...<br><br></code></pre></td></tr></table></figure><p>查看容器mynginx从2016年7月1日后的最新10条日志。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker logs <span class="hljs-attribute">--since</span>=<span class="hljs-string">&quot;2016-07-01&quot;</span> <span class="hljs-attribute">--tail</span>=10 mynginx<br></code></pre></td></tr></table></figure><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p><strong>docker wait :</strong> 阻塞运行直到容器停止，然后打印出它的退出代码。</p><h3 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker wait <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">wait</span> CONTAINER<br></code></pre></td></tr></table></figure><hr><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><p><strong>docker export :</strong> 将文件系统作为一个tar归档文件导出到STDOUT。</p><h3 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">docker</span> ex<span class="hljs-keyword">port</span> [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-o :</strong> 将输入内容写到文件。</li></ul><h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><p>将id为a404c6c174a2的容器按日期保存为tar文件。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">runoob<span class="hljs-title">@runoob</span>:~$ docker export -o mysql-`date +<span class="hljs-variable">%Y</span><span class="hljs-variable">%m</span><span class="hljs-variable">%d</span>`.tar a<span class="hljs-number">404</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span><span class="hljs-keyword">c</span><span class="hljs-number">174</span>a<span class="hljs-number">2</span><br>runoob<span class="hljs-title">@runoob</span>:~$ ls mysql-`date +<span class="hljs-variable">%Y</span><span class="hljs-variable">%m</span><span class="hljs-variable">%d</span>`.tar<br>mysql<span class="hljs-number">-20160711</span>.tar<br></code></pre></td></tr></table></figure><h2 id="port"><a href="#port" class="headerlink" title="port"></a>port</h2><p><strong>docker port</strong> 用于列出指定的容器的端口映射，或者查找将 PRIVATE_PORT NAT 到面向公众的端口。</p><h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker port <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[PRIVATE_PORT<span class="hljs-comment">[/PROTO]</span>]</span><br></code></pre></td></tr></table></figure><h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><p>查看容器 mymysql 的端口映射情况：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker port mymysql<br><span class="hljs-number">3306</span>/tcp -&gt; <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><span class="hljs-symbol">:</span><span class="hljs-number">3306</span><br></code></pre></td></tr></table></figure><h2 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h2><p><strong>docker stats :</strong> 显示容器资源的使用情况，包括：CPU、内存、网络 I&#x2F;O 等。</p><h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker stats <span class="hljs-selector-attr">[OPTIONS]</span> <span class="hljs-selector-attr">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><p><strong>--all , -a :</strong> 显示所有的容器，包括未运行的。</p></li><li><p><strong>--format :</strong> 指定返回值的模板文件。</p></li><li><p><strong>--no-stream :</strong> 展示当前状态就直接退出了，不再实时更新。</p></li><li><p><strong>--no-trunc :</strong> 不截断输出。</p></li></ul><h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><p>列出所有在运行的容器信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$  docker stats<br><span class="hljs-attribute">CONTAINER</span> ID        NAME                                    CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br><span class="hljs-attribute">b95a83497c91</span>        awesome_brattain                        <span class="hljs-number">0</span>.<span class="hljs-number">28</span>%               <span class="hljs-number">5</span>.<span class="hljs-number">629</span>MiB / <span class="hljs-number">1</span>.<span class="hljs-number">952</span>GiB   <span class="hljs-number">0</span>.<span class="hljs-number">28</span>%               <span class="hljs-number">916</span>B / <span class="hljs-number">0</span>B           <span class="hljs-number">147</span>kB / <span class="hljs-number">0</span>B          <span class="hljs-number">9</span><br><span class="hljs-attribute">67b2525d8ad1</span>        foobar                                  <span class="hljs-number">0</span>.<span class="hljs-number">00</span>%               <span class="hljs-number">1</span>.<span class="hljs-number">727</span>MiB / <span class="hljs-number">1</span>.<span class="hljs-number">952</span>GiB   <span class="hljs-number">0</span>.<span class="hljs-number">09</span>%               <span class="hljs-number">2</span>.<span class="hljs-number">48</span>kB / <span class="hljs-number">0</span>B         <span class="hljs-number">4</span>.<span class="hljs-number">11</span>MB / <span class="hljs-number">0</span>B         <span class="hljs-number">2</span><br><span class="hljs-attribute">e5c383697914</span>        test-<span class="hljs-number">1951</span>.<span class="hljs-number">1</span>.kay7x1lh1twk9c0oig50sd5tr   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>%               <span class="hljs-number">196</span>KiB / <span class="hljs-number">1</span>.<span class="hljs-number">952</span>GiB     <span class="hljs-number">0</span>.<span class="hljs-number">01</span>%               <span class="hljs-number">71</span>.<span class="hljs-number">2</span>kB / <span class="hljs-number">0</span>B         <span class="hljs-number">770</span>kB / <span class="hljs-number">0</span>B          <span class="hljs-number">1</span><br><span class="hljs-attribute">4bda148efbc0</span>        random.<span class="hljs-number">1</span>.vnc8on831idyr42slu578u3cr      <span class="hljs-number">0</span>.<span class="hljs-number">00</span>%               <span class="hljs-number">1</span>.<span class="hljs-number">672</span>MiB / <span class="hljs-number">1</span>.<span class="hljs-number">952</span>GiB   <span class="hljs-number">0</span>.<span class="hljs-number">08</span>%               <span class="hljs-number">110</span>kB / <span class="hljs-number">0</span>B          <span class="hljs-number">578</span>kB / <span class="hljs-number">0</span>B          <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID 与 NAME:</strong> 容器 ID 与名称。</p><p><strong>CPU % 与 MEM %:</strong> 容器使用的 CPU 和内存的百分比。</p><p><strong>MEM USAGE &#x2F; LIMIT:</strong> 容器正在使用的总内存，以及允许使用的内存总量。</p><p><strong>NET I&#x2F;O:</strong> 容器通过其网络接口发送和接收的数据量。</p><p><strong>BLOCK I&#x2F;O:</strong> 容器从主机上的块设备读取和写入的数据量。</p><p><strong>PIDs:</strong> 容器创建的进程或线程数。</p><p>根据容器等 ID 或名称现实信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$ docker stats awesome_brattain <span class="hljs-number">67</span>b2525d8ad1<br><br><span class="hljs-attribute">CONTAINER</span> ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS<br><span class="hljs-attribute">b95a83497c91</span>        awesome_brattain    <span class="hljs-number">0</span>.<span class="hljs-number">28</span>%               <span class="hljs-number">5</span>.<span class="hljs-number">629</span>MiB / <span class="hljs-number">1</span>.<span class="hljs-number">952</span>GiB   <span class="hljs-number">0</span>.<span class="hljs-number">28</span>%               <span class="hljs-number">916</span>B / <span class="hljs-number">0</span>B           <span class="hljs-number">147</span>kB / <span class="hljs-number">0</span>B          <span class="hljs-number">9</span><br><span class="hljs-attribute">67b2525d8ad1</span>        foobar              <span class="hljs-number">0</span>.<span class="hljs-number">00</span>%               <span class="hljs-number">1</span>.<span class="hljs-number">727</span>MiB / <span class="hljs-number">1</span>.<span class="hljs-number">952</span>GiB   <span class="hljs-number">0</span>.<span class="hljs-number">09</span>%               <span class="hljs-number">2</span>.<span class="hljs-number">48</span>kB / <span class="hljs-number">0</span>B         <span class="hljs-number">4</span>.<span class="hljs-number">11</span>MB / <span class="hljs-number">0</span>B         <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>以 JSON 格式输出：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker stats nginx --no-stream --format <span class="hljs-string">&quot;&#123;&#123; json . &#125;&#125;&quot;</span><br>  &#123;<span class="hljs-string">&quot;BlockIO&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;0B / 13.3kB&quot;</span></span>,<span class="hljs-string">&quot;CPUPerc&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;0.03%&quot;</span></span>,<span class="hljs-string">&quot;Container&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;nginx&quot;</span></span>,<span class="hljs-string">&quot;ID&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;ed37317fbf42&quot;</span></span>,<span class="hljs-string">&quot;MemPerc&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;0.24%&quot;</span></span>,<span class="hljs-string">&quot;MemUsage&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;2.352MiB / 982.5MiB&quot;</span></span>,<span class="hljs-string">&quot;Name&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;nginx&quot;</span></span>,<span class="hljs-string">&quot;NetIO&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;539kB / 606kB&quot;</span></span>,<span class="hljs-string">&quot;PIDs&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;2&quot;</span></span>&#125;<br></code></pre></td></tr></table></figure><p>输出指定的信息：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">runoob@runoob:~$ docker stats --all --format <span class="hljs-string">&quot;table &#123;&#123;.Container&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span> fervent_panini <span class="hljs-number">5</span>acfcb1b4fd1 drunk_visvesvaraya big_heisenberg<br>  &#123;<span class="hljs-string">&quot;BlockIO&quot;</span>:<span class="hljs-string">&quot;0B / 13.3kB&quot;</span>,<span class="hljs-string">&quot;CPUPerc&quot;</span>:<span class="hljs-string">&quot;0.03%&quot;</span>,<span class="hljs-string">&quot;Container&quot;</span>:<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-string">&quot;ed37317fbf42&quot;</span>,<span class="hljs-string">&quot;MemPerc&quot;</span>:<span class="hljs-string">&quot;0.24%&quot;</span>,<span class="hljs-string">&quot;MemUsage&quot;</span>:<span class="hljs-string">&quot;2.352MiB / 982.5MiB&quot;</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;NetIO&quot;</span>:<span class="hljs-string">&quot;539kB / 606kB&quot;</span>,<span class="hljs-string">&quot;PIDs&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>&#125;<br><br>CONTAINER                CPU <span class="hljs-comment">%               MEM USAGE / LIMIT</span><br>fervent_panini           <span class="hljs-number">0.00</span><span class="hljs-comment">%               56KiB / 15.57GiB</span><br><span class="hljs-number">5</span>acfcb1b4fd1             <span class="hljs-number">0.07</span><span class="hljs-comment">%               32.86MiB / 15.57GiB</span><br>drunk_visvesvaraya       <span class="hljs-number">0.00</span><span class="hljs-comment">%               0B / 0B</span><br>big_heisenberg           <span class="hljs-number">0.00</span><span class="hljs-comment">%               0B / 0B</span><br></code></pre></td></tr></table></figure><h1 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h1><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p><strong>docker commit :</strong> 从容器创建一个新的镜像。</p><h3 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker commit <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[REPOSITORY<span class="hljs-comment">[:TAG]</span>]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a :</strong> 提交的镜像作者；</p></li><li><p><strong>-c :</strong> 使用Dockerfile指令来创建镜像；</p></li><li><p><strong>-m :</strong> 提交时的说明文字；</p></li><li><p><strong>-p :</strong> 在commit时，将容器暂停。</p></li></ul><h3 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h3><p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker commit -a <span class="hljs-string">&quot;runoob.com&quot;</span> -m <span class="hljs-string">&quot;my apache&quot;</span> a404c6c174a2  <span class="hljs-symbol">mymysql:</span>v1 <br><span class="hljs-symbol">sha256:</span><span class="hljs-number">37</span>af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057<br>runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker images <span class="hljs-symbol">mymysql:</span>v1<br><span class="hljs-title class_">REPOSITORY</span>          <span class="hljs-title class_">TAG</span>                 <span class="hljs-title class_">IMAGE</span> <span class="hljs-title class_">ID</span>            <span class="hljs-title class_">CREATED</span>             <span class="hljs-title class_">SIZE</span><br>mymysql             v1                  <span class="hljs-number">37</span>af1236adef        <span class="hljs-number">15</span> seconds ago      <span class="hljs-number">329</span> <span class="hljs-title class_">MB</span><br></code></pre></td></tr></table></figure><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p><strong>docker cp :</strong> 用于容器与主机之间的数据拷贝。</p><h3 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker cp <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span>:SRC_PATH DEST_PATH|-<br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker cp <span class="hljs-comment">[OPTIONS]</span> SRC_PATH|- <span class="hljs-keyword">CONTAINER</span>:DEST_PATH<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-L :</strong> 保持源目标中的链接</li></ul><h3 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h3><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp <span class="hljs-regexp">/www/</span>runoob <span class="hljs-number">96</span>f7f14e99ab:<span class="hljs-regexp">/www/</span><br></code></pre></td></tr></table></figure><p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /www/runoob 96f7f14e99ab:/www<br></code></pre></td></tr></table></figure><p>将容器96f7f14e99ab的&#x2F;www目录拷贝到主机的&#x2F;tmp目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span>  96f7f14e99ab:/www /tmp/<br></code></pre></td></tr></table></figure><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p><strong>docker diff :</strong> 检查容器里文件结构的更改。</p><h3 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker diff <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span><br></code></pre></td></tr></table></figure><h3 id="实例-19"><a href="#实例-19" class="headerlink" title="实例"></a>实例</h3><p>查看容器mymysql的文件结构更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">runoob@runoob:~$ docker diff mymysql<br>A /logs<br>A /mysql_data<br>C /run<br>C /run/mysqld<br>A /run/mysqld/mysqld.pid<br>A /run/mysqld/mysqld.sock<br>C /tmp<br></code></pre></td></tr></table></figure><h1 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h1><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p><strong>docker login :</strong> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p><strong>docker logout :</strong> 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><h3 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">login</span> [<span class="hljs-keyword">OPTIONS</span>] [<span class="hljs-keyword">SERVER</span>]<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker logout <span class="hljs-selector-attr">[OPTIONS]</span> <span class="hljs-selector-attr">[SERVER]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-u :</strong> 登陆的用户名</p></li><li><p><strong>-p :</strong> 登陆的密码</p></li></ul><h3 id="实例-20"><a href="#实例-20" class="headerlink" title="实例"></a>实例</h3><p>登陆到Docker Hub</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker login -u 用户名 -<span class="hljs-selector-tag">p</span> 密码<br></code></pre></td></tr></table></figure><p>登出Docker Hub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">logout</span><br></code></pre></td></tr></table></figure><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像</p><h3 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker pull [<span class="hljs-title class_">OPTIONS</span>] <span class="hljs-title class_">NAME</span>[<span class="hljs-symbol">:TAG|</span><span class="hljs-variable">@DIGEST</span>]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a :</strong> 拉取所有 tagged 镜像</p></li><li><p><strong>--disable-content-trust :</strong> 忽略镜像的校验,默认开启</p></li></ul><h3 id="实例-21"><a href="#实例-21" class="headerlink" title="实例"></a>实例</h3><p>从Docker Hub下载java最新版镜像。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull java</span><br></code></pre></td></tr></table></figure><p>从Docker Hub下载REPOSITORY为java的所有镜像。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker pull -<span class="hljs-selector-tag">a</span> java<br></code></pre></td></tr></table></figure><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><strong>docker push :</strong> 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><h3 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker push <span class="hljs-selector-attr">[OPTIONS]</span> NAME<span class="hljs-selector-attr">[:TAG]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>--disable-content-trust :</strong> 忽略镜像的校验,默认开启</li></ul><h3 id="实例-22"><a href="#实例-22" class="headerlink" title="实例"></a>实例</h3><p>上传本地镜像myapache:v1到镜像仓库中。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> <span class="hljs-keyword">push</span> myapache:<span class="hljs-built_in">v1</span><br></code></pre></td></tr></table></figure><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p><strong>docker search :</strong> 从Docker Hub查找镜像</p><h3 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">search</span> [<span class="hljs-keyword">OPTIONS</span>] TERM<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>--automated :</strong> 只列出 automated build类型的镜像；</p></li><li><p><strong>--no-trunc :</strong> 显示完整的镜像描述；</p></li><li><p><strong>-f &lt;过滤条件&gt;:</strong> 列出收藏数不小于指定值的镜像。</p></li></ul><h3 id="实例-23"><a href="#实例-23" class="headerlink" title="实例"></a>实例</h3><p>从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$ docker search -f stars=<span class="hljs-number">10</span> java<br><span class="hljs-attribute">NAME</span>                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED<br><span class="hljs-attribute">java</span>                  Java is a concurrent, class-based...   <span class="hljs-number">1037</span>   <span class="hljs-meta"> [OK]       </span><br><span class="hljs-meta">anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]</span><br><span class="hljs-attribute">develar</span>/java                                                 <span class="hljs-number">46</span>                <span class="hljs-meta"> [OK]</span><br><span class="hljs-attribute">isuper</span>/java-oracle    This repository contains <span class="hljs-literal">all</span> java...   <span class="hljs-number">38</span>                <span class="hljs-meta"> [OK]</span><br><span class="hljs-attribute">lwieske</span>/java-<span class="hljs-number">8</span>        Oracle Java <span class="hljs-number">8</span> Container - Full + ...   <span class="hljs-number">27</span>                <span class="hljs-meta"> [OK]</span><br><span class="hljs-attribute">nimmis</span>/java-centos    This is docker images of CentOS <span class="hljs-number">7</span>...   <span class="hljs-number">13</span>                <span class="hljs-meta"> [OK]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p><strong>NAME:</strong> 镜像仓库源的名称</p><p><strong>DESCRIPTION:</strong> 镜像的描述</p><p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p><p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p><p><strong>AUTOMATED:</strong> 自动构建。</p><h1 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h1><h2 id="images"><a href="#images" class="headerlink" title="images"></a>images</h2><p><strong>docker images :</strong> 列出本地镜像。</p><h3 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker images <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-comment">[REPOSITORY<span class="hljs-comment">[:TAG]</span>]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a :</strong> 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</p></li><li><p><strong>--digests :</strong> 显示镜像的摘要信息；</p></li><li><p><strong>-f :</strong> 显示满足条件的镜像；</p></li><li><p><strong>--format :</strong> 指定返回值的模板文件；</p></li><li><p><strong>--no-trunc :</strong> 显示完整的镜像信息；</p></li><li><p><strong>-q :</strong> 只显示镜像ID。</p></li></ul><h3 id="实例-24"><a href="#实例-24" class="headerlink" title="实例"></a>实例</h3><p>查看本地镜像列表。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">runoob@runoob:~$ docker images<br>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE<br>mymysql                 v1                  37af1236adef       <span class="hljs-number"> 5 </span>minutes ago      <span class="hljs-number"> 329 </span>MB<br>runoob/ubuntu           v4                  1c06aa18edee       <span class="hljs-number"> 2 </span>days ago          142.1 MB<br>&lt;none&gt;                  &lt;none&gt;              5c6e1090e771       <span class="hljs-number"> 2 </span>days ago          165.9 MB<br>httpd                   latest              ed38aaffef30       <span class="hljs-number"> 11 </span>days ago         195.1 MB<br>alpine                  latest              4e38e38c8ce0       <span class="hljs-number"> 2 </span>weeks ago         4.799 MB<br>mongo                   3.2                 282fd552add6       <span class="hljs-number"> 3 </span>weeks ago         336.1 MB<br>redis                   latest              4465e4bcad80       <span class="hljs-number"> 3 </span>weeks ago         185.7 MB<br>php                     5.6-fpm             025041cd3aa5       <span class="hljs-number"> 3 </span>weeks ago         456.3 MB<br>python                  3.5                 045767ddf24a       <span class="hljs-number"> 3 </span>weeks ago         684.1 MB<br>...<br></code></pre></td></tr></table></figure><p>列出本地镜像中REPOSITORY为ubuntu的镜像列表。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@runoob:~# docker images  ubuntu<br><span class="hljs-attribute">REPOSITORY</span>          TAG                 IMAGE ID            CREATED             SIZE<br><span class="hljs-attribute">ubuntu</span>              <span class="hljs-number">14</span>.<span class="hljs-number">04</span>               <span class="hljs-number">90</span>d5884b1ee0        <span class="hljs-number">9</span> weeks ago         <span class="hljs-number">188</span> MB<br><span class="hljs-attribute">ubuntu</span>              <span class="hljs-number">15</span>.<span class="hljs-number">10</span>               <span class="hljs-number">4</span>e3b13c8a266        <span class="hljs-number">3</span> months ago        <span class="hljs-number">136</span>.<span class="hljs-number">3</span> MB<br></code></pre></td></tr></table></figure><h2 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h2><p><strong>docker rmi :</strong> 删除本地一个或多个镜像。</p><h3 id="语法-25"><a href="#语法-25" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker rmi <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-f :</strong> 强制删除；</p></li><li><p><strong>--no-prune :</strong> 不移除该镜像的过程镜像，默认移除；</p></li></ul><h3 id="实例-25"><a href="#实例-25" class="headerlink" title="实例"></a>实例</h3><p>强制删除本地镜像 runoob&#x2F;ubuntu:v4。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">root<span class="hljs-keyword">@runoob</span>:~# docker rmi -f runoob/<span class="hljs-attribute">ubuntu</span>:v4<br><span class="hljs-attribute">Untagged</span>: runoob/<span class="hljs-attribute">ubuntu</span>:v4<br><span class="hljs-attribute">Deleted</span>: sha256:<span class="hljs-number">1</span>c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be<br><span class="hljs-attribute">Deleted</span>: sha256:<span class="hljs-number">85</span>feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73<br></code></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p><strong>docker tag :</strong> 标记本地镜像，将其归入某一仓库。</p><h3 id="语法-26"><a href="#语法-26" class="headerlink" title="语法"></a>语法</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker <span class="hljs-keyword">tag</span> <span class="hljs-title">[OPTIONS</span>] IMAGE[:<span class="hljs-keyword">TAG</span>] [REGISTRYHOST/][USERNAME/]NAME[:<span class="hljs-keyword">TAG</span>]<br></code></pre></td></tr></table></figure><h3 id="实例-26"><a href="#实例-26" class="headerlink" title="实例"></a>实例</h3><p>将镜像ubuntu:15.10标记为 runoob&#x2F;ubuntu:v3 镜像。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@runoob:~# docker tag ubuntu:<span class="hljs-number">15</span>.<span class="hljs-number">10</span> runoob/ubuntu:v3<br><span class="hljs-attribute">root</span>@runoob:~# docker images   runoob/ubuntu:v3<br><span class="hljs-attribute">REPOSITORY</span>          TAG                 IMAGE ID            CREATED             SIZE<br><span class="hljs-attribute">runoob</span>/ubuntu       v3                  <span class="hljs-number">4</span>e3b13c8a266        <span class="hljs-number">3</span> months ago        <span class="hljs-number">136</span>.<span class="hljs-number">3</span> MB<br></code></pre></td></tr></table></figure><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p><strong>docker build</strong> 命令用于使用 Dockerfile 创建镜像。</p><h3 id="语法-27"><a href="#语法-27" class="headerlink" title="语法"></a>语法</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">docker build [OPTIONS] PATH |<span class="hljs-string"> URL </span>|<span class="hljs-string"> -</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>--build-arg&#x3D;[] :</strong> 设置镜像创建时的变量；</p></li><li><p><strong>--cpu-shares :</strong> 设置 cpu 使用权重；</p></li><li><p><strong>--cpu-period :</strong> 限制 CPU CFS周期；</p></li><li><p><strong>--cpu-quota :</strong> 限制 CPU CFS配额；</p></li><li><p><strong>--cpuset-cpus :</strong> 指定使用的CPU id；</p></li><li><p><strong>--cpuset-mems :</strong> 指定使用的内存 id；</p></li><li><p><strong>--disable-content-trust :</strong> 忽略校验，默认开启；</p></li><li><p><strong>-f :</strong> 指定要使用的Dockerfile路径；</p></li><li><p><strong>--force-rm :</strong> 设置镜像过程中删除中间容器；</p></li><li><p><strong>--isolation :</strong> 使用容器隔离技术；</p></li><li><p><strong>--label&#x3D;[] :</strong> 设置镜像使用的元数据；</p></li><li><p><strong>-m :</strong> 设置内存最大值；</p></li><li><p><strong>--memory-swap :</strong> 设置Swap的最大值为内存+swap，”-1”表示不限swap；</p></li><li><p><strong>--no-cache :</strong> 创建镜像的过程不使用缓存；</p></li><li><p><strong>--pull :</strong> 尝试去更新镜像的新版本；</p></li><li><p><strong>--quiet, -q :</strong> 安静模式，成功后只输出镜像 ID；</p></li><li><p><strong>--rm :</strong> 设置镜像成功后删除中间容器；</p></li><li><p><strong>--shm-size :</strong> 设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</p></li><li><p><strong>--ulimit :</strong> Ulimit配置。</p></li><li><p><strong>--squash :</strong> 将 Dockerfile 中所有的操作压缩为一层。</p></li><li><p><strong>--tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</p></li><li><p><strong>--network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</p></li></ul><h3 id="实例-27"><a href="#实例-27" class="headerlink" title="实例"></a>实例</h3><p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> build -t runoob/ubuntu:<span class="hljs-built_in">v1</span> . <br></code></pre></td></tr></table></figure><p>使用URL <strong>github.com&#x2F;creack&#x2F;docker-firefox</strong> 的 Dockerfile 创建镜像。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker build github.com<span class="hljs-regexp">/creack/</span>docker-firefox<br></code></pre></td></tr></table></figure><p>也可以通过 -f Dockerfile 文件的位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ docker build -f <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/a/</span>Dockerfile .<br></code></pre></td></tr></table></figure><p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ docker build -t test/myapp .<br>Sending build context to Docker daemon 2.048 kB<br><span class="hljs-keyword">Error </span>response from daemon: Unknown instruction: RUNCMD<br></code></pre></td></tr></table></figure><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p><strong>docker history :</strong> 查看指定镜像的创建历史。</p><h3 id="语法-28"><a href="#语法-28" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> [OPTIONS] IMAGE<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-H :</strong> 以可读的格式打印镜像大小和日期，默认为true；</p></li><li><p><strong>--no-trunc :</strong> 显示完整的提交记录；</p></li><li><p><strong>-q :</strong> 仅列出提交记录ID。</p></li></ul><h3 id="实例-28"><a href="#实例-28" class="headerlink" title="实例"></a>实例</h3><p>查看本地镜像runoob&#x2F;ubuntu:v3的创建历史。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">root@runoob:~<span class="hljs-comment"># docker history runoob/ubuntu:v3</span><br>IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT<br>4e3b13c8a266      3 months ago      <span class="hljs-string">/bin/sh</span> -c <span class="hljs-comment">#(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br>&lt;missing&gt;         3 months ago      <span class="hljs-string">/bin/sh</span> -c sed -i &#x27;s/^<span class="hljs-comment">#\s*\(deb.*universe\)$/   1.863 kB            </span><br>&lt;missing&gt;         3 months ago      <span class="hljs-string">/bin/sh</span> -c <span class="hljs-keyword">set</span> -xe   &amp;&amp; <span class="hljs-keyword">echo</span> &#x27;<span class="hljs-comment">#!/bin/sh&#x27; &gt; /u   701 B               </span><br>&lt;missing&gt;         3 months ago      <span class="hljs-string">/bin/sh</span> -c <span class="hljs-comment">#(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></code></pre></td></tr></table></figure><h2 id="save"><a href="#save" class="headerlink" title="save"></a>save</h2><p><strong>docker save :</strong> 将指定镜像保存成 tar 归档文件。</p><h3 id="语法-29"><a href="#语法-29" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker save <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><strong>-o :</strong> 输出到的文件。</li></ul><h3 id="实例-29"><a href="#实例-29" class="headerlink" title="实例"></a>实例</h3><p>将镜像 runoob&#x2F;ubuntu:v3 生成 my_ubuntu_v3.tar 文档</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker save -o my_ubuntu_v3.tar runoob/<span class="hljs-symbol">ubuntu:</span>v3<br>runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>ll my_ubuntu_v3.tar<br>-rw------- <span class="hljs-number">1</span> runoob runoob <span class="hljs-number">142102016</span> <span class="hljs-title class_">Jul</span> <span class="hljs-number">11</span> <span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">37</span> my_ubuntu_v3.ta<br></code></pre></td></tr></table></figure><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p><strong>docker load :</strong> 导入使用 <a href="https://www.runoob.com/docker/docker-save-command.html">docker save</a> 命令导出的镜像。</p><h3 id="语法-30"><a href="#语法-30" class="headerlink" title="语法"></a>语法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">load</span> [<span class="hljs-keyword">OPTIONS</span>]<br></code></pre></td></tr></table></figure><p>OPTIONS 说明：</p><ul><li><p><strong>--input , -i :</strong> 指定导入的文件，代替 STDIN。</p></li><li><p><strong>--quiet , -q :</strong> 精简输出信息。</p></li></ul><h3 id="实例-30"><a href="#实例-30" class="headerlink" title="实例"></a>实例</h3><p>导入镜像：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ docker image ls<br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br><br>$ docker load &lt; busybox.tar.gz<br><br>Loaded image: busybox:latest<br>$ docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937       <span class="hljs-number"> 7 </span>weeks ago         2.489 MB<br><br>$ docker load --input fedora.tar<br><br>Loaded image: fedora:rawhide<br><br>Loaded image: fedora:20<br><br>$ docker images<br><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>busybox             latest              769b9341d937       <span class="hljs-number"> 7 </span>weeks ago         2.489 MB<br>fedora              rawhide             0d20aec6529d       <span class="hljs-number"> 7 </span>weeks ago        <span class="hljs-number"> 387 </span>MB<br>fedora             <span class="hljs-number"> 20 </span>                 58394af37342       <span class="hljs-number"> 7 </span>weeks ago         385.5 MB<br>fedora              heisenbug           58394af37342       <span class="hljs-number"> 7 </span>weeks ago         385.5 MB<br>fedora              latest              58394af37342       <span class="hljs-number"> 7 </span>weeks ago         385.5 MB<br></code></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p><strong>docker import :</strong> 从归档文件中创建镜像。</p><h3 id="语法-31"><a href="#语法-31" class="headerlink" title="语法"></a>语法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">import</span> [<span class="hljs-keyword">OPTIONS</span>] <span class="hljs-keyword">file</span>|URL|- [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-c :</strong> 应用docker 指令创建镜像；</p></li><li><p><strong>-m :</strong> 提交时的说明文字；</p></li></ul><h3 id="实例-31"><a href="#实例-31" class="headerlink" title="实例"></a>实例</h3><p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob&#x2F;ubuntu:v4</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker <span class="hljs-keyword">import</span>  my_ubuntu_v3.tar runoob/<span class="hljs-symbol">ubuntu:</span>v4  <br><span class="hljs-symbol">sha256:</span><span class="hljs-number">63</span>ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39<br>runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker images runoob/<span class="hljs-symbol">ubuntu:</span>v4<br><span class="hljs-title class_">REPOSITORY</span>          <span class="hljs-title class_">TAG</span>                 <span class="hljs-title class_">IMAGE</span> <span class="hljs-title class_">ID</span>            <span class="hljs-title class_">CREATED</span>             <span class="hljs-title class_">SIZE</span><br>runoob/ubuntu       v4                  <span class="hljs-number">63</span>ce4a6d6bc3        <span class="hljs-number">20</span> seconds ago      <span class="hljs-number">142.1</span> <span class="hljs-title class_">MB</span><br></code></pre></td></tr></table></figure><h1 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h1><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p><strong>docker info :</strong> 显示 Docker 系统信息，包括镜像和容器数。。</p><h3 id="语法-32"><a href="#语法-32" class="headerlink" title="语法"></a>语法</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span> [OPTIONS]<br></code></pre></td></tr></table></figure><h3 id="实例-32"><a href="#实例-32" class="headerlink" title="实例"></a>实例</h3><p>查看docker系统信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">docker</span> <span class="hljs-string">info</span><br><span class="hljs-attr">Containers:</span> <span class="hljs-number">12</span><br><span class="hljs-attr">Images:</span> <span class="hljs-number">41</span><br><span class="hljs-attr">Storage Driver:</span> <span class="hljs-string">aufs</span><br> <span class="hljs-attr">Root Dir:</span> <span class="hljs-string">/var/lib/docker/aufs</span><br> <span class="hljs-attr">Backing Filesystem:</span> <span class="hljs-string">extfs</span><br> <span class="hljs-attr">Dirs:</span> <span class="hljs-number">66</span><br> <span class="hljs-attr">Dirperm1 Supported:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">Execution Driver:</span> <span class="hljs-string">native-0.2</span><br><span class="hljs-attr">Logging Driver:</span> <span class="hljs-string">json-file</span><br><span class="hljs-attr">Kernel Version:</span> <span class="hljs-number">3.13</span><span class="hljs-number">.0</span><span class="hljs-number">-32</span><span class="hljs-string">-generic</span><br><span class="hljs-attr">Operating System:</span> <span class="hljs-string">Ubuntu</span> <span class="hljs-number">14.04</span><span class="hljs-number">.1</span> <span class="hljs-string">LTS</span><br><span class="hljs-attr">CPUs:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Total Memory:</span> <span class="hljs-number">1.954</span> <span class="hljs-string">GiB</span><br><span class="hljs-attr">Name:</span> <span class="hljs-string">iZ23mtq8bs1Z</span><br><span class="hljs-attr">ID:</span> <span class="hljs-string">M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW</span><br></code></pre></td></tr></table></figure><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p><strong>docker version :</strong> 显示 Docker 版本信息。</p><h3 id="语法-33"><a href="#语法-33" class="headerlink" title="语法"></a>语法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">version</span> [<span class="hljs-keyword">OPTIONS</span>]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f :</strong> 指定返回值的模板文件。</li></ul><h3 id="实例-33"><a href="#实例-33" class="headerlink" title="实例"></a>实例</h3><p>显示 Docker 版本信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">docker</span> <span class="hljs-string">version</span><br><span class="hljs-attr">Client:</span><br> <span class="hljs-attr">Version:</span>      <span class="hljs-number">1.8</span><span class="hljs-number">.2</span><br> <span class="hljs-attr">API version:</span>  <span class="hljs-number">1.20</span><br> <span class="hljs-attr">Go version:</span>   <span class="hljs-string">go1.4.2</span><br> <span class="hljs-attr">Git commit:</span>   <span class="hljs-string">0a8c2e3</span><br> <span class="hljs-attr">Built:</span>        <span class="hljs-string">Thu</span> <span class="hljs-string">Sep</span> <span class="hljs-number">10</span> <span class="hljs-number">19</span><span class="hljs-string">:19:00</span> <span class="hljs-string">UTC</span> <span class="hljs-number">2015</span><br> <span class="hljs-attr">OS/Arch:</span>      <span class="hljs-string">linux/amd64</span><br><br><span class="hljs-attr">Server:</span><br> <span class="hljs-attr">Version:</span>      <span class="hljs-number">1.8</span><span class="hljs-number">.2</span><br> <span class="hljs-attr">API version:</span>  <span class="hljs-number">1.20</span><br> <span class="hljs-attr">Go version:</span>   <span class="hljs-string">go1.4.2</span><br> <span class="hljs-attr">Git commit:</span>   <span class="hljs-string">0a8c2e3</span><br> <span class="hljs-attr">Built:</span>        <span class="hljs-string">Thu</span> <span class="hljs-string">Sep</span> <span class="hljs-number">10</span> <span class="hljs-number">19</span><span class="hljs-string">:19:00</span> <span class="hljs-string">UTC</span> <span class="hljs-number">2015</span><br> <span class="hljs-attr">OS/Arch:</span>      <span class="hljs-string">linux/amd64</span><br></code></pre></td></tr></table></figure><p><strong>参考资料</strong><br><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全|菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker从入门到实践</title>
    <link href="/2022/09/04/Doker-from-Introduction-to-Practice/"/>
    <url>/2022/09/04/Doker-from-Introduction-to-Practice/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h3><img src="https://img.darklorder.com/img/202308030548065.png" style="zoom:80%;" /><h3 id="Docker的状态转换"><a href="#Docker的状态转换" class="headerlink" title="Docker的状态转换"></a>Docker的状态转换</h3><img src="https://img.darklorder.com/img/202305111341723.png" style="zoom:80%;" /><h3 id="Docker的启动流程"><a href="#Docker的启动流程" class="headerlink" title="Docker的启动流程"></a>Docker的启动流程</h3><img src="https://img.darklorder.com/img/202308030544738.png" style="zoom:80%;" /><h3 id="Docker的事件机制"><a href="#Docker的事件机制" class="headerlink" title="Docker的事件机制"></a>Docker的事件机制</h3><img src="https://img.darklorder.com/img/202308030555519.png" style="zoom:80%;" /><h3 id="Docker-三剑客"><a href="#Docker-三剑客" class="headerlink" title="Docker 三剑客"></a>Docker 三剑客</h3><ul><li>Docker Compose</li><li>Docker Machine</li><li>Docker Swarm</li></ul><p><strong>参考资料</strong><br><a href="https://">XXXX</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基本概念</title>
    <link href="/2022/09/03/Docker-basic-concepts/"/>
    <url>/2022/09/03/Docker-basic-concepts/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="Docker-概念"><a href="#Docker-概念" class="headerlink" title="Docker 概念"></a>Docker 概念</h3><p>  当我们请求 Docker 运行容器时，Docker 会在计算机上设置一个资源隔离的环境。然后将打包的应用程序和关联的文件复制到 Namespace 内的文件系统中，此时环境的配置就完成了。之后 Docker 会执行我们预先指定的命令，运行应用程序。</p><blockquote><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote><p><strong>核心概念</strong></p><ul><li><p><code>Build</code>, <code>Ship and Run</code>（搭建、运输、运行）；</p></li><li><p><code>Build once</code>, <code>Run anywhere</code>（一次搭建，处处运行）；</p></li><li><p>Docker 本身并不是容器，它是创建容器的工具，是应用容器引擎；</p></li><li><p>Docker 三大核心概念，分别是：镜像 Image，容器 Container、仓库 Repository；</p></li><li><p>Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。</p></li><li><p>由于 Namespace 和 Cgroups 功能仅在 Linux 上可用，因此容器无法在其他操作系统上运行。那么 Docker 如何在 macOS 或 Windows 上运行？Docker 实际上使用了一个技巧，并在非 Linux 操作系统上安装 Linux 虚拟机，然后在虚拟机内运行容器。</p></li><li><p>镜像是一个可执行包，其包含运行应用程序所需的代码、运行时、库、环境变量和配置文件，容器是镜像的运行时实例。</p></li></ul><p><strong>Docker 的主要用途，目前有三大类。</strong></p><p><strong>（1）提供一次性的环境。</strong> 比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong> 因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong> 通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><img src="https://img.darklorder.com/img/202111271935108.png"/><h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>dotCloud公司的Docker项目最初也是建立在<strong>LXC</strong>之上，以促进容器技术对开发人员和用户更加友好；</p><ul><li>不久之后，Docker便使用了自行研发的<strong>libcontainer</strong>取代了LXC</li><li>在Docker项目声名大噪之后，dotCloud公司也更名为Docker</li></ul><p>最终，<strong>Docker</strong>于<strong>2013</strong>年发布，解决了开发人员在端到端到运行容器时遇到的许多问题</p><ul><li>容器镜像格式</li><li>构建容器镜像：Dockerfile、docker build</li><li>容器镜像管理：docker image、docker rmi</li><li>容器实例管理：docker ps、docker rm、……</li><li>共享容器镜像：docker push&#x2F;pull</li><li>运行容器镜像的方式：docker run</li></ul><h3 id="Docker-系统组件"><a href="#Docker-系统组件" class="headerlink" title="Docker 系统组件"></a>Docker 系统组件</h3><img src="https://img.darklorder.com/img/202111271940584.png"/><p>Docker系统有三个关键组件  (C&#x2F;S架构)</p><ul><li>Docker CLI（<strong>客户端</strong>）</li><li>Docker Daemon（<strong>守护进程</strong> 管理本地组件）</li><li>Registry（<strong>注册表</strong> 存，检索）</li></ul><p>Docker Daemon</p><ul><li><p>REST API（衔接 Docker Daemon和Docker CLI）（http）</p></li><li><p>Objects （<strong>对象</strong>：Resource资源实例化）</p><p>Image（<strong>镜像</strong>）</p><p>Container （<strong>容器</strong>)</p><p>Volume（<strong>数据卷</strong>）</p><p>Network（<strong>网络</strong>）</p></li></ul><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>运行容器时，基于Mount名称空间建立的隔离文件系统中的内容来自镜像</p><ul><li>Docker镜像是一个特殊的文件系统，它必须包含运行应用程序所需的一切——所有依赖项、配置、脚本、二进制文件等</li><li>镜像还包含容器的其他配置，例如环境变量、要运行的默认命令、 和其他元数据</li><li>通常，镜像还要定义默认启动的应用</li></ul><p>Docker镜像由许多层（Layer）叠加而成</p><ul><li>依赖于特殊的存储驱动，例如aufs、devicemapper、overlay2等</li><li>尽管每种存储驱动程序实现的管理方式不尽相同，但它们都使用可堆叠的镜像层和写时复制（CoW）策略</li></ul><h3 id="Docker-容器-1"><a href="#Docker-容器-1" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>运行有Docker Daemon的主机负责管理本地容器实例的生命周期</p><ul><li><p>Docker Daemon通过其监听的Socket API接收Docker对象的管理请求，包括容器的生命周期中的各类管理操作</p></li><li><p>容器实例的创建要基于本地存储的Docker镜像进行</p></li><li><p>实例启动后，要在前台（foreground，不能转为守护进程模式）运行镜像中定义的默认应用，或用户指定的应用</p></li></ul><p>创建容器时，指定了本地不存在的镜像时，则需要由Docker Daemon自动至Registry上进行下载</p><ul><li>Docker Daemon 默认使用的Registry是<a href="https://registry.hub.docker.com/">DockerHub</a></li></ul><h3 id="从Docker说起"><a href="#从Docker说起" class="headerlink" title="从Docker说起"></a>从Docker说起</h3><p>OCI (Open Container Initiative)</p><ul><li><p>较早版本的Docker是一个单体系统，但其内部的各类功能间并不存在依赖关系，每类功能都可以在一个独立的工具中实现，而且每个工具都可以基于通用格式和同一个容器标准来协作</p></li><li><p>于是，2015年6月，Docker、Google、CoreOS和其他供应商创建了OCI标准，它包括</p><pre><code class="hljs">    image-spec：镜像格式规范    runtime-spec：运行时规范</code></pre></li><li><p>Docker将用于运行容器的代码（libcontainer）作为一个名为runC的项目分解出来，并捐赠给了OCI作为参考实现</p></li></ul><img src="https://img.darklorder.com/img/202111272119098.png" style="zoom:50%;" /><h3 id="Docker-程序组件"><a href="#Docker-程序组件" class="headerlink" title="Docker 程序组件"></a>Docker 程序组件</h3><p>为了兼容OCI规范，自1.11.0版本起始，Docker引擎由一个单一组件拆分成4个独立的项目</p><ul><li><p>Docker engine（Docker-daemon）</p></li><li><p>containerd：守护进程，高级别的container runtime</p><pre><code class="hljs">几乎囊括了容器运行时所需要的容器创建、启动、停止、中止、信号处理和删除，以及镜像管理（镜像和元信息等）等所有功能通过grpc向上层调用者公开其API，可被兼容的任何上层系统所调用，例如Docker Engine或kubernetes等容器编排系统但具体的容器管理还需要OCI兼容的runtime负责完成</code></pre></li><li><p>containerd-shim：支持多种不同的OCI runtime</p><pre><code class="hljs">containerd-shim 的意思是垫片，类似于拧螺丝时夹在螺丝和螺母之间的垫片。containerd-shim 的主要作用是将 containerd 和真正的容器进程解耦，使用 containerd-shim 作为容器进程的父进程，从而实现重启 containerd 不影响已经启动的容器进程。</code></pre></li><li><p>runc：低级别的container runtime</p></li></ul><img src="https://img.darklorder.com/img/202111272129706.png" style="zoom: 55%;" /><img src="https://img.darklorder.com/img/202111272128656.png" style="zoom: 39%;" /><h3 id="低级和高级容器运行时"><a href="#低级和高级容器运行时" class="headerlink" title="低级和高级容器运行时"></a>低级和高级容器运行时</h3><p>当人们想到容器运行时，可能会想到一系列示例；runc、lxc、lmctfy、Docker（容器）、rkt、cri-o。这些中的每一个都是为不同的情况而构建的，并实现了不同的功能。有些，如 containerd 和 cri-o，实际上使用 runc 来运行容器，在High-Level实现镜像管理和 API。与 runc 的Low-Level实现相比，可以将这些功能（包括镜像传输、镜像管理、镜像解包和 API）视为High-Level功能。考虑到这一点，您可以看到容器运行时空间相当复杂。每个运行时都涵盖了这个Low-Level到High-Level频谱的不同部分。这是一个非常主观的图表：</p><img src="https://img.darklorder.com/img/202308030314104.png"/><p>因此，从实际出发，通常只专注于正在运行的容器的runtime通常称为“Low-Level容器运行时”，支持更多高级功能（如镜像管理和gRPC &#x2F; Web API）的运行时通常称为“High-Level容器运行时”，“High-Level容器运行时”或通常仅称为“容器运行时”，我将它们称为“High-Level容器运行时”。值得注意的是，Low-Level容器运行时和High-Level容器运行时是解决不同问题的、从根本上不同的事物。</p><p>Low-Level容器运行时：容器是通过Linux nanespace和Cgroups实现的，Namespace能让你为每个容器提供虚拟化系统资源，像是文件系统和网络，Cgroups提供了限制每个容器所能使用的资源的如内存和CPU使用量的方法。在最低级别的运行时中，容器运行时负责为容器建立namespaces和cgroups,然后在其中运行命令，Low-Level容器运行时支持在容器中使用这些操作系统特性。目前来看低级容器运行时有：runc ：我们最熟悉也是被广泛使用的容器运行时，代表实现Docker。runv：runV 是一个基于虚拟机管理程序（OCI）的运行时。它通过虚拟化 guest kernel，将容器和主机隔离开来，使得其边界更加清晰，这种方式很容易就能帮助加强主机和容器的安全性。代表实现是kata和Firecracker。runsc：runsc &#x3D; runc + safety ，典型实现就是谷歌的gvisor，通过拦截应用程序的所有系统调用，提供安全隔离的轻量级容器运行时沙箱。截止目前，貌似并不没有生产环境使用案例。wasm : Wasm的沙箱机制带来的隔离性和安全性，都比Docker做的更好。但是wasm 容器处于草案阶段，距离生产环境尚有很长的一段路。</p><p>High-Level容器运行时：通常情况下，开发人员想要运行一个容器不仅仅需要Low-Level容器运行时提供的这些特性，同时也需要与镜像格式、镜像管理和共享镜像相关的API接口和特性，而这些特性一般由High-Level容器运行时提供。就日常使用来说，Low-Level容器运行时提供的这些特性可能满足不了日常所需，因为这个缘故，唯一会使用Low-Level容器运行时的人是那些实现High-Level容器运行时以及容器工具的开发人员。那些实现Low-Level容器运行时的开发者会说High-Level容器运行时比如containerd和cri-o不像真正的容器运行时，因为从他们的角度来看，他们将容器运行的实现外包给了runc。但是从用户的角度来看，它们只是提供容器功能的单个组件，可以被另一个的实现替换，因此从这个角度将其称为runtime仍然是有意义的。即使containerd和cri-o都使用runc，但是它们是截然不同的项目，支持的特性也是非常不同的。dockershim, containerd 和cri-o都是遵循CRI的容器运行时，我们称他们为高层级运行时（High-level Runtime）。<br>Kubernetes 只需支持 containerd 等high-level container runtime即可。由containerd 按照OCI 规范去对接不同的low-level container runtime，比如通用的runc，安全增强的gvisor，隔离性更好的runv。</p><h3 id="CRI和容器运行时"><a href="#CRI和容器运行时" class="headerlink" title="CRI和容器运行时"></a>CRI和容器运行时</h3><p>我们知道 Kubernetes 提供了一个 CRI 的容器运行时接口，那么这个 CRI 到底是什么呢？这个其实也和 Docker 的发展密切相关的。</p><p>在 Kubernetes 早期的时候，当时 Docker 实在是太火了，Kubernetes 当然会先选择支持 Docker，而且是通过硬编码的方式直接调用 Docker API，后面随着 Docker 的不断发展以及 Google 的主导，出现了更多容器运行时，Kubernetes 为了支持更多更精简的容器运行时，Google 就和红帽主导推出了 CRI 标准，用于将 Kubernetes 平台和特定的容器运行时（当然主要是为了干掉 Docker）解耦。</p><p>CRI（Container Runtime Interface 容器运行时接口）本质上就是 Kubernetes 定义的一组与容器运行时进行交互的接口，所以只要实现了这套接口的容器运行时都可以对接到 Kubernetes 平台上来。不过 Kubernetes 推出 CRI 这套标准的时候还没有现在的统治地位，所以有一些容器运行时可能不会自身就去实现 CRI 接口，于是就有了 shim（垫片）， 一个 shim 的职责就是作为适配器将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上，其中 dockershim 就是 Kubernetes 对接 Docker 到 CRI 接口上的一个垫片实现。</p><img src="https://img.darklorder.com/img/202308030329960.png"/><p>Kubelet 通过 gRPC 框架与容器运行时或 shim 进行通信，其中 kubelet 作为客户端，CRI shim（也可能是容器运行时本身）作为服务器。</p><p>CRI 定义的 API(<a href="https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto">https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto</a>) 主要包括两个 gRPC 服务，ImageService 和 RuntimeService，ImageService 服务主要是拉取镜像、查看和删除镜像等操作，RuntimeService 则是用来管理 Pod 和容器的生命周期，以及与容器交互的调用（exec&#x2F;attach&#x2F;port-forward）等操作，可以通过 kubelet 中的标志 –container-runtime-endpoint 和 –image-service-endpoint 来配置这两个服务的套接字。</p><img src="https://img.darklorder.com/img/202308030351171.png"/><p>不过这里同样也有一个例外，那就是 Docker，由于 Docker 当时的江湖地位很高，Kubernetes 是直接内置了 dockershim 在 kubelet 中的，所以如果你使用的是 Docker 这种容器运行时的话是不需要单独去安装配置适配器之类的，当然这个举动似乎也麻痹了 Docker 公司。</p><img src="https://img.darklorder.com/img/202308030351558.png"/><p>现在如果我们使用的是 Docker 的话，当我们在 Kubernetes 中创建一个 Pod 的时候，首先就是 kubelet 通过 CRI 接口调用 dockershim，请求创建一个容器，kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server，不过他们都是在 kubelet 内置的。</p><p>dockershim 收到请求后, 转化成 Docker Daemon 能识别的请求, 发到 Docker Daemon 上请求创建一个容器，请求到了 Docker Daemon 后续就是 Docker 创建容器的流程了，去调用 containerd，然后创建 containerd-shim 进程，通过该进程去调用 runc 去真正创建容器。</p><p>其实我们仔细观察也不难发现使用 Docker 的话其实是调用链比较长的，真正容器相关的操作其实 containerd 就完全足够了，Docker 太过于复杂笨重了，当然 Docker 深受欢迎的很大一个原因就是提供了很多对用户操作比较友好的功能，但是对于 Kubernetes 来说压根不需要这些功能，因为都是通过接口去操作容器的，所以自然也就可以将容器运行时切换到 containerd 来。</p><img src="https://img.darklorder.com/img/202308030329927.png"/><p>切换到 containerd 可以消除掉中间环节，操作体验也和以前一样，但是由于直接用容器运行时调度容器，所以它们对 Docker 来说是不可见的。 因此，你以前用来检查这些容器的 Docker 工具就不能使用了。</p><p>你不能再使用 docker ps 或 docker inspect 命令来获取容器信息。由于不能列出容器，因此也不能获取日志、停止容器，甚至不能通过 docker exec 在容器中执行命令。</p><p>当然我们仍然可以下载镜像，或者用 docker build 命令构建镜像，但用 Docker 构建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。为了在 Kubernetes 中使用，需要把镜像推送到镜像仓库中去。</p><p>从上图可以看出在 containerd 1.0 中，对 CRI 的适配是通过一个单独的 CRI-Containerd 进程来完成的，这是因为最开始 containerd 还会去适配其他的系统（比如 swarm），所以没有直接实现 CRI，所以这个对接工作就交给 CRI-Containerd 这个 shim 了。</p><p>然后到了 containerd 1.1 版本后就去掉了 CRI-Containerd 这个 shim，直接把适配逻辑作为插件的方式集成到了 containerd 主进程中，现在这样的调用就更加简洁了。</p><img src="https://img.darklorder.com/img/202308030329202.png"/><p>与此同时 Kubernetes 社区也做了一个专门用于 Kubernetes 的 CRI 运行时 <a href="https://cri-o.io/">CRI-O</a>，直接兼容 CRI 和 OCI 规范。</p><img src="https://img.darklorder.com/img/202308030329388.png"/><p>这个方案和 containerd 的方案显然比默认的 dockershim 简洁很多，不过由于大部分用户都比较习惯使用 Docker，所以大家还是更喜欢使用 dockershim 方案。</p><p>但是随着 CRI 方案的发展，以及其他容器运行时对 CRI 的支持越来越完善，Kubernetes 社区在 2020 年 7 月份就开始着手移除 dockershim 方案了：<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E9%99%A4%E8%AE%A1%E5%88%92%E6%98%AF%E5%9C%A8">https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim，现在的移除计划是在</a> 1.20 版本中将 kubelet 中内置的 dockershim 代码分离，将内置的 dockershim 标记为维护模式，当然这个时候仍然还可以使用 dockershim，目标是在 1.23&#x2F;1.24 版本发布没有 dockershim 的版本（代码还在，但是要默认支持开箱即用的 docker 需要自己构建 kubelet，会在某个宽限期过后从 kubelet 中删除内置的 dockershim 代码）。</p><p>那么这是否就意味这 Kubernetes 不再支持 Docker 了呢？当然不是的，这只是废弃了内置的 dockershim 功能而已，Docker 和其他容器运行时将一视同仁，不会单独对待内置支持，如果我们还想直接使用 Docker 这种容器运行时应该怎么办呢？可以将 dockershim 的功能单独提取出来独立维护一个 cri-dockerd 即可，就类似于 containerd 1.0 版本中提供的 CRI-Containerd，当然还有一种办法就是 Docker 官方社区将 CRI 接口内置到 Dockerd 中去实现。</p><p>但是我们也清楚 Dockerd 也是去直接调用的 Containerd，而 containerd 1.1 版本后就内置实现了 CRI，所以 Docker 也没必要再去单独实现 CRI 了，当 Kubernetes 不再内置支持开箱即用的 Docker 的以后，最好的方式当然也就是直接使用 Containerd 这种容器运行时，而且该容器运行时也已经经过了生产环境实践的，接下来我们就来学习下 Containerd 的使用。</p><p><strong>Containerd</strong></p><p>我们知道很早之前的 Docker Engine 中就有了 containerd，只不过现在是将 containerd 从 Docker Engine 里分离出来，作为一个独立的开源项目，目标是提供一个更加开放、稳定的容器运行基础设施。分离出来的 containerd 将具有更多的功能，涵盖整个容器运行时管理的所有需求，提供更强大的支持。</p><p>containerd 是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性，containerd 可以负责干下面这些事情：</p><ul><li>管理容器的生命周期（从创建容器到销毁容器）</li><li>拉取&#x2F;推送容器镜像</li><li>存储管理（管理镜像及容器数据的存储）</li><li>调用 runc 运行容器（与 runc 等容器运行时交互）</li><li>管理容器网络接口及网络</li></ul><p><strong>架构</strong></p><p>containerd 可用作 Linux 和 Windows 的守护程序，它管理其主机系统完整的容器生命周期，从镜像传输和存储到容器执行和监测，再到底层存储到网络附件等等。</p><img src="https://img.darklorder.com/img/202308030352947.png"/>上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C/S 架构，服务端通过 unix domain socket 暴露低层的 gRPC API 接口出去，客户端通过这些 API 管理节点上的容器，每个 containerd 只负责一台机器，Pull 镜像，对容器的操作（启动、停止等），网络，存储都是由 containerd 完成。具体运行容器由 runc 负责，实际上只要是符合 OCI 规范的容器都可以支持。<p>为了解耦，containerd 将系统划分成了不同的组件，每个组件都由一个或多个模块协作完成（Core 部分），每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的，例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 Service Plugin、Metadata Plugin、GC Plugin、Runtime Plugin 等，其中 Service Plugin 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 Metadata Plugin 依赖 Containers Plugin、Content Plugin 等。比如:</p><ul><li>Content Plugin: 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。</li><li>Snapshot Plugin: 用来管理容器镜像的文件系统快照，镜像中的每一层都会被解压成文件系统快照，类似于 Docker 中的 graphdriver。</li></ul><p>总体来看 containerd 可以分为三个大块：Storage、Metadata 和 Runtime。</p><img src="https://img.darklorder.com/img/202308030352693.png"/><p><strong>参考资料</strong><br>Kubernetes进阶实战<br><a href="https://cloud.tencent.com/developer/article/1895805">Docker、Containerd、RunC分别是什么-腾讯云开发者社区-运维开发故事</a><br><a href="https://cloud.tencent.com/developer/article/1895808">真正运行容器的工具：深入了解 runc 和 OCI 规范-腾讯云开发者社区-运维开发故事</a><br><a href="https://www.qikqiak.com/post/containerd-usage/">一文搞懂容器运行时 Containerd-阳明的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器简介</title>
    <link href="/2022/09/02/Introduction-to-Docker-Containers/"/>
    <url>/2022/09/02/Introduction-to-Docker-Containers/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h2><p><strong>Docker</strong> 最初是 <code>dotCloud</code> 公司创始人 <a href="https://github.com/shykes">Solomon Hykes</a> 在法国期间发起的一个公司内部项目，它是基于 <code>dotCloud</code> 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby">GitHub</a> 上进行维护。<code>Docker</code> 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://opencontainers.org/">开放容器联盟（OCI）</a>。</p><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby">GitHub 项目</a> 已经超过 5 万 7 千个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，<a href="https://www.docker.com/blog/dotcloud-is-becoming-docker-inc/">dotCloud 公司决定改名为 Docker</a>。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p><img src="https://img.darklorder.com/img/202308011722747.png"/><p>Docker 架构</p><blockquote><p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec">OCI容器运行时规范</a> 创建和运行容器。</p></blockquote><blockquote><p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p></blockquote><p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><img src="https://img.darklorder.com/img/202308011725697.png"/><p>传统虚拟化</p><img src="https://img.darklorder.com/img/202308011725945.png"/><p>Docker</p><h2 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h2><p>作为一种新兴的虚拟化方式，<code>Docker</code> 跟传统的虚拟化方式相比具有众多的优势。</p><p><strong>更高效的利用系统资源</strong></p><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><p><strong>更快速的启动时间</strong></p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong>一致的运行环境</strong></p><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><p><strong>持续交付和部署</strong></p><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery&#x2F;Deployment)</a> 系统进行自动部署。</p><p>而且使用 <a href="https://yeasy.gitbook.io/docker_practice/image/build"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><p><strong>更轻松的迁移</strong></p><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p><strong>更轻松的维护和扩展</strong></p><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><p><strong>对比传统虚拟机总结</strong></p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。</p><p>开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。Docker是容器的一种，还有其他容器，比如 CoreOS 的 rkt。</p><p>容器有效的将单个操作系统的资源划分到孤立的组中，以便更好的在孤立的组之间平衡有冲突的资源使用需求。</p><p>其实容器本身并不是一个特别新的技术，早在2000年就已经有了，当时是用来在chroot环境(隔离mount namespac的工具)中做进程隔离（使用namespac和cgroups）</p><p>容器的本质，一句话解释，就是一组受到资源限制，彼此间相互隔离的进程。实现起来也并不复杂，隔离所用到的技术都是由linux内核本身提供的（所以说目前绝大部分的容器都是必须要跑在linux里面的）。其中<code>namespace</code>用来做访问隔离（每个容器进程都有自己独立的进程空间，看不到其他进程），<code>cgroups</code>用来做资源限制（cpu、内存、存储、网络的使用限制）。</p><p>总的来说容器就是一种基于操作系统能力的隔离技术，这和虚拟化技术不可同日而语。</p><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>分层构建（Layered Construction）、联合挂载（Union Mounting）和写时复制（Copy-on-Write）是三种 Linux 文件系统的特性，它们在容器技术中广泛应用。</p><ul><li><p>分层构建：分层构建是指将一个文件系统划分为多个层次，每个层次只包含文件系统的一部分。这种分层构建的优点是可以重用已有的文件系统层次，提高了构建效率。在容器中，分层构建使得容器只需要记录自己的变更，从而避免了重复存储文件系统的问题。</p></li><li><p>联合挂载：联合挂载是指将多个文件系统联合成一个虚拟文件系统。在联合挂载的过程中，只有最上层的文件系统是可写的，其余文件系统只读。在容器中，联合挂载使得容器可以使用主机上的一些文件系统，从而避免了容器中需要存储相同的文件系统的问题。</p></li><li><p>写时复制：写时复制是指当一个进程试图修改一个文件时，会先将这个文件复制到一个新的位置，然后在新的位置上进行修改，从而避免了原始文件的修改。在容器中，写时复制可以使得容器只需要记录自己的变更，从而避免了对主机上原始文件的修改。</p></li></ul><p>这三种特性在容器技术中被广泛应用，使得容器可以更高效地运行，同时也降低了容器与主机之间的耦合度。</p><h2 id="深入剖析"><a href="#深入剖析" class="headerlink" title="深入剖析"></a>深入剖析</h2><h3 id="初出茅庐"><a href="#初出茅庐" class="headerlink" title="初出茅庐"></a>初出茅庐</h3><p><strong>PaaS项目被大家接纳的一个主要原因</strong></p><ul><li>它提供了一种名叫“应用托管”的能力。 </li><li>租一批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，用脚本或者手工的方式在这些机器上部署应用。</li></ul><blockquote><p>缺点：部署过程难免会碰到云端虚拟机和本地环境不一致的问题。</p></blockquote><p><strong>当年PaaS开源项目最佳方案</strong></p><ul><li>Cloud Foundry 项目</li><li>核心组件 一套应用的打包和分发机制</li></ul><blockquote><p>为每种主流编程语音都定义了一种打包格式,把应用的可执行文件和启动脚本打进一个压缩包内,上传到云端的存储中<br>通过调度器选择一个可以运行这个应用的虚拟机,然后通知这个机器上的Agent把应用压缩包下载下来启动。</p></blockquote><p><strong>PaaS项目最核心的能力</strong></p><ul><li>运行应用的隔离环境</li><li>或者说“沙盒”</li><li>就是所谓的“容器”</li></ul><blockquote><p>由于需要在一个虚拟机上启动很多个来自不同用户的应用,会调用操作系统的Cgroups和Namespace机制为每一个应用单独创建一个称作”沙盒”的隔离环境,然后在”沙盒”中启动这些应用程序。</p></blockquote><h3 id="崭露头角"><a href="#崭露头角" class="headerlink" title="崭露头角"></a>崭露头角</h3><p><strong>Dcoker项目能取得高关注度的原因</strong></p><ul><li>解决了应用打包和发布这一困扰运维人员多年的技术难题</li><li>第一次把一个纯后端技术的概念,通过非常友好的设计,交到了最广大的开发者群体手里</li></ul><p><strong>Docker公司为什么一定要发布Swarm项目</strong></p><ul><li>Docker项目从发布之初就全面发力,从技术,社区,商业,市场全方位争取到的开发者群体,实际上是为此后吸引整个生态到自家”PaaS”上的一个铺垫.</li><li>只不过这时,PaaS的定义已经全然不是Docker公司描述的那个样子,而是变成了一套以Docker容器为技术核心,以Docker容器为技术核心,以Docker镜像为打包标准的,全新的容器化思路</li><li>这正是Docker项目从一开始悉心运作容器化理念和经营整个Docker生态的主要目的</li><li>而Swarm项目正式接下来承接Docker公司所有这些努力的关键所在</li></ul><p><strong>Docker在短时间内迅速崛起的三个重要原因</strong></p><ul><li>Docker镜像通过技术手段解决了PaaS的根本性问题</li><li>Docker容器同开发者之间有着与生俱来的关系</li><li>PaaS概念已经深入人心的完美时机</li></ul><h3 id="群雄并起"><a href="#群雄并起" class="headerlink" title="群雄并起"></a>群雄并起</h3><p><strong>Docker和CoreOS停止合作</strong></p><ul><li>根本原因是Docker公司对Docker项目定位的不满足,想让Docker项目提供更多的平台层能力,即向PaaS项目进化</li><li>这显然与CoreOS公司的核心产品和战略发生了冲突</li></ul><p><strong>Swarm项目的亮点</strong></p><ul><li>完全使用Docker项目原本的容器管理API来完成集群管理的</li></ul><p><strong>什么是编排</strong></p><ul><li>主要是指用户如何通过某些或者配置来完成一组虚拟机以及关联资源的定义,配置,创建,删除等工作,然后由平台按照这些指定的逻辑来完成的过程</li></ul><p><strong>Fig项目(后来的compose)</strong></p><ul><li>Fig在开发者面前第一次提出了”容器编排的概念”</li><li>容器和容器之间的关联关系,会由Fig交给Docker的Link功能通过写入Host文件的方式进行配置</li><li>Fig被收购之后改名为Compose,他成为Docker公司目前为止第二大受欢迎的项目</li></ul><p><strong>Docker公司收购的项目</strong></p><ul><li>Fig –&gt; 编排</li><li>SockerPlane –&gt; 容器网络</li><li>Flocker –&gt; 容器存储（EMC公司收购）</li><li>Tutum –&gt; Docker集群图形化管理界面和提供云服务</li></ul><p><strong>Mesos</strong></p><ul><li>Messos作为Berkeley主导的大数据套件之一,是大数据火热时最受欢迎的资源管理项目</li><li>发布Marathon实现了应用托管和负载均衡的PaaS功能</li><li>Messos拥有超大规模集群的管理经验</li></ul><h3 id="尘埃落定"><a href="#尘埃落定" class="headerlink" title="尘埃落定"></a>尘埃落定</h3><p><strong>容器编排领域的两个压力</strong></p><ul><li>Swarm擅长的是跟Docker生态的无缝集成</li><li>Messos擅长的则是大规模集群的调度与管理</li><li>Kubernetes借用Borg和Omega系统的内部特性</li></ul><p><strong>基于Kubernetes的api和扩展接口的二次创新</strong></p><ul><li>目前热度极高的微服务治理项目Istio</li><li>被广泛采用的有状态应用部署框架Operator</li><li>还有像Rook这样的开源创业项目,它通过Kubernetes的可扩展接口,把Ceph这样的重量级产品封装成了简单易用的容器存储插件</li></ul><p><strong>编排落下帷幕</strong></p><ul><li>2017年10月,Docker公司出人意料的宣布,将在自己的主打产品Docker企业版中内置Kubernetes项目</li><li>这标志着持续了进两年之久的”编排之争”至此落下帷幕</li></ul><p><strong>Kubernetes成功的必然性</strong></p><ul><li>Docker公司最后是将开源项目和商业产品紧密绑定,打造一个极端封闭的技术生态</li><li>这其实违背了Docker项目与开发者保持密切关系的初衷</li><li>而Kubernetes社区正是以一种更加温和的方式,承接了Docker项目的未尽事业</li><li>即:以开发者为核心,构建一个相对民主和开放的容器生态</li></ul><h3 id="从进程说开去"><a href="#从进程说开去" class="headerlink" title="从进程说开去"></a>从进程说开去</h3><p><strong>容器技术的几个事实</strong></p><ul><li>容器技术的兴起起源于PaaS技术的普及</li><li>Docker公司发布的Docker项目具有里程碑式的意义</li><li>Docker项目通过”容器镜像”,解决了应用打包这个根本性难题</li></ul><p><strong>什么是容器</strong></p><ul><li>容器就是一种沙盒技术,把你的应用”装起来”,让其能够方便的搬来搬去</li></ul><p><strong>进程</strong></p><ul><li>一旦程序被执行起来,它就从磁盘上的二进制文件,</li><li>变成了计算机内存中的数据,寄存器里的值,堆栈中的指令,被打开的文件,以及各种设备的状态信息的一个集合.</li><li>像这样一个程序运行起来后的计算机执行环境的总和,就是进程</li></ul><p><strong>进程的动态表现</strong></p><ul><li>进程的静态表现就是程序,平时都安安静静的待在磁盘上</li><li>一旦运行起来,它就变成了计算机里的数据和状态的总和,这就是它的动态表现</li></ul><p><strong>容器的核心功能</strong></p><ul><li>通过约束和修改进程的动态表现,为期创造出一个”边界”</li></ul><p><strong>容器的特性</strong></p><ul><li>容器内的第一个进程的PID是1,其实是对被隔离的应用的进程空间做了手脚,</li><li>使得这些进程只能看到重新计算过的进程编号,比如PID&#x3D;1,可实际上,</li><li>他们在宿主机的操作系统里,就是一个普通的进程</li></ul><p><strong>容器名称空间</strong>Namespace</p><ul><li>Mount 挂载文件系统</li><li>UTS 主机名和域名</li><li>IPC 进程间通信</li><li>Network 网络</li><li>User 用户</li><li>PID 进程ID</li></ul><p><strong>Docker并不是”轻量级”虚拟化技术</strong></p><ul><li>跟真实存在的虚拟机不同,在使用Docker时,并没有一个真正的”Docker容器”运行在宿主机里面</li><li>Docker项目帮助用户启动的,还是原来的应用进程,只不过在创建这些进程的时候,</li><li>Docker为他们加上了各种各样的Namespace参数,</li><li>这时这些进程就会觉得自己是各PID Namespace里的第一号进程</li><li>只能看到各自Mount Namespace里挂载的目录和文件,只能访问到各自Network Namespace里的网路设备</li><li>仿佛在一个个”容器”里面,与世隔绝</li></ul><h3 id="隔离与限制"><a href="#隔离与限制" class="headerlink" title="隔离与限制"></a>隔离与限制</h3><p><strong>传统虚拟机和Docker架构图</strong></p><img src="https://img.darklorder.com/img/202308011842921.png"/><ul><li>对比图中Docker和应用同级别并且在靠边的位置</li><li>用户在容器里的应用进程,跟宿主机上的其他进程一样,都由宿主机操作系统统一管理</li><li>只不过这些被隔离的进程拥有额外设置过的Namespace参数</li><li>Docker在这里扮演的更多是旁路是的辅助和管理工作</li></ul><p><strong>KVM虚拟机和容器的性能</strong></p><ul><li>一个运行CentOS的KVM虚拟机在不做优化的情况下,虚拟机自己就要占用100-200MB内存</li><li>用户应用会被宿主机操作系统拦截和处理,损耗性能</li><li>容器化的应用依然是宿主机的一个进程,不存在虚拟化带来的性能损耗</li><li>使用Namespace作为隔离手段的容器并不需要单独的Guest OS,容器额外资源占用几乎不存在</li><li>“敏捷”和”高性能”是容器对比虚拟机的最大优势</li></ul><p><strong>容器的隔离不彻底</strong></p><ul><li>宿主机上的多个容器之间使用的还是同一个宿主机的操作系统内核</li><li>很多资源和对象不能被Namespace化,比如时间</li></ul><p><strong>Cgroups资源限制</strong></p><ul><li>blkio 为块设备设定I&#x2F;O限制,一般用于磁盘等设置</li><li>cpuset 为进程分配单独的CPU核和对应的内存节点</li><li>memory 为进程设定内存使用的限制</li></ul><p><strong>容器是单进程模型</strong></p><ul><li>容器的本质就是一个进程,用户的应用进程实际上就是容器里的PID&#x3D;1的进程</li><li>也是其他后续的所有进程的父进程</li><li>在一个容器中,只能实现找到一个公共的PID&#x3D;1的程序来充当两个不同应用的父进程</li><li>这就是为什么很多人会使用systemd或者supervisord这样的软件来替代应用本身作为容器的启动进程</li></ul><blockquote><p>一个正在运行的 Docker 容器，其实就是一个启用了多个<br>Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。</p></blockquote><p><strong>容器编排与容器生命周期</strong></p><ul><li>容器本身的设计是希望容器和应用能够同生命周期</li><li>否则一旦出现容器是正常运行的,但是应用早就挂了的情况</li><li>在容器编排处理起来就很麻烦了</li></ul><p><strong>Cgroups不完善的地方&#x2F;proc文件系统</strong></p><ul><li>Linux下的&#x2F;proc目录存储是记录当前内核运行状态的一系列特殊文件</li><li>用户能通过这些文件,查看系统以及当前正在运行的进程的信息,</li><li>比如CPU使用,内存占用等,这些信息是top命令的主要信息来源</li><li>如果你在容器中执行top指令,就会发现它显示的是宿主机的CPU和内存数据,并不是当前容器的数据</li><li>因为&#x2F;proc文件系统并不知道用户通过Cgroups给这个容器做了什么资源限制</li><li>即&#x2F;proc文件系统并不了解Cgroup限制的存在</li><li>生产环境中必须修正这个问题,否则应用程序在容器里读取到的CPU核数,可用内存等信息都是宿主机上的数据</li><li>会给应用的运行带来非常大的风险和困惑,这是容器化相较于虚拟机不尽人意的地方</li></ul><h3 id="深入理解容器镜像"><a href="#深入理解容器镜像" class="headerlink" title="深入理解容器镜像"></a>深入理解容器镜像</h3><p><strong>Docker项目为待创建的用户进程做了以下事情</strong></p><ul><li>启用Linux Namespace配置</li><li>设置指定的Cgroups参数</li><li>切换进程的跟目录(Change Root)</li></ul><p><strong>注意</strong></p><ul><li>rootfs只是一个操作系统所包含的文件,配置和目录,并不包括操作系统内核</li><li>在Linux操作系统中,这两部分是分开存放的</li><li>操作系统只有在开机启动时才会加载执行指定版本的内核镜像</li><li>rootfs只包括了操作系统的”躯壳”,并没有包括操作系统的”灵魂”</li></ul><p><strong>容器操作系统的”灵魂”</strong></p><ul><li>同一台机器上的所有容器,都共享宿主机操作系统的内核</li><li>容器内的与内核相关的内核参数,内核模块,和内核的直接交互都是”全局变量”,牵一发而动全身</li></ul><p><strong>容器的一致性</strong></p><ul><li>无论在本地,云端,还是在一台任何地方的的机器上</li><li>用户只需要解压打包好的容器镜像,那么这个应用运行所需要的完整的执行环境就被重现出来了</li><li>深入到操作系统级别的运行环境一致性,打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟</li></ul><p><strong>联合文件系统(UnionFS)</strong></p><img src="https://img.darklorder.com/img/202308011850015.png"/><p><strong>第一层,只读层</strong><br>他是这个容器的rootf最下面的五层,对应的正是ubuntu:latest镜像的五层<br>可以看到它们的挂载方式都是只读的(ro+wh即readonly+whiteout)</p><p><strong>第二层,可读写层</strong><br>它是容器rootfs最上面的一层,挂载方式为rw,即read write<br>在没有写入文件之前,这个目录是空的.而且一旦在容器里面做了写操作,<br>你的修改就会以增量的方式出现在这个层中<br>删除文件时,AuFS会在可读写层创建一个whiteout文件,把只读层里的文件遮挡起来</p><p><strong>第三部分,init层</strong><br>它是一个以”-init”结尾的层,夹在只读层和读写层之间<br>init层是Docker项目单独生成的一个内部层,专门用来存放&#x2F;etc&#x2F;hosts, &#x2F;etc&#x2F;resolv.conf等信息<br>需要这样一层的原因是,这些文件本来属于只读层的Ubuntu镜像的一部分<br>但是用户往往需要在容器启动时就写入一些指定的值比如hostname,所以就需要在读写层对他们进行修改<br>可以,这些修改往往只对当前的容器有效,我们并不希望执行docker commit时,<br>把这些信息连同可读写层一起提交掉,所以docker的做法是,在修改了这些文件之后,<br>以一个单独的层挂载了出来,用户执行docker commit只会提交可读写层,所以是不包含这些内容的</p><p><strong>分层镜像的设计好处</strong></p><ul><li>以Docker镜像为核心,将不同技术人员紧密的联系在了一起</li><li>容器镜像是增量式的,每次镜像拉取,推送的内容,比完整操作系统要小得多</li><li>镜像发布之后,在全世界的任何地方下载这个镜像,可以完全复制镜像制作者当时的环境</li></ul><h3 id="重新认识Docker容器"><a href="#重新认识Docker容器" class="headerlink" title="重新认识Docker容器"></a>重新认识Docker容器</h3><p><strong>Docker exec的原理</strong></p><ul><li>一个进程的Namespace信息在宿主机上是确确实实存在的,并且是以一个文件的方式存在</li><li>一个进程,可以选择加入到某个进程已有的Namespace中,从而达到”进入这个进程所在容器的目的”</li></ul><p><strong>Docker commit原理</strong></p><ul><li>实际上就是在容器运行起来后,把最上层的”可读写层”,加上原先容器镜像的只读层</li><li>打包成了一个新的镜像.并且只读层在宿主机是共享的,不会占用额外的空间</li><li>由于使用了联合文件系统,你在容器里镜像rootfs所做的任何修改,</li><li>都会被操作系统复制到这个读写层,然后再修改,这就是所谓的Copy-on-Write</li><li>Init层的存在,就是为了避免执行docker commit时,</li><li>把Docker自己对&#x2F;etc&#x2F;hosts等文件的修改,也一起提交掉</li></ul><p><strong>容器的volume</strong></p><p>docker run -v &#x2F;test …</p><ul><li>Docker默认会在宿主机上创建一个临时目录&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;[VOLUME_ID]&#x2F;_data</li><li>然后把它挂载到容器的&#x2F;test目录上</li></ul><p>docker run -v &#x2F;home:&#x2F;test …</p><ul><li>Docker直接把宿主机的&#x2F;home目录挂载到容器的&#x2F;test目录上</li></ul><p>Docker是如何将宿主机目录挂载到容器的</p><ul><li>只需要在容器的rootfs准备好之后,在执行chroot之前,把Volume指定的宿主机目录(比如&#x2F;home目录)</li><li>挂载到指定的容器目录(比如&#x2F;test目录)在宿主机上对应的目录(即&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层ID&#x2F;test])</li><li>这个Volume的挂载工作就完成了</li><li>由于执行这个挂载操作时,容器进程已经创建了,意味着此时Mount Namespace已经开启</li><li>所以挂载事件只在这个容器中可见,宿主机上看不到这个挂载点,保证了容器的隔离性不会被Volume打破</li></ul><p>注意:</p><ul><li>这里的”容器进程”,是Docker创建的一个容器初始化进程(dockerinit),而不是应用进程(ENTRYPOINT+CMD)</li><li>dockerinit会负责完成根目录的准备,挂载设备和目录,配置hostname等一系列需要在容器内进行的初始化操作</li><li>最后它通过execv()系统调用,让应用进程取代自己,成为容器里的PID&#x3D;1的进程</li></ul><p><strong>挂载机制</strong></p><ul><li>Docker中的挂载,使用的是Linux的绑定挂载(Bind Mount)机制</li><li>主要作用是运行你将一个目录或者文件,而不是整个设备,挂载到一个指定的目录上</li><li>原挂载点的内容则会被隐藏起来且不受影响</li><li>Bind Mount实际上是一个inode替换的过程</li></ul><p><strong>Bind Mount的本质</strong></p><img src="https://img.darklorder.com/img/202308011904273.png"/><ul><li>mount –bind &#x2F;home &#x2F;test 会将&#x2F;home 挂载到&#x2F;test上</li><li>实际上相当于&#x2F;test的dentry,重定向到了&#x2F;home的inode</li><li>当我们修改&#x2F;test目录时,实际上就是修改的是&#x2F;home目录的inode</li><li>这就是为何一旦执行umount命令,&#x2F;test目录原先的内容就会恢复</li></ul><p><strong>&#x2F;test目录挂载在容器的可读写层,会不会被docker commit提交掉呢</strong></p><ul><li>docker commit是发生在宿主机空间的</li><li>Mount Namespace的隔离作用,宿主机并不知道这个绑定挂载的存在</li><li>在宿主机看来,容器中可读写层的&#x2F;test目录(&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层ID]&#x2F;test)始终是空的</li><li>由于Docker一开始还是要创建这个&#x2F;test目录作为挂载点,执行完docker commit之后</li><li>新镜像中,会多出来一个空的&#x2F;test目录,因为新建目录操作不是挂载操作,Mount Namespace不能起到”障眼法”的作用</li></ul><h3 id="谈谈Kubernetes的本质"><a href="#谈谈Kubernetes的本质" class="headerlink" title="谈谈Kubernetes的本质"></a>谈谈Kubernetes的本质</h3><p><strong>一个正在运行的Linux容器</strong></p><ul><li>一组联合挂载在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt上的rootfs,也就是”容器镜像”,容器的静态视图</li><li>一个由Namespace+Cgroup构成的隔离环境,这一部分称为”容器运行时”,容器的动态视图</li></ul><blockquote><p>真正承载着容器信息进行传递的,是容器镜像,而不是容器运行时<br>0<br><strong>Kubernetes的由来</strong></p></blockquote><ul><li>核心特性都基于Borg&#x2F;Omega系统的设计与经验</li><li>在开源社区落地过程中,修复了很多当年遗留在Borg体系中的缺陷和问题</li></ul><p><strong>架构图</strong></p><img src="https://img.darklorder.com/img/202308011905905.png"/><p>和原型项目Borg非常类似,都由Master和Node两种节点组成,分别对应着控制节点和计算节点</p><p>控制节点,Master节点</p><ul><li>负责API服务的kube-apiserver</li><li>负责调度的kube-scheduler</li><li>负责容器编排的kube-controller-manager</li><li>整个集群的持久化数据,由kube-apiserver处理后保存在Etcd中</li></ul><p>计算节点,Node节点</p><ul><li>kubelet主要负责和容器运行时打交道</li><li>而这个交互依赖的是CRI(Container Runtime Interface)的远程调用接口</li><li>这个接口定义了容器运行时的各项核心操作,比如启动一个容器所需要的所有参数</li><li>不需要关心是什么容器运行时,用到的什么基础</li><li>只要这个容器能够运行标准的容器镜像,他就可以通过实现CRI接入到Kubernetes项目当中</li></ul><p><strong>容器运行时</strong></p><ul><li>例如Docker项目,一般通过OCI这个容器运行时规范通底层的Linux操作系统进行交互</li><li>即:把CRI请求翻译成对Linux操作系统的调用(操作Linux Namespace和Cgroups等)</li></ul><p><strong>kubelet</strong></p><ul><li>kubelet还通过gRPC协议同一个叫做Device Plugin的插件进行交互</li><li>这个插件是Kubernetes项目用来管理GPU等宿主机物理机设备的主要组件</li><li>也是基于kubernetes项目进行机器学习,高性能作业支持等工作必须关注的功能</li><li>调用网络插件和存储插件为容器配置网络和持久化存储</li><li>这两个插件和kubelet交互的接口,分别是CNI(Container Networking Interface)和CSI(Container Storage Interface)</li></ul><p><strong>Borg项目对Kubernetes的指导作用</strong></p><ul><li>体现在Master节点之上</li><li>虽然在Master实现的细节上和Borg有所不同</li><li>但是出发点却高度一致:即如何编排,管理,调用用户提交的作业</li><li>将Docker仅仅作为最底层的一个容器运行时实现</li><li>着重解决的问题:运行在大规模集群中的各种任务之间,实际上存在着各种各样的关系</li><li>处理这些关系,才是作业编排和管理系统最困难的地方</li></ul><p><strong>Kubernetes项目最主要的设计思想</strong></p><p>从宏观的角度,以统一的方式来定义任务之间的各种关系,并且为将来支持更多种类的关系留有余地</p><p><strong>紧密关系的应用</strong></p><ul><li>这些应用之间需要非常频繁的交互和访问,或者直接通过本地文件系统进行信息交换</li><li>在常规环境下,这些应用往往会直接部署在同一台机器上,通过localhost通信,通过本地磁盘交换文件</li><li>但在Kubernetes项目中,这些容器会被划分为一个Pod</li><li>Pod里的容器共享同一个Network Namespace ,同一数据卷,从而达到高效交换信息的目的</li></ul><p><strong>类似Web应用和数据库之间的访问关系</strong></p><ul><li>Kubernetes提供了一种叫做Service的服务</li><li>给Pod绑定一个Service服务,而Service服务声明的IP地址等信息是终生不变的</li><li>这个Service服务的主要作用,就是作为Pod的代理入口</li><li>从而代替Pod对外暴露一个固定的网络地址</li></ul><p><strong>Secret对象</strong></p><ul><li>其实是保存在Etcd里的键值对数据</li><li>可以把Credential信息以Secret的方式存在Etcd里</li><li>Kubernetes就会在你指定的Pod启动时,自动把Secret里的数据以Volume的方式挂载刀片容器里</li></ul><p><strong>Kubernetes的推崇做法</strong></p><ul><li>通过一个”编排对象”,比如PodmJob,CronJob等,来描述你试图管理的应用</li><li>再为它定义一些”服务对象”,比如Service,Secret, HPA等.这些对象会负责具体的平台级功能</li></ul><p><strong>参考资料</strong><br><a href="https://yeasy.gitbook.io/docker_practice/">Docker-从入门到实践</a><br><a href="https://time.geekbang.org/column/intro/116">极客时间-深入剖析Kubernetes</a><br><a href="https://kkwen.cn/index.php/category/kubernetes/">kwen94-博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装部署</title>
    <link href="/2022/09/01/Install-Docker/"/>
    <url>/2022/09/01/Install-Docker/</url>
    
    <content type="html"><![CDATA[<p>关于 Docker安装部署</p><span id="more"></span><h2 id="Docker-安装部署"><a href="#Docker-安装部署" class="headerlink" title="Docker 安装部署"></a>Docker 安装部署</h2><p>目前，Docker支持在多个平台上进行安装部署，包括Linux、Windows和Mac。每个平台会有对应的系统版本要求，具体可以参见官方说明。</p><img src="https://img.darklorder.com/img/202305121626702.png"/><p>在实际应用中，Docker使用最多的场景是在Linux系统上。本文将基于市面上最常用的Centos和Ubuntu系统，对Docker的安装部署进行介绍。</p><h5 id="初始化环境-CentOS"><a href="#初始化环境-CentOS" class="headerlink" title="初始化环境 CentOS"></a>初始化环境 CentOS</h5><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</p><p>通过 uname -r 命令查看你当前的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>使用root 权限登录 CentOS。确保 yum 包更新到最新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update<br></code></pre></td></tr></table></figure><p>卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker  docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure><p>安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p>设置yum源</p><p>官方源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>阿里云源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>清华大学源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h5 id="安装Docker-CentOS"><a href="#安装Docker-CentOS" class="headerlink" title="安装Docker CentOS"></a>安装Docker CentOS</h5><p>安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce<br></code></pre></td></tr></table></figure><p>也可以查看所有仓库中所有docker版本，并选择特定版本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br>sudo yum install docker-ce-版本号.ce<br></code></pre></td></tr></table></figure><p>启动并加入开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start docker<br>sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure><h5 id="初始化环境-Ubuntu"><a href="#初始化环境-Ubuntu" class="headerlink" title="初始化环境 Ubuntu"></a>初始化环境 Ubuntu</h5><p>Docker CE 可以安装在 64 位的 x86平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。</p><p>卸载旧版本</p><p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker \<br>               docker-engine \<br>               docker.io<br></code></pre></td></tr></table></figure><h5 id="安装Docker-Ubuntu"><a href="#安装Docker-Ubuntu" class="headerlink" title="安装Docker Ubuntu"></a>安装Docker Ubuntu</h5><p>使用脚本自动安装</p><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套安装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror Aliyun<br></code></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中</p><p>启动Docker CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></figure><p>卸载Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 先执行命令</span><br>apt-get autoremove docker-ce<br></code></pre></td></tr></table></figure><p>删除 &#x2F;etc&#x2F;apt&#x2F;sources.list.d 目录下的 docker.list 文件</p><h6 id="安装Docker-Ubuntu-1"><a href="#安装Docker-Ubuntu-1" class="headerlink" title="安装Docker Ubuntu"></a>安装Docker Ubuntu</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 修改源地址</span><br>root@ubuntu2004:~<span class="hljs-comment"># vim /etc/apt/sources.list</span><br>deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br><br>root@ubuntu2004:~<span class="hljs-comment">#</span><br>root@ubuntu2004:~<span class="hljs-comment"># visudo</span><br>%sudo ALL=(ALL:ALL) NOPASSWD:ALL<br>root@ubuntu2004:~$ <br><span class="hljs-comment">## 更新本地包数据库</span><br>root@ubuntu2004:~$ apt update<br><span class="hljs-comment">## 更新所有已安装的包（也可以使用 full-upgrade）</span><br>root@ubuntu2004:~$ apt upgrade<br>root@ubuntu2004:~$ apt install screenfetch<br>root@ubuntu2004:~$ apt install vim net-tools aptitude git<br>root@ubuntu2004:~$ apt-get install uml-utilities<br>root@ubuntu2004:~$ apt install bridge-utils<br>root@ubuntu2004:~$ ufw <span class="hljs-built_in">disable</span> <br>root@ubuntu2004:~$ screenfetch<br>                          ./+o+-       root@ubuntu2004<br>                  yyyyy- -yyyyyy+      OS: Ubuntu 20.04 focal<br>               ://+//////-yyyyyyo      Kernel: x86_64 Linux 5.4.0-91-generic<br>           .++ .:/++++++/-.+sss/`      Uptime: 1m<br>         .:++o:  /++++++++/:--:/-      Packages: 656<br>        o:+o+:++.`..```.-/oo+++++/     Shell: bash 5.0.17<br>       .:+o:+o/.          `+sssoo+/    Resolution: No X Server<br>  .++/+:+oo+o:`             /sssooo.   WM: Not Found<br> /+++//+:`oo+o               /::--:.   GTK Theme: Adwaita [GTK3]<br> \+/+o+++`o++o               ++////.   Disk: 6.9G / 52G (15%)<br>  .++.o+++oo+:`             /dddhhh.   CPU: 11th Gen Intel Core i7-11700K @ 4x 3.6GHz<br>       .+.o+oo:.          `oddhhhh+    GPU: VMware SVGA II Adapter<br>        \+.++o+o``-````.:ohdhhhhh+     RAM: 509MiB / 3907MiB<br>         `:o+++ `ohhhhhhhhyo++os:     <br>           .o:`.syhhhhhhh/.oo++o`     <br>               /osyyyyyyo++ooo+++/    <br>                   ````` +oo+++o\:    <br>                          `oo++.      <br>root@ubuntu2004:~$ <br>root@ubuntu2004:~$ vim /etc/ssh/sshd_config<br>PermitRootLogin <span class="hljs-built_in">yes</span>              <span class="hljs-comment">#允许root直接登录</span><br>PermitEmptyPasswords no          <span class="hljs-comment">#因为设置了root密码，所以需要修改为no</span><br>root@ubuntu2004:~$ service ssh restart  重启ssh服务<br>root@ubuntu2004:~$ vim ~/.bash_profile<br><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">&quot;[\u@\h \W]\\$ &quot;</span><br>root@ubuntu2004:~$ <span class="hljs-built_in">source</span> ~/.bash_profile<br>[root@ubuntu2004 ~]<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## Ubuntu（使用 apt-get 进行安装）</span><br><span class="hljs-comment"># step 1: 安装必要的一些系统工具</span><br>sudo apt-get update<br>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br><span class="hljs-comment"># step 2: 安装GPG证书</span><br>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br><span class="hljs-comment"># Step 3: 写入软件源信息</span><br>sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br><span class="hljs-comment"># Step 4: 更新并安装Docker-CE</span><br>sudo apt-get -y update<br>sudo apt-get -y install docker-ce<br><span class="hljs-comment"># 安装指定版本的Docker-CE:</span><br><span class="hljs-comment"># Step 1: 查找Docker-CE的版本:</span><br><span class="hljs-comment"># apt-cache madison docker-ce</span><br><span class="hljs-comment">#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-comment">#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-comment"># Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)</span><br><span class="hljs-comment"># sudo apt-get -y install docker-ce=[VERSION]</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu2004:~$ docker version<br>Client: Docker Engine - Community<br> Version:           20.10.11<br> API version:       1.41<br> Go version:        go1.16.9<br> Git commit:        dea9396<br> Built:             Thu Nov 18 00:37:06 2021<br> OS/Arch:           linux/amd64<br> Context:           default<br> Experimental:      <span class="hljs-literal">true</span><br>Got permission denied <span class="hljs-keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get <span class="hljs-string">&quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version&quot;</span>: dial unix /var/run/docker.sock: connect: permission denied<br>root@ubuntu2004:~$ <br></code></pre></td></tr></table></figure><h5 id="Docker-镜像加速器"><a href="#Docker-镜像加速器" class="headerlink" title="Docker 镜像加速器"></a>Docker 镜像加速器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 镜像加速器</span><br>root@ubuntu2004:~<span class="hljs-comment"># </span><br>root@ubuntu2004:~<span class="hljs-comment"># sudo mkdir -p /etc/docker</span><br>root@ubuntu2004:~<span class="hljs-comment"># sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>          <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>          <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>          <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span><br>  ]<br>&#125;<br>EOF<br>root@ubuntu2004:~<span class="hljs-comment"># systemctl daemon-reload</span><br>root@ubuntu2004:~<span class="hljs-comment"># systemctl restart docker</span><br>root@ubuntu2004:~<span class="hljs-comment"># docker info</span><br> ...<br> Registry Mirrors:<br>  https://docker.mirrors.ustc.edu.cn/<br>  https://hub-mirror.c.163.com/<br>  https://reg-mirror.qiniu.com/<br> Live Restore Enabled: <span class="hljs-literal">false</span><br>root@ubuntu2004:~<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p><strong>参考资料</strong><br><a href="https://micromaple.blog.csdn.net/article/details/125727576">CSDN【云原生】Docker镜像详细讲解</a><br><a href="https://developer.aliyun.com/mirror/docker-ce">阿里云 Docker CE镜像</a><br><a href="https://developer.aliyun.com/mirror/ubuntu">阿里云 Ubuntu 镜像</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>名称空间</title>
    <link href="/2022/08/31/Kernel-Namespace/"/>
    <url>/2022/08/31/Kernel-Namespace/</url>
    
    <content type="html"><![CDATA[<p>Namespaces、CGroups、Containerruntime</p><span id="more"></span><h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><p>内核名称空间（Kernel Namespace）是Linux操作系统中的一个重要概念，用于隔离和管理系统资源。在Linux中，名称空间是一种资源隔离机制，它允许不同的进程看到和访问的资源独立于其他进程，从而实现进程间的隔离性。内核名称空间特别用于隔离内核级别的资源。</p><p>如果把<strong>Linux操作系统</strong>比作一个<strong>大房子</strong>，那<strong>命名空间</strong>指的就是这个房子中的一个个<strong>房间</strong>，住在每个房间里的人都自以为独享了整个房子的资源，但其实大家仅仅只是在共享的基础之上互相隔离，共享指的是共享全局的资源，而隔离指的是局部上彼此保持隔离，因而命名空间的本质就是指：一种在空间上<strong>隔离</strong>的概念，当下盛行的许多容器虚拟化技术（典型代表如LXC、Docker）就是基于linux命名空间的概念而来的。</p><p>Docker容器十分类似LXC容器，他们实现了相同的安全特性。在你使用 <code>docker run</code>,启动一个Docker容器的时候，  Docker 会创建设置一个 namespaces 和 control groups 来配合容器。</p><p>命名空间提供的隔离，是第一个也是最简单的安全形式，在容器中运行的进程在其他容器或主机中是看不到的，基本上不会相互影响。</p><p>每一个容器都有自己的网络机制，这意味这不同的容器能访问其他容器接口的sockets。当然如果你希望容器能相互配置使用，也可以将容器的网络接口释放出来，利用端口转发，让容器像主机一样可以在网络中被识别。都你使用一个公共的端口来连接容器直接内部的网络，你就是尝试去在容器之间进行ping。实际上所有的容器都是利用桥接方式来共享端口连接，一台主机就可以连接运行在上面的所有容器。</p><p><strong>名称空间管理相关的系统调用</strong></p><ul><li><p>clone()：创建子进程，并将其隔离至新建的名称空间之中； 负责创建一个子进程，若同时使用了CLONE_NEW*相关的标志，则为每个标志创建出名称空间，并将该进程置于该名称空间中；</p></li><li><p>setns()：将进程加入到指定的现有名称空间中； 通过操作进程相关的&#x2F;proc&#x2F;[pid]&#x2F;ns&#x2F;目录完成</p></li><li><p>unshare()：将进程隔离至新建的名称空间中； 与clone()类似，但不同之处在于，unshare()在当前进程中创建名称空间，一旦调用完成，当前进程即位于新的名称空间之中；</p></li><li><p>ioctl()：获取名称空间的相关信息。</p></li></ul><p>目前，内核(5.13)支持8种名称空间</p><table><thead><tr><th align="center">名称空间</th><th align="center">调用标志</th><th align="center">隔离内容</th><th align="center">引入时的内核版本</th></tr></thead><tbody><tr><td align="center"><strong>Mount</strong></td><td align="center">CLONE_NEWNS</td><td align="center">挂载点、文件系统</td><td align="center">2.4.19</td></tr><tr><td align="center"><strong>UTS</strong></td><td align="center">CLONE_NEWUFS</td><td align="center">主机名和NIS域名</td><td align="center">2.6.19</td></tr><tr><td align="center"><strong>IPC</strong></td><td align="center">CLONE_NEWIPC</td><td align="center">SysV IPC、POSIX messages</td><td align="center">2.6.19</td></tr><tr><td align="center"><strong>PID</strong></td><td align="center">CLONE_NEWPID</td><td align="center">PID</td><td align="center">2.6.24</td></tr><tr><td align="center"><strong>Network</strong></td><td align="center">CLONE_NEWNET</td><td align="center">网络设备、协议栈、端口等</td><td align="center">2.6.29</td></tr><tr><td align="center"><strong>User</strong></td><td align="center">CLONE_NEWUSER</td><td align="center">User ID和Group ID</td><td align="center">3.8</td></tr><tr><td align="center">Cgroup</td><td align="center">CLONE_NEWCGROUP</td><td align="center">Cgroup根目录及层级结构</td><td align="center">4.6</td></tr><tr><td align="center">Time</td><td align="center">CLONE_NEWTIME</td><td align="center">Boot time和monotonic time</td><td align="center">5.6</td></tr></tbody></table><p><em>备注：<br>monotonic time：单调递增时钟，自系统开机后开始累加计时，但系统休眠时间不计入；<br>boot time：类似于monotonic time，不同之处是，boot time会计入系统休眠时间；</em></p><h4 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h4><p>cgroups(Control Groups) 是 linux 内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</p><p>简单说，cgroups 可以限制、记录任务组所使用的物理资源。本质上来说，cgroups 是内核附加在程序上的一系列钩子(hook)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</p><p>cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups 提供了以下功能：</p><ul><li>资源限制：cgroups 可以对任务的资源总额进行限制。比如设定任务运行时使用的内存上限，一旦超出就发 OOM（内存溢出）。</li><li>优先级分配：通过分配的 CPU 时间片数量和磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。</li><li>资源统计：cgoups 可以统计系统的资源使用量，比如 CPU 使用时长、内存用量等。这个功能非常适合当前云端产品按使用量计费的方式。</li><li>隔离：为组隔离命名空间，这样一个组不会看到另一个组的进程、网络连接和文件系统</li><li>任务控制：cgroups 可以对任务执行挂起、恢复等操作。</li></ul><p><strong>CGroups能够限制的资源：</strong></p><ul><li>blkio：块设备IO</li><li>cpu：CPU</li><li>cpuacct：CPU资源使用报告</li><li>cpuset：多处理器平台上的CPU集合</li><li>devices：设备访问</li><li>freezer：挂起或恢复任务</li><li>memory：内存用量及报告</li><li>perf_event：对cgroup中的任务进行统一性能测试</li><li>net_cls：cgroup中的任务创建的数据报文的类别标识符</li></ul><p>安装Docker后，用户可以在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;docker&#x2F;目录下看到对Docker组应用的各种限制项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cd /sys/fs/cgroup/memory/</span><br>[root@localhost memory]<span class="hljs-comment"># ls</span><br>cgroup.clone_children           memory.kmem.slabinfo                memory.memsw.limit_in_bytes      memory.swappiness<br>cgroup.event_control            memory.kmem.tcp.failcnt             memory.memsw.max_usage_in_bytes  memory.usage_in_bytes<br>cgroup.procs                    memory.kmem.tcp.limit_in_bytes      memory.memsw.usage_in_bytes      memory.use_hierarchy<br>cgroup.sane_behavior            memory.kmem.tcp.max_usage_in_bytes  memory.move_charge_at_immigrate  notify_on_release<br>memory.failcnt                  memory.kmem.tcp.usage_in_bytes      memory.numa_stat                 release_agent<br>memory.force_empty              memory.kmem.usage_in_bytes          memory.oom_control               system.slice<br>memory.kmem.failcnt             memory.limit_in_bytes               memory.pressure_level            tasks<br>memory.kmem.limit_in_bytes      memory.max_usage_in_bytes           memory.soft_limit_in_bytes<br>memory.kmem.max_usage_in_bytes  memory.memsw.failcnt                memory.stat<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cd /sys/fs/cgroup/memory/</span><br>[root@localhost memory]<span class="hljs-comment"># ls</span><br>cgroup.clone_children       memory.kmem.max_usage_in_bytes      memory.memsw.failcnt             memory.stat<br>cgroup.event_control        memory.kmem.slabinfo                memory.memsw.limit_in_bytes      memory.swappiness<br>cgroup.procs                memory.kmem.tcp.failcnt             memory.memsw.max_usage_in_bytes  memory.usage_in_bytes<br>cgroup.sane_behavior        memory.kmem.tcp.limit_in_bytes      memory.memsw.usage_in_bytes      memory.use_hierarchy<br>init.scope                  memory.kmem.tcp.max_usage_in_bytes  memory.move_charge_at_immigrate  notify_on_release<br>memory.failcnt              memory.kmem.tcp.usage_in_bytes      memory.numa_stat                 release_agent<br>memory.force_empty          memory.kmem.usage_in_bytes          memory.oom_control               system.slice<br>memory.kmem.failcnt         memory.limit_in_bytes               memory.pressure_level            tasks<br>memory.kmem.limit_in_bytes  memory.max_usage_in_bytes           memory.soft_limit_in_bytes       user.slice<br></code></pre></td></tr></table></figure><p>用户可以通过修改这些文件值来控制组限制Docker应用资源。</p><h4 id="Container-runtime"><a href="#Container-runtime" class="headerlink" title="Container runtime"></a>Container runtime</h4><p>容器运行时（Container Runtime）是一种软件组件，负责在宿主机上管理和运行容器。它是容器化技术的核心组成部分，允许将应用程序及其依赖项打包并隔离在宿主系统之上。容器运行时与宿主操作系统内核进行交互，并管理容器的生命周期、网络、存储等重要功能。</p><p>容器并非Linux内核中的“一等公民”，它从根本上来说就是由名称空间、CGroups和LSM(Linux内核安全模块) 等几个内核原语组成；</p><ul><li><p>借助于这些内核原语即可设置安全、隔离的进程运行环境，但这也意味着每次创建都得手动执行相关的操作；</p></li><li><p>“容器运行时”便是一组简化该类操作的工具集</p></li></ul><p>“运行时”是进程的生命周期管理工具，容器运行时是一种特指运行和管理容器所需要的软件</p><p>用于帮助用户轻松、高效、安全地部署容器，而且是容器管理的关键组件</p><p>2007年，CGroups引入到Linux内核之后，便出现了一些容器运行时项目，例如LXC(Linux containers)和LMCTFY(Google)等</p><p>容器运行时的主要任务包括：</p><ul><li><p>容器创建：它加载容器镜像，该镜像包含应用程序及其运行时依赖项，并创建一个具有独立文件系统的容器实例。</p></li><li><p>容器执行：运行时启动容器进程，管理其资源，并提供一个独立的执行环境，使其表现为一个隔离的应用程序实例。</p></li><li><p>容器网络：设置网络接口并管理容器的网络连接，使其能够与其他容器或外部网络进行通信。</p></li><li><p>资源管理：运行时确保容器访问所需的资源，同时根据配置的限制限制其对宿主资源的访问。</p></li><li><p>容器终止：当容器内的应用程序完成任务或被显式停止时，运行时负责清理资源并终止容器。</p></li></ul><h4 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h4><p>借助于称之为 “容器运行时 Container Runtime” 的软件技术，在同一个内核之上生成多个彼此隔离的用户空间</p><ul><li>各用户空间可独立管理运行其内部进程</li><li>每个用户空间 “自以为” 独占该内核及硬件资源</li><li>每一个用户空间就叫一个容器</li></ul><p>需要将内核级的共享资源进行隔离，每个容器暴露的是系统接口</p><ul><li><p>依赖于内核中称为 “名称空间” 的技术进行</p><p>名称空间是Linux内核特性，用于隔离部分系统资源，从而使得进程仅可访问同一名称空间中的相应资源；</p><p>名称空间只能做到隔离，做不到资源的分配；</p></li><li><p>资源限制则依赖于由Google贡献的 “CGroups”</p><p>cgroups(Control Groups) 是 linux 内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</p></li></ul><p>支撑容器创建的功能是内置于内核当中的，需要通过系统调用来实现；用户空间虚拟化是内核的功能。</p><p>每一个容器都是一组独立的名称空间，一组名称空间组合起来形成的。</p><p><strong>参考资料</strong><br><a href="https://lwn.net/Articles/531114/">Namespace in Operation</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文彻底弄懂REST API</title>
    <link href="/2022/08/20/REST-API/"/>
    <url>/2022/08/20/REST-API/</url>
    
    <content type="html"><![CDATA[<p>一文彻底弄懂REST API</p><span id="more"></span><center><img src="https://img.darklorder.com/img/202307070418363.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这是一个开发中经常会遇到的名词，也许你已经了解过一些这方面的知识，也有可能对这个概念比较模糊。本文将会诠释REST的基础以及如何给应用创建一个API，我们开始正文。</p><h4 id="什么是API？"><a href="#什么是API？" class="headerlink" title="什么是API？"></a><strong>什么是API？</strong></h4><p>首先介绍API的概念，Application Programming Interface（应用程序接口）是它的全称。简单的理解就是，API是一个接口。那么它是一个怎样的接口呢，现在我们常将它看成一个HTTP接口即HTTP API。也就是说这个接口得通过HTTP的方式来调用，做过前后端开发的小伙伴可能知道，后端开发又叫做面向接口开发，我们往往会提供一个接口供前端调用，或者供其他服务调用。举个例子，我们程序中往往会涉及到调用第三方接口，比如说，调用支付宝或者微信的支付接口来实现我们程序中的支付功能、调用带三方的短信接口来向用户发送验证码短信等等…</p><p>这样说吧，比如说我们有一个可以允许我们查看（view），创建（create），编辑（edit）以及删除（delete）部件的应用程序。我们可以创建一个可以让我们执行这些功能的HTTP API:</p><p><a href="http://demo.com/view_books">http://demo.com/view_books</a><br><a href="http://demo.com/create_new_book?name=shuxue">http://demo.com/create_new_book?name=shuxue</a><br><a href="http://demo.com/update_book?id=1&amp;name=shuxue">http://demo.com/update_book?id=1&amp;name=shuxue</a><br><a href="http://demo.com/delete_book">http://demo.com/delete_book</a>?</p><p>这是4个HTTP API，分别实现了图书的查看、新增、编辑、删除的操作，当我们把接口发布出去的时候，别人就可以通过这四个接口来调用相关的服务了。但是这样做有什么不方便的地方呢？你可能发现了，这种API的写法有一个缺点 ，那就是没有一个统一的风格，比如说第一个接口表示查询全部图书的信息，我们也可以写成这样：</p><p><a href="http://demo.com/books/list">http://demo.com/books/list</a><br>那这样就会造成使用我们接口的其他人必须得参考API才能知道它是怎么运作的。</p><p>不用担心，REST会帮我们解决这个问题。</p><h4 id="什么是REST？"><a href="#什么是REST？" class="headerlink" title="什么是REST？"></a><strong>什么是REST？</strong></h4><p>有了上面的介绍，你可能也大概有了直观的了解，说白了，<strong>REST是一种风格！</strong></p><p>REST的作用是将我们上面提到的查看（view），创建（create），编辑（edit）和删除（delete）直接映射到HTTP 中已实现的<strong>GET,POST,PUT和DELETE</strong>方法。</p><p>这四种方法是比较常用的，HTTP总共包含<strong>八种</strong>方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GET</span><br>POST<br>PUT<br><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">OPTIONS</span><br>HEAD<br>TRACE<br><span class="hljs-keyword">CONNECT</span><br></code></pre></td></tr></table></figure><p>当我们在浏览器点点点的时候我们通常只用到了GET方法，当我们提交表单，例如注册用户的时候我们就用到了POST方法…</p><p>介绍到这里，我们重新将上面的四个接口改写成REST风格：</p><p><strong>查看所有图书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//</span>demo.com/books<br></code></pre></td></tr></table></figure><p><strong>新增一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST http:<span class="hljs-regexp">//</span>demo.com/books<br>Data: name=shuxue<br></code></pre></td></tr></table></figure><p><strong>修改一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT http:<span class="hljs-regexp">//</span>demo.com/books<br>Data:id=<span class="hljs-number">1</span>,name=shuxue<br></code></pre></td></tr></table></figure><p><strong>删除一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">DELETE http:<span class="hljs-regexp">//</span>demo.com/books<br>Data:id=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>大家有没有发现，这样改动之后API变得统一了，我们只需要改变请求方式就可以完成相关的操作，这样大大简化了我们接口的理解难度，变得易于调用。</p><p><strong>这就是REST风格的意义！</strong></p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h4><p>REST的另一重要部分就是为既定好请求的类型来响应正确的状态码。如果你对HTTP状态码陌生，以下是一个简易总结。当你请求HTTP时，服务器会响应一个状态码来判断你的请求是否成功，然后客户端应如何继续。以下是四种不同层次的状态码：</p><ul><li>2xx &#x3D; Success（成功）</li><li>3xx &#x3D; Redirect（重定向）</li><li>4xx &#x3D; User error（客户端错误）</li><li>5xx &#x3D; Server error（服务器端错误）</li></ul><p>我们常见的是200（请求成功）、404（未找到）、401（未授权）、500（服务器错误）…</p><h4 id="API格式响应"><a href="#API格式响应" class="headerlink" title="API格式响应"></a><strong>API格式响应</strong></h4><p>上面介绍了REST API的写法，响应状态码，剩下就是请求的数据格式以及响应的数据格式。说的通俗点就是，我们用什么格式的参数去请求接口并且我们能得到什么格式的响应结果。</p><p>我这里只介绍一种用的最多的格式——JSON格式</p><p>目前json已经发展成了一种最常用的数据格式，由于其轻量、易读的优点。</p><p>所以我们经常会看到一个请求的header信息中有这样的参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>:application/json<br></code></pre></td></tr></table></figure><p>这个参数的意思就是接收来自后端的json格式的信息。</p><p>我举个json响应的例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;<br>&quot;code&quot;: 200,<br>&quot;books&quot;: [&#123;<br>&quot;id&quot;: 1,<br>&quot;name&quot;: &quot;yuwen&quot;<br>&#125;, &#123;<br>&quot;id&quot;: 2,<br>&quot;name&quot;: &quot;shuxue&quot;<br>&#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样返回是不是一目了然，而且冗余信息很少！</p><h4 id="REST-API例子"><a href="#REST-API例子" class="headerlink" title="REST API例子"></a><strong>REST API例子</strong></h4><p>说了这么多，最后我以一个实际REST API的例子结尾（这里以java语言为例）</p><p>我们新建一个SpringBoot的项目demo</p><center><img src="https://img.darklorder.com/img/202307070418852.jpg"  alt="文件名" style="zoom:50%;" /></center><p>然后写上查看、新增、修改、删除四个接口（这里为了方便返回的格式我用字符串代替json格式）</p><center><img src="https://img.darklorder.com/img/202307070418147.jpg"  alt="文件名" style="zoom:40%;" /></center><p>最后通过Apifox工具对四个接口依次进行测试。如下图。</p><center><img src="https://img.darklorder.com/img/202307070418078.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070418452.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070418347.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070417291.jpg"  alt="文件名" style="zoom:40%;" /></center><p>以上，</p><p><strong>问：REST API是什么呢？</strong></p><p><strong>答：是一种REST风格的HTTP接口！</strong></p><p><strong>参考资料</strong><br><a href="https://zhuanlan.zhihu.com/p/536437382">一文彻底弄懂REST API - 知乎</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟化技术的分类及介绍</title>
    <link href="/2022/08/12/Classification-and-Introduction-of-Virtualization-Technology/"/>
    <url>/2022/08/12/Classification-and-Introduction-of-Virtualization-Technology/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>虚拟化是云计算系统中的一种基础技术，可以说当前一个云计算服务必定是构建在虚拟化的基础上的。本文首先介绍了不同抽象层次的虚拟化技术，之后对应用广泛的系统级虚拟化和操作系统级虚拟化进行了更详细的分类和描述，最后介绍了各种典型虚拟化方案的具体实现。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>虚拟化是计算机系统中的一个重要概念，基本上每个计算机系统都提供一个给上层软件的界面，从处理器提供的基本指令集到很多中间件系统提供的巨大的应用程序界面集。虚拟化本质上是扩展或替换一个现存界面来模仿另一个系统的行为，其对计算机系统的重要性主要体现在以下几个方面。</p><p>相比高层软件（比如中间件和应用软件），硬件和底层系统软件变化得比较快，也就是说，我们面对的一种情况是旧有软件的维护跟不上下层平台更新的步伐。通过移植旧有软件的底层接口到新平台，可使得一大类的现有软件可以立刻在新平台上工作。</p><p>在服务器机器上，一个组织为它提供的每个服务都分配一台虚拟机，接着，将虚拟机以最佳方式分配到物理服务器上。与进程不同，虚拟机能很简单地迁移到其他物理机器上，这增加了管理服务器基础设施的灵活性。这个方法能潜在地减少服务器计算机的投资并减少能量消耗，后者是大型服务器中心的关键问题。</p><p>虚拟化技术和云计算的提供极为相关。云计算采用了这样一个模型，即作为一个服务，提供云上创建的存储、计算和高层对象。所提供的服务覆盖从诸如物理体系结构等的底层方面（基础设施即服务IaaS）到诸如软件平台（平台即服务PaaS），再到任意应用层次的服务（软件即服务SaaS）。云服务的提供被虚拟化技术直接驱动，允许为云的用户提供一个或多个虚拟机，供用户自己使用。</p><p>分布式应用的需求也激发虚拟化解决方案的开发者去以很少的开销创建和销毁虚拟机。在可能需要动态地请求资源的应用中，这是必要的。例如对于多人在线游戏或分布式多媒体应用，通过采用合适的资源分配策略满足虚拟机服务质量需求，能提升对这样的应用的支持度。</p><p>另一个好处是，在单台计算机上提供对几个不同操作系统环境的便利访问，虚拟化可用于在一种物理体系结构上提供多种操作系统类型。</p><p>虚拟化技术起始于IBM370体系结构，它的VM操作系统能为运行在同一计算机上的不同程序提供几个完整的虚拟机。最近，人们对虚拟化的兴趣大增，有许多研究项目和商业系统为商用PC、服务器和云基础设施提供虚拟化解决方案。</p><h2 id="虚拟化技术的分类"><a href="#虚拟化技术的分类" class="headerlink" title="虚拟化技术的分类"></a>虚拟化技术的分类</h2><p>现代计算机系统是一个庞大的整体，整个系统的复杂性是不言而喻的。因而，整个计算机系统被分成了多个自下而上的层次，每一个层次都向上一层次呈现一个抽象，并且每一层只需知道下层抽象的接口，而不需要了解其内部运作机制。这样以层的方式抽象资源的好处是每一层只需要考虑本层设计以及与相邻层间的相互交互，从而大大降低了系统设计的复杂性，提高了软件的移植性。</p><p>本质上，虚拟化就是由位于下层的软件模块，通过向上一层软件模块提供一个与它原先所期待的运行环境完全一致的接口的方法，抽象出一个虚拟的软件或硬件接口，使得上层软件可以直接运行在虚拟的环境上。虚拟化可以发生在现代计算机系统的各个层次上，不同层次的虚拟化会带来不同的虚拟化概念。</p><p>如前文所述，虚拟化技术起源于上世纪70年代的IBM370体系，经过四十余年的发展，当前存在诸多实现在不同层次的虚拟化技术，原理不尽相同，且每一种技术都相当复杂。在本文中，将通过不同的角度对目前存在的较流行的虚拟化技术进行分类，并对其原理进行初步介绍，旨在对纷繁复杂的虚拟化技术有个整体认识及厘清不同虚拟化技术之间的相互关系。</p><h3 id="不同抽象层次的虚拟化技术"><a href="#不同抽象层次的虚拟化技术" class="headerlink" title="不同抽象层次的虚拟化技术"></a>不同抽象层次的虚拟化技术</h3><p>在介绍各种虚拟化概念之前，先介绍虚拟化中的两个重要名词。在虚拟化中，物理资源通常有一个定语称为宿主（Host），而虚拟出来的资源通常有一个定语称为客户（Guest）。</p><p>在计算机系统中，从底层至高层依次可分为：硬件层、操作系统层、函数库层、应用程序层，在对某层实施虚拟化时，该层和上一层之间的接口不发生变化，而只变化该层的实现方式。从使用虚拟资源的Guest的角度来看，虚拟化可发生在上述四层中的任一层。应当注意，在对Guest的某一层进行虚拟化时，并未对Host在哪一层实现它作出要求，这一点是时常引起混淆的地方。</p><h4 id="硬件抽象层上的虚拟化"><a href="#硬件抽象层上的虚拟化" class="headerlink" title="硬件抽象层上的虚拟化"></a>硬件抽象层上的虚拟化</h4><p>硬件抽象层上的虚拟化是指通过虚拟硬件抽象层来实现虚拟机，为客户机操作系统呈现和物理硬件相同或相近的硬件抽象层，又称为指令集级虚拟化，实现在此层的虚拟化粒度是最小的。</p><p>实现在此层的虚拟化技术可以对整个计算机系统进行虚拟，即可将一台物理计算机系统虚拟化为一台或多台虚拟计算机系统，故又可称作系统级虚拟化。每个虚拟计算机系统（简称为虚拟机）都拥有自己的虚拟硬件（如CPU、内存和设备等），来提供一个独立的虚拟机执行环境。每个虚拟机中的操作系统可以完全不同，并且它们的执行环境是完全独立的。由于客户机操作系统所能看到的是硬件抽象层，因此，客户机操作系统的行为和在物理平台上没有什么区别。</p><h4 id="操作系统层上的虚拟化"><a href="#操作系统层上的虚拟化" class="headerlink" title="操作系统层上的虚拟化"></a>操作系统层上的虚拟化</h4><p>操作系统层上的虚拟化是指操作系统的内核可以提供多个互相隔离的用户态实例。这些用户态实例（经常被称为容器）对于它的用户来说就像是一台真实的计算机，有自己独立的文件系统、网络、系统设置和库函数等。</p><p>由于这是操作系统内核主动提供的虚拟化，因此操作系统层上的虚拟化通常非常高效，它的虚拟化资源和性能开销非常小，也不需要有硬件的特殊支持。但它的灵活性相对较小，每个容器中的操作系统通常必须是同一种操作系统。另外，操作系统层上的虚拟化虽然为用户态实例间提供了比较强的隔离性，但其粒度是比较粗的。</p><h4 id="库函数层上的虚拟化"><a href="#库函数层上的虚拟化" class="headerlink" title="库函数层上的虚拟化"></a>库函数层上的虚拟化</h4><p>操作系统通常会通过应用级的库函数提供给应用程序一组服务，例如文件操作服务、时间操作服务等。这些库函数可以隐藏操作系统内部的一些细节，使得应用程序编程更为简单。不同的操作系统库函数有着不同的服务接口，例如Linux的服务接口是不同于Windows的。库函数层上的虚拟化就是通过虚拟化操作系统的应用级库函数的服务接口，使得应用程序不需要修改，就可以在不同的操作系统中无缝运行，从而提高系统间的互操作性。</p><p>例如，Wine就是在Linux上模拟了Windows的库函数接口，使得一个Windows应用程序能够在Linux上正常运行。</p><h4 id="编程语言层上的虚拟化"><a href="#编程语言层上的虚拟化" class="headerlink" title="编程语言层上的虚拟化"></a>编程语言层上的虚拟化</h4><p>另一大类编程语言层上的虚拟机称为语言级虚拟机，例如JVM（Java Virtual Machine）和微软的CLR（Common Language Runtime）。这一类虚拟机运行的是进程级的作业，所不同的是这些程序所针对的不是一个硬件上存在的体系结构，而是一个虚拟体系结构。这些程序的代码首先被编译为针对其虚拟体系结构的中间代码，再由虚拟机的运行时支持系统翻译为硬件的机器语言进行执行。</p><h3 id="系统级虚拟化"><a href="#系统级虚拟化" class="headerlink" title="系统级虚拟化"></a>系统级虚拟化</h3><p>系统级虚拟化即硬件抽象层上的虚拟化、指令集级虚拟化，是最早被提出和研究的一种虚拟化技术，当前存在多种此种技术的具体实现方案，在介绍它们之前，有必要先了解实现系统级虚拟化可采取的途径。</p><p>在每台虚拟机中都有属于它的虚拟硬件，通过虚拟化层的模拟，虚拟机中的操作系统认为自己仍然是独占一个系统在运行，这个虚拟化层被称为虚拟机监控器（Virtual Machine Monitor，VMM）。VMM对物理资源的虚拟可以归结为三个主要任务：处理器虚拟化、内存虚拟化和I&#x2F;O虚拟化。其中，处理器虚拟化是VMM中最核心的部分，因为访问内存或进行I&#x2F;O本身就是通过一些指令来实现的。</p><h4 id="可虚拟化架构和不可虚拟化架构"><a href="#可虚拟化架构和不可虚拟化架构" class="headerlink" title="可虚拟化架构和不可虚拟化架构"></a>可虚拟化架构和不可虚拟化架构</h4><p>在系统级虚拟化中，虚拟计算机系统和物理计算机系统可以是两个完全不同ISA（Instruction Set Architecture，指令集架构）的系统，例如，可以在一个x86的物理计算机上运行一个安腾的虚拟计算机。但是，不同的ISA使得虚拟机的每一条指令都需要在物理机上模拟执行，从而造成性能上的极大下降。</p><p>显然，相同体系结构的系统虚拟化通常会有比较好的性能，并且VMM实现起来也会比较简单。这种情况下虚拟机的大部分指令可以在处理器上直接运行，只有那些与硬件资源关系密切的敏感指令才会由VMM进行处理。此时面前的一个问题是，要能将这些敏感指令很好地筛选出来。但事实上，某些处理器在设计之初并没有充分考虑虚拟化的需求，导致没有办法识别出所有的敏感指令，因而不具备一个完备的可虚拟化结构。</p><p>大多数的现代计算机体系结构都有两个或两个以上的特权级，用来分隔系统软件和应用软件。系统中有一些操作和管理关键系统资源的指令会被定为特权指令，这些指令只有在最高特权级上才能够正确执行。如果在非最高特权级上运行，特权指令会引发一个异常，处理器会陷入到最高特权级，交由系统软件来处理。</p><p>在x86架构中，所有的特权指令都是敏感指令，然而并不是所有的敏感指令都是特权指令。</p><p>为了VMM可以完全控制系统资源，它不允许虚拟机上操作系统直接执行敏感指令。如果一个系统上所有敏感指令都是特权指令，则能够用一个很简单的方法来实现一个虚拟环境：将VMM运行在系统的最高特权级上，而将客户机操作系统运行在非最高特权级上，当客户机操作系统因执行敏感指令而陷入到VMM时，VMM模拟执行引起异常的敏感指令，这种方法被称为“陷入再模拟”。</p><p>总而言之，判断一个架构是否可虚拟化，其核心就在于该结构对敏感指令的支持上。如果一个架构中所有敏感指令都是特权指令，则称其为可虚拟化架构，否则称为不可虚拟化架构。</p><h4 id="按照实现方法分类"><a href="#按照实现方法分类" class="headerlink" title="按照实现方法分类"></a>按照实现方法分类</h4><p>系统级虚拟化有许多不同的具体实现方案，按照实现方法的不同，可划分为如下几个类别。</p><p><strong>（1）仿真（Emulation）</strong></p><p>我们已经知道，通过陷入再模拟敏感指令的执行来实现虚拟机的方法是有前提条件的：所有的敏感指令必须都是特权指令。如果一个体系结构上存在敏感指令不属于特权指令，那么其就存在虚拟化漏洞，可以采用一些方法来填补或避免这些漏洞。最简单直接的方法是，所有指令都采用模拟来实现，就是取一条指令，就模拟出这条指令执行的效果。这种方法称作仿真。</p><p>仿真是最复杂的虚拟化实现技术，使用仿真方法，可以在一个x86处理器上运行为PowerPC设计的操作系统，这在其它的虚拟化方案中是无法实现的。甚至可以运行多个虚拟机，每个虚拟机仿真一个不同的处理器。此外，这种方法不需要对宿主操作系统的特殊支持，虚拟机可以完全作为应用层程序运行。</p><p>正如前面提到的，使用仿真方法的主要问题是速度会非常慢。由于每条指令都必须在底层硬件上进行仿真，因此速度减慢100倍的情况也并不稀奇。若要实现高度保真的仿真，包括周期精度、CPU的缓存行为等，实际速度差距甚至可能会达到1000倍之多。</p><p>使用这种方式的典型实现是Bochs。</p><p><strong>（2）完全虚拟化（Full Virtualization）</strong></p><p>在客户操作系统看来，完全虚拟化的虚拟平台和现实平台是一样的，客户机操作系统察觉不到是运行在一个虚拟平台上，这样的虚拟平台可以运行现有的操作系统，无须对操作系统进行任何修改，因此这种方式被称为完全虚拟化。</p><p>进一步说，客户机的行为是通过执行反映出来的，因此VMM需要能够正确处理所有可能的指令。在实现方式上，以x86架构为例，完全虚拟化经历了两个阶段：软件辅助的完全虚拟化和硬件辅助的完全虚拟化。</p><p><strong>①软件实现的完全虚拟化</strong></p><p>在x86虚拟化技术的早期，没有在硬件层次上对虚拟化提供支持，因此完全虚拟化只能通过软件实现。一个典型的做法是二进制代码翻译（Binary Translation）。</p><p>二进制代码翻译的思想是，通过扫描并修改客户机的二进制代码，将难以虚拟化的指令转化为支持虚拟化的指令。VMM通常会对操作系统的二进制代码进行扫描，一旦发现需要处理的指令，就将其翻译成为支持虚拟化的指令块（Cache Block）。这些指令块可以与VMM合作访问受限的虚拟资源，或者显式地触发异常让VMM进一步处理。</p><p>这种技术虽然能够实现完全虚拟化，但很难在架构上保证其完整性。因此，x86厂商在硬件上加入了对虚拟化的支持，从而在硬件架构上实现了虚拟化。</p><p><strong>②硬件辅助完全虚拟化</strong></p><p>可以预料，如果硬件本身加入足够的虚拟化功能，可以截获操作系统对敏感指令的执行或者对敏感资源的访问，从而通过异常的方式报告给VMM，这样就解决了虚拟化的问题。硬件虚拟化时一种完备的虚拟化方法，因而内存和外设的访问本身也是由指令来承载，对处理器指令级别的截获就意味着VMM可以模拟一个与真实主机完全一样的环境。</p><p>Intel的VT-x和AMD的AMD-V是这一方向的代表。以VT-x为例，其在处理器上引入了一个新的执行模式用于运行虚拟机，当虚拟机执行在这个特殊模式中时，它仍然面对的是一套完整的处理器寄存器集合和执行环境，只是任何敏感操作都会被处理器截获并报告给VMM。</p><p>在当前的系统级虚拟化解决方案中，全虚拟化应用得非常普遍，典型的有知名的产品有VirtualBox、KVM、VMware Workstation和VMware ESX（它在其4.0版，被改名为VMware vSphere）、Xen（也支持全虚拟化）。</p><p><strong>（3）类虚拟化（Para-Virtualization）</strong></p><p>这样的虚拟平台需要对所运行的客户机操作系统进行或多或少的修改使之适应虚拟环境，因此客户机操作系统知道其运行在虚拟平台上，并且会去主动适应。这种方式被称为类虚拟化，有时也称作半虚拟化。另外，值得指出的是，一个VMM可以既提供完全虚拟化的虚拟平台，又提供类虚拟化的虚拟平台。</p><p>类虚拟化是通过在源代码级别修改指令以回避虚拟化漏洞的方式来使VMM 能够对物理资源实现虚拟化。上面谈到x86 存在一些难以虚拟化的指令，完全虚拟化通过Binary Translation在二进制代码级别上来避免虚拟化漏洞。类虚拟化采取的是另一种思路，即修改操作系统内核的代码，使得操作系统内核完全避免这些难以虚拟化的指令。</p><p>既然内核代码已经需要修改，类虚拟化进一步可以被用于优化I&#x2F;O。也就是说，类虚拟化不是去模拟真实世界中的设备，因为太多的寄存器模拟会降低性能．相反，类虚拟化可以自定义出高度优化的协议I&#x2F;O。这种I&#x2F;O协议完全基于事务，可以达到近似物理机的速度。</p><p>这种虚拟技术以Xen为代表，微软的Hyper-V所采用技术和Xen类似，也可以把Hyper-V归属于半虚拟化。</p><h4 id="按照实现结构分类"><a href="#按照实现结构分类" class="headerlink" title="按照实现结构分类"></a>按照实现结构分类</h4><p>在系统级虚拟化的实现中，VMM是一个关键角色，前面已介绍过VMM的组成部分。从Host实现VMM的角度出发，还可以将当前主流的虚拟化技术按照实现结构分为如下三类。</p><ul><li><strong>Hypervisor模型</strong></li></ul><p>Hypervisor这个术语是在 20 世纪 70 年代出现的，在早期计算机界，操作系统被称为Supervisor，因而能够在其他操作系统上运行的操作系统被称为 Hypervisor。</p><p>在Hypervisor模型中，VMM首先可以被看做是一个完备的操作系统，不过和传统操作系统不同的是，VMM是为虚拟化而设计的，因此还具备虚拟化功能。从架构上来看，首先，所有的物理资源如处理器、内存和I&#x2F;O设备等都归VMM所有，因此，VMM承担着管理物理资源的责任；其次，VMM需要向上提供虚拟机用于运行客户机操作系统，因此，VMM还负责虚拟环境的创建和管理。</p><p>由于VMM同时具备物理资源的管理功能和虚拟化功能，因此，物理资源虚拟化的效率会更高一些。在安全方面，虚拟机的安全只依赖于VMM的安全。Hypervisor模型在拥有虚拟化高效率的同时也有其缺点。由于VMM完全拥有物理资源，因此，VMM需要进行物理资源的管理，包括设备的驱动。我们知道，设备驱动开发的工作量是很大的。因此，对于Hypervisor模型来说这是个很大的挑战。事实上，在实际的产品中，基于Hypervisor模型的VMM通常会根据产品定位，有选择地挑选一些I&#x2F;O设备来支持，而不是支持所有的I&#x2F;O设备。</p><p>采用这种模型的典型是面向企业级应用的VMware vSphere。</p><ul><li><strong>宿主模型</strong></li></ul><p>与Hypervisor模型不同。在宿主模型中，物理资源由宿主机操作系统管理。宿主机操作系统是传统操作系统，如Windows 、Linux等，这些传统操作系统并不是为虚拟化而设计的，因此本身并不具备虚拟化功能，实际的虚拟化功能由VMM来提供。VMM通常是宿主机操作系统独立的内核模块，有些实现中还包括用户态进程，如负责I&#x2F;O虚拟化的用户态设备模型。 VMM通过调用宿主机操作系统的服务来获得资源， 实现处理器、内存和I&#x2F;O设备的虚拟化。VMM创建出虚拟机之后，通常将虚拟机作为宿主机操作系统的一个进程参与调度。</p><p>宿主模型的优缺点和Hypervisor模型恰好相反。宿主模型最大的优点是可以充分利用现有操作系统的设备驱动程序，VMM无须为各类I&#x2F;O设备重新实现驱动程序，可以专注于物理资源的虚拟化。考虑到I&#x2F;O设备种类繁多，千变万化， 设备驱动程序开发的工作量非常大，因此，这个优点意义重大。此外，宿主模型也可以利用宿主机操作系统的其他功能，例如调度和电源管理等，这些都不需要VMM重新实现就可以直接使用。</p><p>宿主模型当然也有缺点，由于物理资源由宿主机操作系统控制，VMM得要调用宿主机操作系统的服务来获取资源进行虚拟化，而那些系统服务在设计开发之初并没有考虑虚拟化的支持，因此，VMM虚拟化的效率和功能会受到一定影响。此外，在安全方面，由于VMM是宿主机操作系统内核的一部分，因此，如果宿主机操作系统内核是不安全的，那么，VMM也是不安全的，相应地运行在虚拟机之上的客户机操作系统也是不安全的。换言之，虚拟机的安全不仅依赖于VMM的安全，也依赖于宿主机操作系统的安全。</p><p>采用这种模型的典型是KVM、VirtualBox和VMware Workstation。</p><ul><li><strong>混合模型</strong></li></ul><p>混合模型是上述两种模式的汇合体。VMM依然位于最低层，拥有所有的物理资源。与Hypervisor模式不同的是，VMM 会主动让出大部分I&#x2F;O设备的控制权，将它们交由一个运行在特权虚拟机中的特权操作系统控制。相应地，VMM 虚拟化的职责也被分担．处理器和内存的虚拟化依然由VMM来完成，而I&#x2F;O的虚拟化则由VMM和特权操作系统共同合作来完成。</p><p>I&#x2F;O设备虚拟化由VMM和特权操作系统共同完成，因此，设备模型模块位于特权操作系统中，并且通过相应的通信机制与VMM合作。</p><p>混合模型集中了上述两种模型的优点。 VMM可以利用现有操作系统的I&#x2F;O设备驱动程序，不需要另外开发。VMM直接控制处理器、内存等物理资源，虚拟化的效率也比较高。</p><p>在安全方面，如果对特权操作系统的权限控制得当，虚拟机的安全性只依赖于VMM。当然，混合模型也存在缺点。由于特权操作系统运行在虚拟机上，当需要特权操作系统提供服务时，VMM需要切换到特权操作系统，这里面就产生上下文切换的开销。当切换比较频繁时，上下文切换的开销会造成性能的明显下降。出于性能方面的考虑，很多功能还是必须在VMM 中实现，如调度程序和电源管理等。</p><p>采用这种模型的典型是Xen。</p><h3 id="操作系统级虚拟化"><a href="#操作系统级虚拟化" class="headerlink" title="操作系统级虚拟化"></a>操作系统级虚拟化</h3><p>在操作系统虚拟化技术中，每个节点上只有唯一的系统内核，不虚拟任何硬件设备。通过使用操作系统提供的功能，多个虚拟环境之间可以相互隔离。通常所说的容器（Container）技术，如目前为止最流行的容器系统Docker，即属于操作系统级虚拟化。此外，在不同的场景中，隔离出的虚拟环境也被称作虚拟环境（即VE，Virtual Environment）或虚拟专用服务器（即VPS，Virtual Private Server）。</p><p>以容器技术为例，它有自己独特的优点，它的出现，一方面解决了传统操作系统所忽视和缺乏的应用程序间的独立性问题，另一方面，它避免了相对笨重的系统级虚拟化，是一种轻量级的虚拟化解决方案。</p><p>操作系统领域一直以来面临的一个主要挑战来自于应用程序间存在的相互独立性和资源互操作性之间的矛盾，即每个应用程序都希望能运行在一个相对独立的系统环境下，不受到其他程序的干扰，同时又能以方便快捷的方式与其他程序交换和共享系统资源。当前通用操作系统更强调程序间的互操作性，而缺乏对程序间相对独立性的有效支持，然而对于许多分布式系统如Web服务、数据库、游戏平台等应用领域，提供高效的资源互操作同保持程序间的相对独立性具有同等重要的意义。</p><p>主流虚拟化产品VMware和Xen等均采用Hypervisor模型（Xen采用的混合模型与Hypervisor模型差别不大，可统称为Hypervisor模型）。该模型通过将应用程序运行在多个不同虚拟机内，实现对上层应用程序的隔离。但由于Hypervisor 模型倾向于每个虚拟机都拥有一份相对独立的系统资源，以提供更为完全的独立性，这种策略造成处于不同虚拟机内的应用程序间实现互操作非常困难。例如， 即使是运行在同一台物理机器上，如果处于不同虚拟机内，那么应用程序间仍然只能通过网络进行数据交换，而非共享内存或者文件。而如果使用容器技术，由于各容器共享同一个宿主操作系统，能够在满足基本的独立性需求的同时提供高效的系统资源共享支持。</p><p>容器技术还可以更高效地使用系统资源，由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。此外，容器还具有更快速的启动时间，传统的虚拟机技术启动应用服务往往需要数分钟，而对于容器由于，直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大的节约了应用开发、测试、部署的时间。</p><h2 id="典型虚拟化技术实现及其特点"><a href="#典型虚拟化技术实现及其特点" class="headerlink" title="典型虚拟化技术实现及其特点"></a>典型虚拟化技术实现及其特点</h2><h3 id="系统级虚拟化实现"><a href="#系统级虚拟化实现" class="headerlink" title="系统级虚拟化实现"></a>系统级虚拟化实现</h3><h4 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h4><p>VMware是x86 虚拟化软件的主流广商之一。VMware的5位创始人中的3位曾在斯坦福大学研究操作系统虚拟化，项目包括SimOS系统模拟器和Disco虚拟机监控器。1998年，他们与另外两位创始人共同创建了VMware 公司，总部位于美国加州Palo Alto。</p><p>VMware提供一系列的虚拟化产品，产品的应用领域从服务器到桌面。下面是VMware主要产品的简介，包括VMware ESX、VMware Server和VMware Workstation。</p><p>VMware ESX Server是VMware的旗舰产品，后续版本改称VMware vSphere。ESX Server基于Hypervisor模型，在性能和安全性方面都得到了优化，是一款面向企业级应用的产品。VMware ESX Server支持完全虚拟化，可以运行Windows 、Linux、Solaris和Novell Netware等客户机操作系统。VMware ESX Server也支持类虚拟化，可以运行Linux 2. 6. 21 以上的客户机操作系统。ESX Server的早期版本采用软件虚拟化的方式，基于Binary Translation技术。自ESX Server 3开始采用硬件虚拟化的技术，支持Intel VT技术和AMD-V技术。</p><p>VMware Server之前叫VMware GSX Server，是VMware面向服务器端的入门级产品。VMware Server采用了宿主模型，宿主机操作系统可以是Windows或者Linux。VMware Server的功能与ESX Server类似，但是在性能和安全性上与ESX Server有所差距。VMware Server也有自己的优点，由于采用了宿主模型，因此VMware Server支持的硬件种类要比ESX Server多。</p><p>VMware Workstation是VMware面向桌面的主打产品。与VMware Server类似，VMware Workstation也是基于宿主模型，宿主机操作系统可以是Windows或者Linux。VMware Workstation也支持完全虚拟化，可以运行Windows、Linux、Solaris、Novell Netware和FreeBSD等客户机操作系统。与VMware Server不同， VMware Workstation专门针对桌面应用做了优化，如为虚拟机分配USB设备，为虚拟机显卡进行3D加速等。</p><h4 id="Microsoft"><a href="#Microsoft" class="headerlink" title="Microsoft"></a>Microsoft</h4><p>微软在虚拟化产品方面起步比VMware晚，但是在认识到虚拟化的重要性之后，微软通过外部收购和内部开发，推出了一系列虚拟化产品，目前已经形成了比较完整的虚拟化产品线。微软的虚拟化产品涵盖了服务器虚拟化（Hyper-V）和桌面虚拟化（Virtual PC）。</p><p>Virtual PC是而向桌面的虚拟化产品，最早由Connectix公司开发，后来该产品被微软公司收购。Virtual PC是基于宿主模型的虚拟机产品，宿主机操作系统是Windows。早期版本也采用软件虚拟化方式，基于Binary Translation技术。之后版本已经支持硬件虚拟化技术。</p><p>Windows Server 2008是微软推出的服务器操作系统，其中一项重要的新功能是虚拟化功能。其虚拟化架构采用的是混合模型，重要组件之一Hyper-V作为Hypervisor运行在最底层，Server 2008本身作为特权操作系统运行在Hyper-V之上。Server 2008采用硬件虚拟化技术，必须运行在支持Intel VT技术或者AMD-V 技术的处理器上。</p><h4 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h4><p>Xen是一款基于GPL授权方式的开源虚拟机软件。Xen起源于英国剑桥大学Ian Pratt领导的一个研究项目，之后，Xen独立出来成为一个社区驱动的开源软件项目。Xen社区吸引了许多公司和科研院所的开发者加入，发展非常迅速。之后，Ian成立了XenSource公司进行Xen的商业化应用，并且推出了基于Xen的产品Xen Server。2007年，Ctrix公司收购了XenSource公司，继续推广Xen的商业化应用，Xen开源项目本身则被独立到<a href="http://www.xen.org./">www.xen.org。</a></p><p>从技术角度来说，Xen基于混合模型，特权操作系统（ 在Xen中称作Domain 0）可以是Linux、Solaris以及NetBSD，理论上，其他操作系统也可以移植作为Xen的特权操作系统。Xen最初的虚拟化思路是类虚拟化，通过修改Linux内核，实现处理器和内存的虚拟化，通过引入I&#x2F;O的前端驱动&#x2F;后端驱动（front &#x2F; backend）架构实现设备的类虚拟化。之后也支持了完全虚拟化和硬件虚拟化技术。</p><h4 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h4><p>KVM（Kernel-based Virtual Machine）也是一款基于GPL授权方式的开源虚拟机软件。KVM 最早由Qumranet公司开发，在2006年出现在Linux内核的邮件列表上，并于2007年被集成到了Linux 2.6.20内核中，成为内核的一部分。</p><p>KVM支持硬件虚拟化方法，并结合QEMU来提供设备虚拟化。KVM的特点在于和Linux内核结合得非常好，而且和Xen一样，作为开源软件，KVM的移植性也很好。</p><h4 id="Oracle-VM-VirtualBox"><a href="#Oracle-VM-VirtualBox" class="headerlink" title="Oracle VM VirtualBox"></a>Oracle VM VirtualBox</h4><p>VirtualBox是一款开源虚拟机软件，类似于VMware Workstation。VirtualBox 是由德国Innotek公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle 收购后正式更名成 Oracle VM VirtualBox。Innotek 以 GNU General Public License (GPL) 释出 VirtualBox。用户可以在VirtualBox上安装并且执行Solaris、Windows、DOS、Linux、BSD等系统作为客户端操作系统。现在由甲骨文公司进行开发，是甲骨文公司VM虚拟化平台技术的一部分。</p><h4 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h4><p>Bochs 是一个 x86 计算机仿真器，它在很多平台上（包括 x86、PowerPC、Alpha、SPARC 和 MIPS）都可以移植和运行。使 Bochs 不仅可以对处理器进行仿真，还可以对整个计算机进行仿真，包括计算机的外围设备，比如键盘、鼠标、视频图像硬件、网卡（NIC）等。</p><p>Bochs 可以配置作为一个老式的 Intel® 386 或其后继处理器使用，例如 486、Pentium、Pentium Pro 或 64 位处理器。它甚至还可以对一些可选的图形指令进行仿真，例如 MMX 和 3DNow。</p><h4 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h4><p>QEMU是一套由Fabrice Bellard所编写的模拟处理器的自由软件。它与Bochs，PearPC近似，但其具有某些后两者所不具备的特性，如高速度及跨平台的特性，qemu可以虚拟出不同架构的虚拟机，如在x86平台上可以虚拟出power机器。kqemu为qemu的加速器，经由kqemu这个开源的加速器，QEMU能模拟至接近真实电脑的速度。</p><p>QEMU本身可以不依赖于KVM，但是如果有 KVM的存在并且硬件(处理器)支持比如Intel VT功能，那么QEMU在对处理器虚拟化这一块可以利用KVM提供的功能来提升性能。换言之，KVM缺乏设备虚拟化以及相应的用户空间管理虚拟机的工具，所以它借用了QEMU的代码并加以精简，连同KVM一起构成了一个完整的虚拟化解决方案，不妨称之为：KVM+QEMU。</p><h3 id="操作系统级虚拟化实现"><a href="#操作系统级虚拟化实现" class="headerlink" title="操作系统级虚拟化实现"></a>操作系统级虚拟化实现</h3><h4 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h4><p>容器的概念始于 1979 年的 UNIX chroot，它是一个 UNIX 操作系统上的系统调用，用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到该目录。这个功能的想法是为每个进程提供独立的磁盘空间。其后在 1982年，它被加入到了 BSD 系统中。</p><h4 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h4><p>LXC 的意思是 LinuX Containers，它是第一个最完善的 Linux 容器管理器的实现方案，是通过 cgroups 和 Linux 名字空间namespace实现的。LXC 存在于 liblxc 库中，提供了各种编程语言的 API 实现，包括 Python3、Python2、Lua、Go、Ruby 和 Haskell 等。与其它容器技术不同的是， LXC 可以工作在普通的 Linux 内核上，而不需要增加补丁。现在 LXC project 是由 Canonical 公司赞助并托管的。</p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>Docker 是到现在为止最流行和使用广泛的容器管理系统。它最初是一个叫做 dotCloud 的 PaaS 服务公司的内部项目，后来该公司改名为 Docker。Docker 开始阶段使用的也是 LXC ，之后采用自己开发的 libcontainer 替代了它。不像其它的容器平台，Docker 引入了一整个管理容器的生态系统，这包括高效、分层的容器镜像模型、全局和本地的容器注册库、清晰的 REST API、命令行等等。稍后的阶段， Docker 推动实现了一个叫做 Docker Swarm 的容器集群管理方案。</p><h4 id="Linux-VServer"><a href="#Linux-VServer" class="headerlink" title="Linux VServer"></a>Linux VServer</h4><p>Linux-VServer 也是一个操作系统级虚拟化解决方案。Linux-VServer 对 Linux 内核进行虚拟化，这样多个用户空间环境—又称为 Virtual Private Server（VPS） 就可以单独运行，而不需要互相了解。Linux-VServer 通过修改 Linux 内核实现用户空间的隔离。</p><p>Linux-VServer 也使用了 chroot 来为每个 VPS 隔离 root 目录。虽然 chroot 允许指定新 root 目录，但还是需要其他一些功能（称为 Chroot-Barrier）来限制 VPS 脱离其隔离的 root 目录回到上级目录。给定一个隔离的 root 目录之后，每个 VPS 就可以拥有自己的用户列表和 root 密码。</p><p>2.4 和 2.6 版本的 Linux 内核支持 Linux-VServer，它可以运行于很多平台之上，包括 x86、x86-64、SPARC、MIPS、ARM 和 PowerPC。</p><h4 id="Virtuozzo-x2F-OpenVZ"><a href="#Virtuozzo-x2F-OpenVZ" class="headerlink" title="Virtuozzo&#x2F;OpenVZ"></a>Virtuozzo&#x2F;OpenVZ</h4><p>Virtuozzo是SWsoft公司（目前SWsoft已经改名为Parallels）的操作系统虚拟化软件的命名，Virtuozzo是商业解决方案，而OpenVZ是以Virtuozzo为基础的开源项目，它们采用的也是操作系统级虚拟化技术。OpenVZ 类似于 Linux-VServer，它通过对 Linux 内核进行补丁来提供虚拟化、隔离、资源管理和状态检查。每个 OpenVZ 容器都有一套隔离的文件系统、用户及用户组等。</p><p><em>参考文献</em></p><ul><li>1 ] 金海, 廖小飞. 面向计算系统的虚拟化技术J]. 中国基础科学, 2008, 10(6):12-18.</li><li>2 ] 英特尔开源软件技术中心. 系统虚拟化M]. 清华大学出版社, 2009.</li><li>3 ] GeorgeCoulouris, 库鲁里斯, 金蓓弘,等. 分布式系统:分布式系统概念与设计M]. 机械工业出版社, 2013</li><li>4 ] Andrew S. Tanenbaum, Maarten van Steen. 分布式系统原理与范型M]. 清华大学出版社, 2004.</li><li>5 ] Barham P, Dragovic B, Fraser K, et al. Virtual machine monitors: Xen and the art of virtualizationJ]. Symposium on Operating System Principles, 2003, 36(August):164–177.</li><li>6 ] Qumranet A K, Qumranet Y K, Qumranet D L, et al. kvm: the Linux virtual machine monitorJ]. Proc Linux Symposium, 2007.</li><li>7 ] Adams K, Agesen O. A comparison of software and hardware techniques for x86 virtualizationC]&#x2F;&#x2F; ACM, 2006:2-13.</li><li>8 ] Uhlig R, Neiger G, Rodgers D, et al. Intel virtualization technologyJ]. Computer, 2005, 38(5):48-56.</li><li>9 ] Garfinkel T, Rosenblum M. A Virtual Machine Introspection Based Architecture for Intrusion DetectionJ]. Proceedings of the Network &amp; Distributed Systems Security Symposium, 2003:191–206.</li></ul><p><strong>参考资料</strong><br><a href="https://blog.csdn.net/mumuriyue/article/details/85714900">虚拟化技术的分类及介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>Hypervisor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hypervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟化技术</title>
    <link href="/2022/08/10/what-is-a-hypervisor/"/>
    <url>/2022/08/10/what-is-a-hypervisor/</url>
    
    <content type="html"><![CDATA[<p>Hypervisor是所有虚拟化技术的核心。</p><span id="more"></span><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>虚拟化技术源于提升计算机硬件资源使用效率的需求，发展出了Xen、KVM等众多硬件虚拟化方式的虚拟机技术、以Docker容器为代表的软件虚拟化技术，虚拟化技术实质上在不同层级上对于计算机的软硬件资源进行了模拟封装，使得这些资源可按需分配、配置和调度，也为云计算的发展奠定了坚实的基础，甚至可以说没有虚拟化技术的发展就没有云计算发展。</p><p>“虚拟化”的概念最早于1959年6月提出，牛津大学的计算机教授克里斯·托弗在国际信息处理大会上发表了一篇名为《大型高速计算机中的时间共享》的学术报告，文中首次提出了 “虚拟化” 的基本概念，并论述了什么是虚拟化技术。上个世纪60年代，IBM公司最先进行了虚拟化技术的实践探索，发明了一种操作系统虚拟机技术，允许用户在一台主机上运行多个操作系统，让用户尽可能地充分利用昂贵的大型机资源。最初主要运用于大型服务器上，但随着硬件技术突飞猛进的发展，普通PC的性能越来越强，也可用来运行虚拟机，构建云服务平台。</p><h4 id="常用的虚拟化技术有这些"><a href="#常用的虚拟化技术有这些" class="headerlink" title="常用的虚拟化技术有这些"></a>常用的虚拟化技术有这些</h4><ul><li>微软的Hyper-V</li><li>Linux中的KVM，XEN</li><li>VMware的ESXI</li><li>Docker</li></ul><p>虚拟化包含多个层面，比如硬件虚拟化，这种虚拟化从底层的硬件平台直接支持软件环境；另外一种是操作系统虚拟化，这是Linux的一个亮点。</p><p>在硬件层之上，独立于操作系统的一层软件被称之为hypervisor，或者叫做虚拟机监视器。hypervisor创建了虚拟化平台，而操作系统实例则运行在这个平台上，这使得硬件平台可以被多个操作系统和应用所共享，从而降低硬件的成本。<br>运行在hypervisor上面的实体被称为虚拟机，即VM，是用来放置操作系统、应用和数据元的“容器”。虚拟机中的操作系统和应用程序的数据被存储在虚拟磁盘中，hypervisor利用虚拟磁盘来启动虚拟化平台。虚拟机被封装为一个文件，这样比分布式的文件更好管理。</p><h4 id="虚拟机：虚拟化硬件"><a href="#虚拟机：虚拟化硬件" class="headerlink" title="虚拟机：虚拟化硬件"></a>虚拟机：虚拟化硬件</h4><p>虚拟机 Virtual Machine 指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。</p><p>在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。在容器技术之前，业界的网红是虚拟机。</p><p>虚拟机技术的代表，是 VMWare 和 OpenStack。</p><h4 id="容器：将操作系统层虚拟化，是一个标准的软件单元"><a href="#容器：将操作系统层虚拟化，是一个标准的软件单元" class="headerlink" title="容器：将操作系统层虚拟化，是一个标准的软件单元"></a>容器：将操作系统层虚拟化，是一个标准的软件单元</h4><ul><li><p>随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。</p></li><li><p>高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置 CPU 和内存的使用率，进而更好地利用服务器的计算资源。</p></li><li><p>快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。</p></li></ul><table><thead><tr><th>特性</th><th align="center">虚拟机</th><th align="center">容器</th></tr></thead><tbody><tr><td>隔离级别</td><td align="center">操作系统级</td><td align="center">进程</td></tr><tr><td>隔离策略</td><td align="center"><a href="https://baike.baidu.com/item/hypervisor/3353492?fr=aladdin">Hypervisor</a>（虚拟机监控器）</td><td align="center"><a href="https://baike.baidu.com/item/Cgroup/4988200?fr=aladdin">Cgroups</a>（控制组群）</td></tr><tr><td>系统资源</td><td align="center">5 ～ 15%</td><td align="center">0 ～ 5%</td></tr><tr><td>启动时间</td><td align="center">分钟级</td><td align="center">秒级</td></tr><tr><td>镜像存储</td><td align="center">GB - TB</td><td align="center">KB - MB</td></tr><tr><td>集群规模</td><td align="center">上百</td><td align="center">上万</td></tr><tr><td>高可用策略</td><td align="center">备份、容灾、迁移</td><td align="center">弹性、负载、动态</td></tr></tbody></table><p><strong>参考资料</strong><br><a href="https://www.ibm.com/cn-zh/topics/hypervisors?mhsrc=ibmsearch_a&mhq=hypervisor">IBM 虚拟机管理器</a><br><a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">RedHat 什么是虚拟机监控程序</a></p>]]></content>
    
    
    <categories>
      
      <category>Hypervisor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hypervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE 到底是什么</title>
    <link href="/2022/08/07/What-is-SRE/"/>
    <url>/2022/08/07/What-is-SRE/</url>
    
    <content type="html"><![CDATA[<p>什么是 SRE？SRE 需要具备什么能力？</p><span id="more"></span><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>SRE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算概论</title>
    <link href="/2022/08/06/Introduction-to-Cloud-Computing/"/>
    <url>/2022/08/06/Introduction-to-Cloud-Computing/</url>
    
    <content type="html"><![CDATA[<p>关于云计算基本特征、部署模型和服务模型</p><span id="more"></span><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p>让我们首先了解云的五个基本特征，包括按需自助服务、广泛的网络访问、资源池、快速弹性和可度量的服务。</p><p><strong>按需自助服务（On-demand Self-service）：</strong> 用户可以使用简单的界面访问云资源，如处理能力、存储和网络，而无需与每个服务提供商进行人工交互。</p><p><strong>广泛的网络访问（Broad Network Access）：</strong> 可以通过标准机制和平台（如手机、平板电脑、笔记本电脑和工作站）通过网络访问云计算资源。</p><p><strong>资源池（Resource Pooling）：</strong> 云提供商的规模经济，他们将其传递给客户，使云具有成本效益。使用多租户模型，将计算资源集中起来为多个消费者提供服务；云资源是根据需求动态分配和重新分配的，而客户无需关心这些资源的物理位置。</p><p><strong>快速弹性（Rapid Elasticity）：</strong> 用户可以在需要的时候访问更多的资源，在不需要的时候缩小规模，因为资源是弹性供应和释放的。</p><p><strong>可度量的服务（Measured Service）：</strong> 用户只为其使用或预订的东西付费。如果用户不使用资源，就不会付钱。根据利用率透明地监控、测量和报告资源使用情况。</p><h3 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h3><p><strong>Public Cloud：公共云</strong> 云服务提供商通过公共网络向用户提供云服务，用户可以根据自己的需求随时使用或释放资源。<br><strong>Private Cloud：私有云</strong> 云服务提供商在企业内部或数据中心中提供云服务，仅对内部员工或合作伙伴提供服务。<br><strong>Hybrid Cloud：混合云</strong> 结合了公有云和私有云的特点，使用户可以在公有云和私有云之间移动工作负载和数据。<br><strong>Community Cloud：社区云</strong> 特定的组织或行业提供的云服务，仅面向该组织或行业的成员。<br><strong>Multi-cloud：多云</strong> 同时采用两个或多个不同的云服务提供商，以获取更好的性能、可靠性、安全性和成本控制等方面的优势。<br><strong>Edge computing 边缘计算</strong> 在边缘设备上进行数据处理和存储，以减少数据传输和响应时间，提高应用程序性能。</p><h3 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h3><p><strong>Infrastructure as a Service (IaaS)：基础设施即服务</strong> 提供基础设施服务，例如虚拟机、存储、网络等。<br><strong>Platform as a Service (PaaS)：平台即服务</strong> 提供完整的应用程序开发和部署平台，包括开发、测试、部署和管理工具等。<br><strong>Software as a Service (SaaS)：软件即服务</strong> 提供基于云的应用程序服务，例如邮件、协作、客户关系管理等。<br><strong>Function as a Service (FaaS)：函数即服务</strong> 以事件驱动的方式提供计算服务，例如无服务器计算、事件处理等。<br><strong>Backend as a Service (BaaS)：后端即服务</strong> 提供云端的后端服务，例如数据库、身份认证、通知、存储等。<br><strong>Data as a Service (DaaS)：数据即服务</strong> 提供数据访问和分析服务，例如数据挖掘、数据分析、数据可视化等。<br><strong>Machine as a Service (MaaS)：机器即服务</strong> 提供物联网设备租赁或购买服务，例如传感器、智能家居设备等。<br><strong>Gaming as a Service (GaaS)：游戏即服务</strong> 提供云游戏服务，例如流媒体游戏、云端游戏服务器等。<br><strong>Container as a Service (CaaS)：容器即服务</strong> 提供容器管理平台，快速部署、运行和管理容器化应用程序。<br><strong>Anything as a Service (XaaS)：任何事物即服务</strong> 广义的术语，包括所有可以作为服务提供的事物，例如网络安全服务、身份认证服务、API管理服务等。</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Computing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算（Cloud Computing）</title>
    <link href="/2022/08/05/Cloud-Computing/"/>
    <url>/2022/08/05/Cloud-Computing/</url>
    
    <content type="html"><![CDATA[<p>关于云计算（Cloud Computing） 看懂云计算、虚拟化和容器，这一篇就够啦！</p><span id="more"></span><h2 id="云计算这个词，相信大家都非常熟悉了。"><a href="#云计算这个词，相信大家都非常熟悉了。" class="headerlink" title="云计算这个词，相信大家都非常熟悉了。"></a>云计算这个词，相信大家都非常熟悉了。</h2><p>云计算的准确定义，有比较多的先驱定义过，具体如下：</p><p><strong>Gartner公司</strong>将云计算定义为：「一种计算方式，能够通过Internet技术将可扩展的和弹性的IT能力作为服务交付给外部用户。」</p><p><strong>Forrester Research公司</strong>，将云计算定义为：「一种标准化的IT性能（服务，软件或者基础设施），以按使用付费和自助服务方式，通过Internet技术进行交付。」</p><p><strong>NIST（美国国家标准和技术研究院）</strong>，将云计算定义为：「云计算是一种模型，可以随时随地，便捷地，按需地从可配置计算资源共享池中获取所需的资源（例如，网络，服务器，存储，应用程序及服务），资源可以快速供给和释放，使管理的工作量和服务提供者的介入降低至最少。这种云模型，包括五个基本特征，三种服务模型和四种部署模型。」</p><p>“云计算”这个词，相信大家都非常熟悉。</p><p>作为信息科技发展的主流趋势，它频繁地出现在我们的眼前。伴随它一起出现的，还有这些概念名词——OpenStack、Hypervisor、KVM、Docker、K8S…</p><center><img src="https://img.darklorder.com/img/202305112240666.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这些名词概念，全部都属于云计算技术领域的范畴。</p><p>对于初学者来说，理解这些概念的具体含义并不是一件容易的事情。</p><p>所以，今天这篇文章，将给大家做一个通俗易懂的介绍，解释这些云计算概念以及它们之间的关系，希望对大家入门有所帮助。</p><h3 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h3><p>在介绍那些古怪名词之前，我先介绍一下<strong>云计算。</strong></p><p>以前电脑被发明的时候，还没有网络，每个电脑（PC），就是一个单机。</p><center><img src="https://img.darklorder.com/img/202305112242464.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这台单机，包括CPU、内存、硬盘、显卡等硬件。用户在单机上，安装操作系统和应用软件，完成自己的工作。</p><p>后来，有了<strong>网络（Network），</strong>单机与单机之间，可以交换信息，协同工作。</p><center><img src="https://img.darklorder.com/img/202305112243322.jpg"  alt="文件名" style="zoom:50%;" /></center><p>再后来，单机性能越来越强，就有了<strong>服务器（Server）。</strong>人们发现，可以把一些服务器集中起来，放在机房里，然后让用户通过网络，去访问和使用机房里的计算机资源。</p><center><img src="https://img.darklorder.com/img/202305112243607.jpg"  alt="文件名" style="zoom:50%;" /></center><p>再再后来，小型网络变成了大型网络，就有了<strong>互联网（Internet）。</strong>小型机房变成了大型机房，就有了<strong>IDC（Internet Data Center，互联网数据中心）。</strong></p><p>当越来越多的计算机资源和应用服务（Application，例如看网页，下电影）被集中起来，就变成了——<strong>“云计算（Cloud Computing）”。</strong>无数的大型机房，就成了“云端”。</p><center><img src="https://img.darklorder.com/img/202305112244542.jpg"  alt="文件名" style="zoom:50%;" /></center><p>是不是觉得太简单？别急，开始深入。</p><p>云计算的道理是简单的，说白了，就是把计算机资源集中起来，放在网络上。但是，云计算的实现方式，就非常复杂了。</p><p>举个例子，如果你只是在公司小机房摆了一个服务器，开个FTP下载服务，然后用于几个同事之间的电影分享，当然是很简单的。</p><p>如果是“双11”的淘宝购物节，全球几十亿用户访问阿里巴巴的淘宝网站，单日几十<strong>PB（1PB&#x3D;1024TB&#x3D;1024×1024GB）</strong>的访问量，每秒几百<strong>GB</strong>的流量……这个，就不是几根网线几台服务器能解决的了。</p><p>这时，需要设计一个<strong>超大容量、超高并发（同时访问）、超快速度、超强安全</strong>的云计算系统，才能满足业务平稳运行的要求。</p><p>这才是云计算的复杂之处。</p><p>刚才说了，我们把计算机资源放在云端。这个计算机资源，实际上分为好几种层次：</p><p><strong>第一层次，</strong>是最底层的硬件资源，主要包括CPU（计算资源），硬盘（存储资源），还有网卡（网络资源）等。</p><p><strong>第二层次，</strong>要高级一些，我不打算直接使用CPU、硬盘、网卡，我希望你把操作系统（例如Windows、Linux）装好，把数据库软件装好，我再来使用。</p><p><strong>第三层次，</strong>更高级一些，你不但要装好操作系统这些基本的，还要把具体的应用软件装好，例如FTP服务端软件、在线视频服务端软件等，我可以直接使用服务。</p><p>这三种层次，就是大家经常听到的<strong>IaaS、Paas、SaaS。</strong></p><center><img src="https://img.darklorder.com/img/202305112246787.jpg"  alt="文件名" style="zoom:50%;" /></center><p>SaaS: Software-as-a-Service（软件即服务）<br>PaaS: Platform-as-a-Service（平台即服务）<br>IaaS: Infrastructure-as-a-Service（基础设施即服务）</p><p>再补一张图，可能更直观：</p><center><img src="https://img.darklorder.com/img/202305112246104.jpg"  alt="文件名" style="zoom:50%;" /></center><p>目前主流的云计算服务提供商，例如亚马逊AWS、阿里云、华为云、天翼云、腾讯云，说白了，都是为大家提供以上三个层次的云资源。你想要什么，它们就提供什么。你想要多少，它们就提供多少。</p><center><img src="https://img.darklorder.com/img/202305112247813.jpg"  alt="文件名" style="zoom:50%;" /></center><p>继续，继续。</p><p>这么多样化多层次的云计算服务，阿里、华为们又是怎么提供的呢？</p><p>难道说，是人工安排？——</p><p>如果你要八核CPU、16GB内存、500GB硬盘的服务器，阿里临时安排工程师帮你组装？如果你要装CentOS 7.2（一种类Linux操作系统），MySQL 5.5.60（一种数据库系统），阿里也临时让工程师帮你安装配置？</p><p>这显然是不可能的，耗不起人力，也等不起时间。</p><p><strong>于是，就有了各种软件和平台，负责对资源进行快速调用和集中管理。</strong></p><h3 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h3><p>如果要对物理资源进行管理，第一步，就是<strong>“虚拟化”。</strong></p><p>虚拟化是云计算的基础。简单来说，虚拟化就是在一台物理服务器上，运行多台“虚拟服务器”。这种虚拟服务器，也叫<strong>虚拟机（VM，Virtual Machine）。</strong></p><p>从表面来看，这些虚拟机都是独立的服务器，但实际上，它们共享物理服务器的CPU、内存、硬件、网卡等资源。</p><center><img src="https://img.darklorder.com/img/202305112248949.png"  alt="文件名" style="zoom:50%;" /></center><p>物理机，通常称为“宿主机（Host）”。虚拟机，则称为“客户机（Guest）”。</p><p>谁来完成物理资源虚拟化的工作呢？</p><p>就是大名鼎鼎的 <strong>Hypervisor 。</strong></p><p>Hypervisor，汉译过来是“超级监督者”，也叫做VMM（Virtual Machine Monitor，虚拟机监视器）。它不是一款具体的软件，而是一类软件的统称。</p><p>Hypervisor分为两大类：</p><p>第一类，hypervisor直接运行在物理机之上。虚拟机运行在hypervisor之上。第二类，物理机上安装正常的操作系统（例如Linux或Windows），然后在正常操作系统上安装hypervisor，生成和管理虚拟机。</p><center><img src="https://img.darklorder.com/img/202305112249807.jpg"  alt="文件名" style="zoom:50%;" /></center><p>像<strong>VMware、KVM、Xen、Virtual Box，</strong>都属于Hypervisor。</p><p>VMware大家应该很熟悉，就是VMware Workstation。学习Linux的话，很多人都是在windows系统下安装WMware，然后创建Linux虚拟机。</p><center><img src="https://img.darklorder.com/img/202305112250795.jpg"  alt="文件名" style="zoom:50%;" /></center><p>但是，真正厉害的，是但是，真正厉害的，是 <strong>KVM（kernel-based virtual machine，基于Linux内核的虚拟机）。</strong>它是目前最热门最受追捧的虚拟化方案。</p><center><img src="https://img.darklorder.com/img/202305112251358.jpg"  alt="文件名" style="zoom:50%;" /></center><p>KVM这样的Hypervisor软件，实际上是提供了一种虚拟化能力，模拟CPU的运行，更为底层。但是它的用户交互并不良好，不方便使用。</p><p>于是，为了更好地管理虚拟机，就需要OpenStack这样的云管理平台。</p><center><img src="https://img.darklorder.com/img/202305112252953.jpg"  alt="文件名" style="zoom:50%;" /></center><p>关于OpenStack，我之前曾经介绍过（<a href="https://mp.weixin.qq.com/s?__biz=MzI1NTA0MDUyMA==&mid=2456660029&idx=1&sn=1a900a0c45ff77355693e7902c3d8f38&chksm=fda5055acad28c4c34d015b72843ef14c5529f81651cf38daddd1ce4d7e595c9f937f1ee3327&scene=21#wechat_redirect">链接</a>）。它有点像个商店，负责管理商品（计算资源、存储资源、网络资源等），卖给用户，但它本身不制造商品（不具备虚拟化能力），它的商品，来自于KVM。当然，如果不用KVM，也可以用Xen等其它hypervisor。</p><center><img src="https://img.darklorder.com/img/202305112252467.jpg"  alt="文件名" style="zoom:50%;" /></center><p>OpenStack的管理界面，比命令行好多了吧？</p><p>请记住，上面所说的几个概念，包括VM、KVM、OpenStack等，都主要属于IaaS（基础设施即服务）。这个不难理解吧？</p><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>继续往下说。</p><p>那么，容器是什么呢？大佬们经常说的Docker和K8S，又是什么呢？</p><p>前面我们介绍了虚拟化。人们在使用虚拟化一段时间后，发现它存在一些问题：</p><p>不同的用户，有时候只是希望运行各自的一些简单程序，跑一个小进程。为了不相互影响，就要建立虚拟机。如果建虚拟机，显然浪费就会有点大，而且操作也比较复杂，花费时间也会比较长。</p><p>而且，有的时候，想要迁移自己的服务程序，就要迁移整个虚拟机。显然，迁移过程也会很复杂。</p><p>有没有办法<strong>更灵活快速一</strong>些呢？</p><p>有，这就引入了<strong>“容器（Container）”。</strong></p><p>容器也是虚拟化，但是属于“轻量级”的虚拟化。它的目的和虚拟机一样，都是为了创造“隔离环境”。但是，它又和虚拟机有很大的不同——虚拟机是操作系统级别的资源隔离，而容器本质上是进程级的资源隔离。</p><center><img src="https://img.darklorder.com/img/202305112253652.jpg"  alt="文件名" style="zoom:50%;" /></center><p>虚拟化 VS 容器</p><p>而大家常听说的<strong>Docker，</strong>就是创建容器的工具，是应用容器引擎。</p><p>Docker的中文意思，就是码头工人。而它的LOGO，就是一只鲸鱼背着很多货柜箱。</p><center><img src="https://img.darklorder.com/img/202305112254729.jpg"  alt="文件名" style="zoom:50%;" /></center><p>相比于传统的虚拟机，Docker的优势很明显，它启动时间很快，是秒级，而且对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB，而容器只需要MB级甚至KB级。</p><center><img src="https://img.darklorder.com/img/202305112254245.jpg"  alt="文件名" style="zoom:50%;" /></center><p>除了Docker对容器进行创建之外，我们还需要一个工具，对容器进行<strong>编排。</strong></p><p>这个工具，就是<strong>K8S。</strong></p><p><strong>K8S，</strong>就是<strong>Kubernetes，</strong>中文意思是舵手或导航员。Kubernetes这个单词很长，所以大家把中间8个字母缩写成8，就成了K8S。</p><center><img src="https://img.darklorder.com/img/202305112255615.jpg"  alt="文件名" style="zoom:50%;" /></center><p>K8S是一个容器集群管理系统，主要职责是<strong>容器编排（Container Orchestration）</strong>——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。</p><p>简单来说，K8S有点像容器的保姆。它负责管理容器在哪个机器上运行，监控容器是否存在问题，控制容器和外界的通信，等等。</p><p>通过下面这张K8S系统结构图，就能够看出K8S和容器之间的关系。</p><center><img src="https://img.darklorder.com/img/202305112255372.jpg"  alt="文件名" style="zoom:80%;" /></center><p>除了K8S之外，还有很多种容器管理平台，例如<strong>Compose，Marathon，Swarm，Mesos</strong>等。</p><p>Docker和K8S，关注的不再是基础设施和物理资源，而是应用层，所以，就属于PaaS。明白了吧？</p><p>好啦，今天就先到这里了。再说下去，估计很多人又要晕啦。</p><p>正如文章开头所说，今天主要是介绍KVM、Hypervisor、OpenStack、Docker、K8S这些名词的意思，它们在云计算系统中的位置，以及它们之间的关系。云计算涉及到大量的需求。同一个需求，会有很多不同的技术来实现。同一个技术，往往又有多个不同的厂家互相竞争。所以，概念和名词就会特别多，发展变化也会很快。</p><p>不管怎么说，梳理清楚最关键的名词概念，是学好云计算的第一步。</p><p><strong>参考资料</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NTA0MDUyMA==&mid=2456665252&idx=1&sn=365da9095c9a1ed46886eab43b5bc003&chksm=fda511c3cad298d5679642973577a7380ad050fddc15fde6c5bd81f354aacc787fb9ee86bb7f&scene=21#wechat_redirect">看懂云计算、虚拟化和容器，这一篇就够啦！鲜枣课堂-作者小枣君</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Computing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>千万不要陷入“自证陷阱”</title>
    <link href="/2022/08/01/Self-certification-trap/"/>
    <url>/2022/08/01/Self-certification-trap/</url>
    
    <content type="html"><![CDATA[<p>如果有人冤枉你吃了他的东西，你不要剖开自己的肚子以证清白，应该挖出他的眼睛咽下去，让他在你肚子里，看看清楚。–《反击》</p><img src="https://img.darklorder.com/img/202308030445256.gif" style="zoom: 50%;"/><blockquote><p>看到这句话有些触动想到了《让子弹飞》里的六子，为了证明自己只吃了一碗粉而刨开肚子</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>丛林法则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writing Article</title>
    <link href="/2022/07/31/writing/"/>
    <url>/2022/07/31/writing/</url>
    
    <content type="html"><![CDATA[<p>写作</p><span id="more"></span><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><ul><li>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p><table><thead><tr><th align="center">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="left">source&#x2F;_posts</td></tr><tr><td align="center">page</td><td align="left">source</td></tr><tr><td align="center">draft</td><td align="left">source&#x2F;_drafts</td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source&#x2F;_drafts 文件夹，您可通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><ul><li>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</li></ul><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是文件最上方以 —— 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>title: Hello World<br><span class="hljs-built_in">date</span>: 2022-07-24 00:00:00<br>---<br></code></pre></td></tr></table></figure><ul><li>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="left"></td></tr><tr><td align="left"><code>lang</code></td><td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="left">Inherited from <code>_config.yml</code></td></tr></tbody></table><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">删除文件夹<span class="hljs-built_in">source</span>/_posts下目标文章markdown文件<br>删除.deploy_git文件夹<br>执行hexo cl 后，再执行 hexo g ，hexo s 即可。<br></code></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>创建 分类 页并添加 tpye 属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page categories<br></code></pre></td></tr></table></figure><p>source&#x2F;categories&#x2F;index.md 添加 categories 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: categories<br>date: 2022-07-24 00:00:00<br><span class="hljs-section">type: &quot;categories&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>给文章添加 categories 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: 写作<br>date: 2022-07-31 00:00:00<br>categories:<br><span class="hljs-section">- Hello World</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>打开需要添加分类的文章，为其添加categories属性。</li><li>下方的categories: Hello World 表示添加这篇文章到 Hello World 这个分类。</li><li>注意：hexo一篇文章只能属于一个分类，也就是说如果在 “- Hello World” 下方添加 “-xxx”，hexo不会产生两个分类，</li><li>而是把分类嵌套（即该文章属于 “- Hello World” 下的 “-xxx” 分类）。</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>创建 标签 页并添加 tpye 属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page tags<br></code></pre></td></tr></table></figure><p>source&#x2F;tags&#x2F;index.md 添加 tags 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: tags<br>date: 2022-07-24 00:00:00<br><span class="hljs-section">type: &quot;tags&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>给文章添加 tags 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: 写作<br>date: 2022-07-25 00:00:00<br>categories:<br><span class="hljs-bullet">-</span> Hello World<br>tags:<br><span class="hljs-bullet">-</span> Hello <br><span class="hljs-section">- World</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- Hello - World 就是这篇文章的标签了</li><li>至此，成功给文章添加分类，点击首页的 “标签” 可以看到该标签下的所有文章。</li><li>当然，只有添加了tags: xxx的文章才会被收录到首页的 “标签” 中。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>出身重要还是后天努力重要？</title>
    <link href="/2022/07/25/Origin-or-hard-work/"/>
    <url>/2022/07/25/Origin-or-hard-work/</url>
    
    <content type="html"><![CDATA[<p>我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”;你和别人同时搞，你比别人搞的好，就是“专家”。</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/24/hello-world/"/>
    <url>/2022/07/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>用户手册</p><span id="more"></span><h2 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a>用户手册</h2><h3 id="自动更新主题"><a href="#自动更新主题" class="headerlink" title="自动更新主题"></a>自动更新主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm update            <span class="hljs-comment">#  更新所有</span><br>$ npm update --save hexo-theme-fluid            <span class="hljs-comment"># 更新主题</span><br></code></pre></td></tr></table></figure><h3 id="手动更新主题"><a href="#手动更新主题" class="headerlink" title="手动更新主题"></a>手动更新主题</h3><p>修改根目录的package.json文件，将对应插件名称所对应的版本号更改为要更新的版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm <span class="hljs-built_in">ls</span>            <span class="hljs-comment"># 查询当前项目已安装插件版本</span><br>$ npm install --save            <span class="hljs-comment"># 更新</span><br></code></pre></td></tr></table></figure><h3 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean            <span class="hljs-comment"># 清理缓存 clean</span><br>$ hexo generate         <span class="hljs-comment"># 构建 build</span><br>$ hexo server           <span class="hljs-comment"># 本地启动 server</span><br>$ hexo deploy           <span class="hljs-comment"># 自动部署 deploy</span><br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&quot;博客配置&quot;</span> <span class="hljs-string">指的是</span> <span class="hljs-string">根目录下的</span> <span class="hljs-string">_config.yml</span><br><span class="hljs-string">&quot;主题配置&quot;</span> <span class="hljs-string">指的是</span> <span class="hljs-string">theme/fluid/_config.yml</span><br></code></pre></td></tr></table></figure><h3 id="顶部大图"><a href="#顶部大图" class="headerlink" title="顶部大图"></a>顶部大图</h3><p>主题配置中，每个页面都有名为 banner_img 的属性，可以使用本地图片的相对路径，也可以为外站链接。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml">  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span>          <span class="hljs-comment"># 对应存放在 /source/img/default.png</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://xxxx.com/img/default.png</span><br>  <br><span class="hljs-comment"># 高度</span><br>  <span class="hljs-string">鉴于每个人的喜好不同，开放对页面</span> <span class="hljs-string">banner_img</span> <span class="hljs-string">高度的控制。</span><br>  <span class="hljs-string">主题配置中，每个页面对应的</span> <span class="hljs-string">banner_img_height</span> <span class="hljs-string">属性，有效值为</span> <span class="hljs-number">0</span> <span class="hljs-bullet">-</span> <span class="hljs-number">100</span><span class="hljs-string">。100</span> <span class="hljs-string">即为全屏，个人建议</span> <span class="hljs-number">70</span> <span class="hljs-string">以上。</span><br><span class="hljs-comment"># 蒙版透明度</span><br>  <span class="hljs-string">主题配置中，每个页面对应的</span> <span class="hljs-string">banner_mask_alpha</span> <span class="hljs-string">属性，有效值为</span> <span class="hljs-number">0</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1.0</span><span class="hljs-string">，</span> <span class="hljs-number">0</span> <span class="hljs-string">是完全透明（无蒙版），1</span> <span class="hljs-string">是完全不透明</span><br></code></pre></td></tr></table></figure><h3 id="博客标题"><a href="#博客标题" class="headerlink" title="博客标题"></a>博客标题</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">博客标题</span><br></code></pre></td></tr></table></figure><h3 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;links&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/links/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-link-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li>key: 用于关联有语言配置，如不存在关联则显示 key 本身的值</li><li>link: 跳转链接</li><li>icon: 图标的 css class，可以省略（即没有图标），主题内置图标详见这里</li><li>name: 强制使用此名称显示（不再按语言配置显示），可省略</li></ul><p>另外支持二级菜单（下拉菜单），配置写法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;文档&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-books&#x27;</span>,<br>      <span class="hljs-attr">submenu:</span> [<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;主题博客&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;配置指南&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/guide/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;图标用法&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/icon/&#x27;</span> &#125;<br>      ]<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="全局字体"><a href="#全局字体" class="headerlink" title="全局字体"></a>全局字体</h3><p>设置单独的页面，可以直接在 markdown 里通过 style 标签实现：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&lt;style&gt;</span><br>  <span class="hljs-string">/*</span> <span class="hljs-string">设置整个页面的字体</span> <span class="hljs-string">*/</span><br>  <span class="hljs-string">html,</span> <span class="hljs-string">body,</span> <span class="hljs-string">.markdown-body</span> &#123;<br>    <span class="hljs-attr">font-family:</span> <span class="hljs-string">KaiTi</span>,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,<span class="hljs-string">Georgia</span>, <span class="hljs-string">sans</span>, <span class="hljs-string">serif;</span><br>    <span class="hljs-attr">font-size:</span> <span class="hljs-string">15px;</span><br>  &#125;<br><br>  <span class="hljs-string">/*</span> <span class="hljs-string">只设置</span> <span class="hljs-string">markdown</span> <span class="hljs-string">字体</span> <span class="hljs-string">*/</span><br>  <span class="hljs-string">.markdown-body</span> &#123;<br>    <span class="hljs-attr">font-family:</span> <span class="hljs-string">KaiTi</span>,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,<span class="hljs-string">Georgia</span>, <span class="hljs-string">sans</span>, <span class="hljs-string">serif;</span><br>    <span class="hljs-attr">font-size:</span> <span class="hljs-string">15px;</span><br>  &#125;<br><span class="hljs-string">&lt;/style&gt;</span><br></code></pre></td></tr></table></figure><h3 id="强制全局-HTTPS"><a href="#强制全局-HTTPS" class="headerlink" title="强制全局 HTTPS"></a>强制全局 HTTPS</h3><p>这种情况可以在主题配置中开启此配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">force_https:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="自定义-JS-x2F-CSS-x2F-HTML"><a href="#自定义-JS-x2F-CSS-x2F-HTML" class="headerlink" title="自定义 JS &#x2F; CSS &#x2F; HTML"></a>自定义 JS &#x2F; CSS &#x2F; HTML</h3><p>如果你想引入外部的 JS、CSS（比如 IconFont）或 HTML，可以通过以下主题配置，具体见注释：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 指定自定义 js 文件路径，路径是相对 source 目录</span><br><span class="hljs-attr">custom_js:</span> <span class="hljs-string">/js/custom.js</span><br><br><span class="hljs-comment"># 指定自定义 css 文件路径，路径是相对 source 目录</span><br><span class="hljs-attr">custom_css:</span> <span class="hljs-string">/css/custom.css</span><br><br><span class="hljs-comment"># 自定义 &lt;head&gt; 节点中的 HTML 内容</span><br><span class="hljs-attr">custom_head:</span> <span class="hljs-string">&#x27;&lt;meta name=&quot;key&quot; content=&quot;value&quot;&gt;&#x27;</span><br><br><span class="hljs-comment"># 自定义底部 HTML 内容（位于 footer 上方），也可用于外部引入 js css 这些操作，注意不要和 post.custom 配置冲突</span><br><span class="hljs-attr">custom_html:</span> <span class="hljs-string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css&quot;&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Slogan-打字机"><a href="#Slogan-打字机" class="headerlink" title="Slogan(打字机)"></a>Slogan(打字机)</h3><p>标题文字默认开启了打字机动效，相关配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">fun_features:</span><br>  <span class="hljs-attr">typing:</span> <span class="hljs-comment"># 为 subtitle 添加打字机效果</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typeSpeed:</span> <span class="hljs-number">70</span> <span class="hljs-comment"># 打印速度</span><br>    <span class="hljs-attr">cursorChar:</span> <span class="hljs-string">&quot;_&quot;</span> <span class="hljs-comment"># 游标字符</span><br>    <span class="hljs-attr">loop:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否循环播放效果</span><br></code></pre></td></tr></table></figure><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>若要手动指定摘要，使用 <!-- more --> MD文档里划分，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文的一部分作为摘要</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">余下的正文</span><br></code></pre></td></tr></table></figure><p>或者在 Front-matter 里设置 excerpt 字段，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ul><li>无论哪种摘要都最多显示 3 行，当屏幕宽度不足时会隐藏部分摘要。</li></ul><h3 id="文章跳转方式"><a href="#文章跳转方式" class="headerlink" title="文章跳转方式"></a>文章跳转方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_blank</span><br></code></pre></td></tr></table></figure><ul><li>_blank：新标签页打开</li><li>_self：当前标签页打开</li></ul><h3 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h3><p>如果想把某些文章隐藏起来，不在首页和其他分类里展示，可以在文章开头 Front-matter 中配置 hide: true 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><ul><li>隐藏会使文章在分类和标签类里都不显示</li><li>隐藏后依然可以通过文章链接访问</li></ul><h3 id="文章排序"><a href="#文章排序" class="headerlink" title="文章排序"></a>文章排序</h3><p>如果想手动将某些文章固定在首页靠前的位置，在文章开头 Front-matter 中配置 sticky 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><ul><li>sticky 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</li></ul><h3 id="文章在首页的封面图"><a href="#文章在首页的封面图" class="headerlink" title="文章在首页的封面图"></a>文章在首页的封面图</h3><p>对于单篇文章，在文章开头 Front-matter 中配置 index_img 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h3 id="文章页顶部大图"><a href="#文章页顶部大图" class="headerlink" title="文章页顶部大图"></a>文章页顶部大图</h3><p>默认显示主题配置中的 post.banner_img，如需要设置单个文章的 Banner，在 Front-matter 中指定 banner_img 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h3 id="文章内容本地图片"><a href="#文章内容本地图片" class="headerlink" title="文章内容本地图片"></a>文章内容本地图片</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-type">![](/img/example.jpg)</span><br></code></pre></td></tr></table></figure><h3 id="日期-x2F-字数-x2F-阅读时长-x2F-阅读数"><a href="#日期-x2F-字数-x2F-阅读时长-x2F-阅读数" class="headerlink" title="日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数"></a>日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数</h3><p>显示在文章页大标题下的文章信息，除了作者和阅读次数，其他功能都是默认开启的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">author:</span>  <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">date:</span>  <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;dddd, MMMM Do YYYY, h:mm a&quot;</span>  <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-attr">wordcount:</span>  <span class="hljs-comment"># 字数统计</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">min2read:</span>  <span class="hljs-comment"># 阅读时间</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span><br>    <span class="hljs-attr">views:</span>  <span class="hljs-comment"># 阅读次数</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span>  <span class="hljs-comment"># 统计数据来源，可选：leancloud | busuanzi   注意不蒜子会间歇抽风</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br></code></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>将脚注写在文末，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文</span><br><br><span class="hljs-comment">## 参考</span><br>[<span class="hljs-string">^1</span>]<span class="hljs-string">:</span> <span class="hljs-string">参考资料1</span><br>[<span class="hljs-string">^2</span>]<span class="hljs-string">:</span> <span class="hljs-string">参考资料2</span><br></code></pre></td></tr></table></figure><h3 id="Tag-插件"><a href="#Tag-插件" class="headerlink" title="Tag 插件"></a>Tag 插件</h3><p>在 markdown 中加入如下的代码来使用便签</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br><br>使用时 &#123;% note primary %&#125; 和 &#123;% endnote %&#125; 需单独一行，否则会出现问题<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-info">info</p><p class="note note-light">light</p><h3 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h3><p>在 markdown 中加入如下的代码来使用 Label：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% label primary @text %&#125;<br><br>若使用 &#123;% label primary @text %&#125;，text 不能以 @ 开头<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;label label-primary&quot;</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class="label label-primary">primary</span> <span class="label label-default">default</span> <span class="label label-info">info</span> <span class="label label-success">success</span> <span class="label label-warning">warning</span> <span class="label label-danger">danger</span></p><h3 id="组图"><a href="#组图" class="headerlink" title="组图"></a>组图</h3><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% gi total n1-n2-... %&#125;<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>&#123;% endgi %&#125;<br><br>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-...：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式<br>如下图为 &#123;% gi 5 3-2 %&#125; 示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。<br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div></div></div><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>标签是以词云的形式展示，标签的大小和颜色会根据标签下的文章数量变化，相关配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tag:</span><br>  <span class="hljs-attr">tagcloud:</span><br>    <span class="hljs-attr">min_font:</span> <span class="hljs-number">15</span><br>    <span class="hljs-attr">max_font:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">unit:</span> <span class="hljs-string">px</span>  <span class="hljs-comment"># 字号单位</span><br>    <span class="hljs-attr">start_color:</span> <span class="hljs-string">&quot;#BBBBEE&quot;</span><br>    <span class="hljs-attr">end_color:</span> <span class="hljs-string">&quot;#337ab7&quot;</span><br></code></pre></td></tr></table></figure><h3 id="友情链接页"><a href="#友情链接页" class="headerlink" title="友情链接页"></a>友情链接页</h3><p>友情链接页用于展示好友的博客入口，默认关闭，开启需要先在 navbar 项中将 links 的注释(#号)删掉：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;links&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/links/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-link-fill&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>然后找到 links 的配置项，对页面内容进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">links:</span><br>  <span class="hljs-attr">items:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Fluid Docs&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;主题使用指南&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span><br>    &#125;<br>  <span class="hljs-attr">default_avatar:</span> <span class="hljs-string">/img/avatar.png</span><br></code></pre></td></tr></table></figure><ul><li>title: 友链站的标题</li><li>intro: 站点或博主的简介，可省略</li><li>link: 跳转链接</li><li>avatar: 头像图片，可省略</li><li>default_avatar: 成员的默认头像（仅在指定了头像并且加载失败时生效）</li></ul><p>友链页也可以使用自定义区域和评论，使用方式类似于文章页，具体见配置项与相关注释。</p><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><p>如果想单独生成一个页面，步骤和创建「关于页」类似<br>先用命令行创建页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page example<br></code></pre></td></tr></table></figure><p>创建成功后编辑博客目录下 &#x2F;source&#x2F;example&#x2F;index.md：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">若不填默认是</span> <span class="hljs-string">title</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>正文默认没有 Markdown 样式，如果希望和文章相同的样式，可以加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;markdown-body&quot;</span>&gt;</span><br>正文<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面的参数配置可以在主题配置中统一设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">page:<br>  banner_img: /img/default.png<br>  banner_img_height: 70<br>  banner_mask_alpha: 0.3<br></code></pre></td></tr></table></figure><p>也可以直接在 Front-matter 里单独设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br><span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br><span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.5</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里可以写正文</span><br></code></pre></td></tr></table></figure><h3 id="Fluid-注入代码"><a href="#Fluid-注入代码" class="headerlink" title="Fluid 注入代码"></a>Fluid 注入代码</h3><p>进入博客目录下 scripts 文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">filter</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">injects</span>) &#123;<br>  injects.<span class="hljs-property">header</span>.<span class="hljs-title function_">file</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;source/_inject/test1.ejs&#x27;</span>, &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;, -<span class="hljs-number">1</span>);<br>  injects.<span class="hljs-property">footer</span>.<span class="hljs-title function_">raw</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;&lt;script async src=&quot;https://xxxxxx&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>header 和 footer 是注入点的名称，表示代码注入到页面的什么位置；</li><li>file 方法表示注入的是文件，第一个参数下面介绍，第二个参数则是文件的路径，第三个参数是传入文件的参数（可省略），第四个参数是顺序（可省略）；</li><li>raw 方法表示注入的是原生代码，第一个参数下面介绍，第二个参数则是一句原生的 HTML 语句；</li><li>default 表示注入的键名，可以使用任意键名，同一个注入点下的相同键名会使注入的内容覆盖，而不同键名则会让内容依次排列（默认按执行先后顺序，可通过 file 第四个参数指定），这里 default 为主题默认键名，通常会替换掉主题默认的组件；</li></ul><p>主题目前提供的注入点如下：</p><table><thead><tr><th>注入点名称</th><th>注入范围</th><th>存在 <code>default</code> 键</th></tr></thead><tbody><tr><td>head</td><td><code>&lt;head&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>header</td><td><code>&lt;header&gt;</code> 标签中所有内容</td><td>有</td></tr><tr><td>bodyBegin</td><td><code>&lt;body&gt;</code> 标签中的开始</td><td>无</td></tr><tr><td>bodyEnd</td><td><code>&lt;body&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>footer</td><td><code>&lt;footer&gt;</code> 标签中所有内容</td><td>有</td></tr><tr><td>postMetaTop</td><td>文章页 <code>&lt;header&gt;</code> 标签中 meta 部分内容</td><td>有</td></tr><tr><td>postMetaBottom</td><td>文章页底部 meta 部分内容</td><td>有</td></tr><tr><td>postMarkdownBegin</td><td><code>&lt;div class=&quot;markdown-body&quot;&gt;</code> 标签中的开始</td><td>无</td></tr><tr><td>postMarkdownEnd</td><td><code>&lt;div class=&quot;markdown-body&quot;&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>postLeft</td><td>文章页左侧边栏</td><td>有</td></tr><tr><td>postRight</td><td>文章页右侧边栏</td><td>有</td></tr><tr><td>postCopyright</td><td>文章页版权信息</td><td>有</td></tr><tr><td>postRight</td><td>文章页右侧边栏</td><td>无</td></tr><tr><td>postComments</td><td>文章页评论</td><td>有</td></tr><tr><td>pageComments</td><td>自定义页评论</td><td>有</td></tr><tr><td>linksComments</td><td>友链页评论</td><td>有</td></tr></tbody></table><p><strong>参考资料</strong><br><a href="https://github.com/fluid-dev/hexo-theme-fluid">Hexo Fluid GitHub</a><br><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
