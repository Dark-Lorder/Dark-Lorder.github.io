<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iPhone今天这个大漏洞，让人打开App就被盗刷一万五。。。</title>
    <link href="/2023/07/24/Spend-money-to-buy-lessons/"/>
    <url>/2023/07/24/Spend-money-to-buy-lessons/</url>
    
    <content type="html"><![CDATA[<p>微信零钱每日限额一万，微笑</p><span id="more"></span><p>众所周知，苹果一直在宣传自己的安全、隐私、可控。</p><p>而且在过去，它也足够的安全。</p><p>但世界上也没有绝对坚固的墙，大家也别因为这样，就彻底放松警惕。</p><p>因为今天，它就翻车了。。。</p><center><img src="https://img.darklorder.com/img/202307311242237.gif"  alt="文件名" style="zoom:100%;" /></center><p>事情是这样的，一个网友的丈母娘被 App Store 应用商店里的 “骗子 App” 骗走了一万五千元。</p><p>直到目前，他们被盗刷的钱都没能追回。</p><p>而我在复盘完事情的完整经过之后发现，其中两个重要环节，都是苹果出现了问题。</p><p>但凡苹果在这两个环节中的任何一个环节有安全措施，也不至于让骗子得逞。</p><p>先跟大家聊聊大概发生了什么事吧，大家可以先看看原博主 airycanon 描述的事情经过~</p><p>上下滑动可以查看完整长图</p><p><a href="https://img.darklorder.com/img/202307311319978.jpg">图片</a></p><p>简单来说，就是 airycanon 的丈母娘从 AppStore 应用商店里下载了一个菜谱 App。</p><p>但是这个 App 本身有问题，打开 App 之后，首先会弹出一个 Apple 账号登录界面。</p><img src="https://img.darklorder.com/img/202307311248469.png"/><p>用过 iPhone 的小伙伴都知道，不少 App 都支持使用苹果账号一键注册登录，就像微信小程序一键登录一样。</p><p><strong>所以这一步看起来是合理的。</strong></p><p>但其实，真正的苹果一键登录界面，是这个样子的：</p><p>大家可以上下对比看看</p><img src="https://img.darklorder.com/img/202307311248753.png"/><p>菜谱 App 弹出的那个“假登录界面”，其实也是有用的，<strong>它在后台已经完成了一次苹果账号登录。</strong></p><p>至于有什么用途，我们放到后面再说。</p><p>登录弹窗之后，这个 App 又弹出一个仿照系统界面设计的密码输入界面。</p><p>因为长得和安装应用时候的密码验证界面很像，手机用的不那么灵光的老人还是很容易中招的。</p><p>App”L”eID。。。</p><img src="https://img.darklorder.com/img/202307311249332.png"/><p>自此，骗子就搞到了受害者 iPhone 的账号和密码。</p><p>假如用户给苹果账号绑定了支付方式 —— 就比如 airycanon 的丈母娘绑定了微信免密支付。。。</p><p>那骗子就可以开始盗号刷刷刷了。</p><p>u1s1，这个骗子绝对是个惯犯。<strong>他为了避免受害人收到短信交易提醒，盗刷之前甚至还利用查找 iPhone 远程把受害者的手机给重置恢复出厂设置了。。。</strong></p><p>这要是没用 iCloud 备份相册的人，不得气疯了。。。</p><p><strong>真·砂仁猪心。</strong></p><p>OK，事情大概就是这么一回事，讲道理，看完之后我整个人就是一个大写的懵。</p><p>首先，我倒是理解这种骗人 App 能堂而皇之在苹果官方 App Store 上架。。。</p><p><strong>因为骗过苹果商店审核的操作在业内根本不算什么秘密。</strong></p><p>马甲包、同 ID 双版本、幸运按钮。。。黑产总有办法。</p><img src="https://img.darklorder.com/img/202307311250825.png"/><p>比如我也在 App Store 里下载了几个菜谱大全，他们倒是没有盗我的密码，但是点开以后也都不是菜谱。</p><p><strong>而是一个个关不掉的强制弹窗，“ 帮 ” 我开各种彩铃包、权益合约包。。。</strong></p><img src="https://img.darklorder.com/img/202307311250766.png"/><p>难得遇到了一个正经菜谱 App，结果刚看了两个菜，就要收我 28。。。</p><p><strong>不对，是每周 28 块钱。。。</strong></p><p>我估计正经厨房类 App 的产品经理们都得看傻了：同行们黑心钱都这么好赚的吗？</p><p>“ 非强制消费”</p><img src="https://img.darklorder.com/img/202307311250241.png"/><p>但是，就算 App 能通过钓鱼的方式骗到受害者苹果账户的密码，但是苹果本身是有 “ 两步验证 ” 机制的呀？</p><p>在登录新设备或者浏览器的时候，除了输入密码，苹果还会要求输入一个短信验证码。</p><p>而且 airycanon 也在帖子里说明了，他丈母娘的 Apple ID 已经开启了两步验证。</p><p>但是他们自始至终没有收到苹果的验证码。</p><img src="https://img.darklorder.com/img/202307311251965.png"/><p>这时候他发现，<strong>丈母娘账号的两步验证设置里，多出来了一个从来没见过的境外号码。</strong></p><p>怪不得自己手机上没有验证码了，<strong>因为接收验证码的手机已经变成骗子的手机了。。。</strong></p><p>考虑到设置两步验证是一个挺复杂的操作、即使手把手跟丈母娘说都不一定能设置成功。</p><p>那这个号码只能是骗子偷偷添加进来的了。。。</p><img src="https://img.darklorder.com/img/202307311251618.png"/><p>这就很离谱了好吧，因为虽然“菜谱骗子”们骗过了苹果的 App 审核，<strong>但它们最多也只是诈骗，是在玩弄社会工程学，而不是病毒。</strong></p><p><strong>理论上来说，它们根本没有办法绕过苹果最根本的安全措施，在不弹任何验证码的情况下往苹果的双证验证系统里加入<strong><strong>能收验证码的新手机号</strong></strong>。。。</strong></p><p>这一点是我和编辑部小伙伴们都感觉非常诧异的，也是今天关注到这件事的网友们讨论最激烈的。</p><p>不过在一段讨论之后，研究苹果开发的 BugOS 技术组提到了一种可能的思路：</p><img src="https://img.darklorder.com/img/202307311252605.png"/><p>上面截图里的内容大家看不懂没关系，简单来说，<strong>苹果浏览器框架的安全策略出了问题。</strong></p><p>事情大概是这么回事：我们都知道，不管是 iPhone，还是安卓手机，系统里都会有一个预装的默认网页浏览器对不对。</p><img src="https://img.darklorder.com/img/202307311252308.png"/><p>比如 iPhone 上就是 Safiri，安卓这边则是各家的自带浏览器。</p><p>但这其实只是表面上的浏览器。</p><p>但其实，<strong>再往系统底层找，还有一个“没有图标”的浏览器框架：WebView。</strong></p><img src="https://img.darklorder.com/img/202307311252723.png"/><p>这个 “ 浏览器框架 ” 不能被普通用户在手机里直接点开，它存在的意义，是供其他 App 调用的。</p><p>我们举个例子，就比方说美团、滴滴他们经常在 App 里搞领券的活动，对于这种临时的活动页面一般就是写个网页。</p><img src="https://img.darklorder.com/img/202307311253933.png"/><p>这些 “ App 内的网页 ”，实际上都不是 App 本身在渲染，而是美团和滴滴拉起了系统里的 WebView 组件来进行渲染的。</p><p>这个组件其实帮了开发者很大的忙，假如没有 WebView 浏览器框架的话，包括美团和滴滴在内的所有 App 开发者，都得往 App 里再额外集成一个独立的浏览器内核。</p><p>本身现在的 App 们就已经很占存储空间了，要是一人再背一个 Chrome。。。</p><p>画面太美了，我不敢想！</p><p>另外，作为网络世界的窗口，浏览器漏洞本身也是很多黑客行为的突破口。</p><p>系统本身提供一个全局自动更新的浏览器框架，也可以避免一些 App 不更新内置的浏览器内核，导致黑客趁虚而入。</p><p><strong>这次的问题，恰恰就出在这个 “为了不出问题” 而设计的系统级浏览器框架上。</strong></p><p>不知道大家有没有体验过系统浏览器的 “<strong>便捷单点登录</strong>” 功能。</p><p>就比方说，假如你在 Windows 电脑上使用自带的 Edge 浏览器打开微软账户官网，Edge 浏览器不会让你输入微软账户的账号密码。</p><p>而是会自动读取当前电脑里登录的微软账户，然后帮你在浏览器网站里完成登录。</p><img src="https://img.darklorder.com/img/202307311253625.png"/><p>假如你在登录了谷歌账号的安卓手机上使用谷歌 Chrome 浏览器，它也会自动帮你完成登录操作。</p><img src="https://img.darklorder.com/img/202307311254951.png"/><p>苹果也是如此，假如你在 Safari 浏览器里打开 Apple ID 官网，并点击登录。</p><p>浏览器也不会让你输入密码，而是直接弹出来一个登陆操作的确认框。</p><img src="https://img.darklorder.com/img/202307311254573.gif"/><p>假如你点了 “ 继续 ”，得益于高性能的苹果 A16 处理器，系统会光速弹出 Face ID 验证。</p><p>一个眨眼的功夫，就登录成功了。</p><img src="https://img.darklorder.com/img/202307311255122.png"/><p>诶，等会儿。。。</p><p><strong>这个登陆框，怎么有点儿眼熟啊？？？</strong></p><p><strong>为什么 “ 菜谱大全 ” 会请求登录 Apple ID 官网啊？？？</strong></p><img src="https://img.darklorder.com/img/202307311255195.png"/><p>说真的，假如没有对比的话，菜谱大全的操作很容易会被大家当成是普通的 “ 一键注册账号 ” ——</p><p>包括发帖的 airycanon 也没反应过来，以为是丈母娘没有选苹果的隐私邮箱登录选项才暴露了 Apple ID，让黑客掌握了信息。</p><p>真正的一键注册环节会要求选择是否隐藏邮件地址</p><img src="https://img.darklorder.com/img/202307311256034.png"/><p>实际上，当这个确认窗验证完毕之后，骗子都已经准备好往账号里加料了。。。</p><img src="https://img.darklorder.com/img/202307311256164.png"/><p>“ 菜谱大全 ” 之所以能够一键登录，恰恰就是利用了 WebView 这个系统级浏览器框架的 “ 便捷登录 ” 特性。</p><p>表面上，是一个菜谱 App，<strong>而在它的内部，隐藏了一个正在访问 Apple ID 官网、并准备篡改用户接收验证短信手机号的浏览器界面。</strong></p><p>我后来看 BugOS 技术组又发了一个微博，他们已经用自己写的代码还原完整个攻击过程了。</p><img src="https://img.darklorder.com/img/202307311256161.png"/><p>按照苹果 Apple ID 官网目前的安全逻辑，<strong>只有一开始的账号登录环节需要下发验证码做双重验证。</strong></p><p>而这最开始的一步，骗子已经通过 WebKit 的便捷登录绕过去了。</p><p><strong>已经处于登录状态的情况下，只要输固定的账号密码，就可以直接添加新的验证手机了。</strong></p><img src="https://img.darklorder.com/img/202307311257506.gif"/><p>现在相信大家已经彻底搞明白背后是怎么一回事儿了，这时候我们再重新回看故事的全貌：</p><p>“ 菜谱大全 ” 先是在表层界面的下面，隐藏了一个 WebView 浏览器组件，然后利用它系统级的 “便捷登录” 能力，进入了 Apple ID 官网。</p><p>接着，它给用户弹出了一个密码输入框，用来搞定添加验证手机的最后一步障碍。</p><img src="https://img.darklorder.com/img/202307311258021.png"/><p>拿到密码之后，App 就会偷偷跑起添加新验证手机的自动脚本，这时候受害者的苹果账号就已经不属于自己了。</p><p>什么时候发起攻击，全看黑客心情了。</p><p>OK，复盘完毕，这么一看好像还是受害者太傻，平白无故把密码交出来了对不对 —— 假如受害者打死不填密码，黑客也没招。</p><p>我们不应该骂苹果对不对？</p><p>emmmm，在下这个结论之前，我想先带大家看一看苹果的老对手 —— 谷歌是怎么做的。</p><img src="https://img.darklorder.com/img/202307311258470.png"/><p>和苹果 Apple ID 一样，只要已经处于登录状态了，谷歌这边的账号系统要想添加新的验证手机，也只是输一下固定密码的事。</p><p><strong>但是和苹果不同，谷歌根本不允许系统的 WebView 组件使用 “便捷登录” 技术。</strong></p><p>我在自己的安卓手机上做了个小测试，分别使用谷歌 Chrome 浏览器和 Via 浏览器（ 一款直接调用系统 WebView 框架的极简浏览器 App ）访问谷歌账号官网。</p><p>Chrome 浏览器因为已经获取了系统里的账号登录状态，因此直接就登录了。</p><p>Via 浏览器则没有这个能力，需要一步步重新输入账号、密码、验证码。</p><img src="https://img.darklorder.com/img/202307311259604.png"/><p>换句话说，假如有骗子想在安卓手机上做一个同样套路的事，第一步就卡住了。。。</p><p>但是在苹果系统里，不管是调用 WebView 的 Via，还是真正的自带浏览器 Safari，<strong>都能调用便捷登录。</strong></p><p>再搭配上 App Store 的审核漏洞，一锅好菜就出炉了。。。</p><img src="https://img.darklorder.com/img/202307311259869.png"/><p>严格来说，这对于 iOS 系统来说也算是一个漏洞 —— 它不是代码漏洞，而是一个逻辑漏洞。</p><p>骗子利用苹果开放的便捷登录能力，伪装了自己一波，再利用一点点社工技巧，就把钱骗到手了。</p><p>由于系统逻辑漏洞造成的问题，正确的解决方式应该是着手准备 OTA 补丁，同时帮着受骗的用户追回损失。</p><p>不过苹果给这个受害者带来的感知，并不是很好。。。</p><img src="https://img.darklorder.com/img/202307311259025.png"/><p>可能现在时间还比较短，希望苹果后续可以帮这个受害者妥善解决。</p><p><strong>不瞒大家说，本来我今天是没打算写这篇文章的。</strong></p><p>因为真要细究的话，安卓这边虽然把 WebView 的洞补上了，但是其他的漏洞更多、骗人的方式根本数不过来。</p><p>苹果生态总体来说都还是更安全的、让人用着更放心的，但是大家不要因为它 “安全” 的标签就变得麻木、不重视安全了。</p><p>就像大家都说沃尔沃安全，但你不能因为这点就不握着方向盘了。。。</p><p>相信很多给家长买 iPhone 的小伙伴，都是希望家长尽可能不被骗。</p><p>但我觉得，我们还是要告诉他们即便是 iPhone，即便是 App Store，也不能保证绝对安全。</p><p>不随便输密码、不给所有 App 用一模一样的密码是最后的底线。</p><p><strong>千万记得叮嘱他们，免密支付能不开就不开。</strong> <strong>如果开了的话，免密支付的卡里面也不要放太多的钱。</strong></p><p><strong>参考资料</strong><br><a href="https://mp.weixin.qq.com/s/G55w5UakMUcuhWyUPaHFYQ">iPhone今天这个大漏洞，让人打开App就被盗刷一万五。。。</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作为了生活，生活不是为了工作</title>
    <link href="/2023/01/04/Life-and-work/"/>
    <url>/2023/01/04/Life-and-work/</url>
    
    <content type="html"><![CDATA[<p><strong>乐视认为,生活绝不是为了更好地工作,但工作一定是为了更好地生活。</strong></p><span id="more"></span><p>这几天有几个朋友向我诉苦，</p><p>想换份工作。</p><p>而我只做过一份工作，</p><p>感觉没资格提意见。</p><p>如果真的要我说，</p><p>我希望你可以做自己擅长做的事，</p><p>其次也要做一份自己喜欢做的事，</p><p>碰巧你擅长做的也是你喜欢做的事，</p><p>那我为你感到庆幸。</p><p>工作为了生活，生活不是为了工作。</p><p>Recently some closed friends complained to me about changing their jobs.</p><p>But I am not qualified to comment due to I never change jobs before.</p><p>It is my little tips below:</p><p>First I hope you could do the jobs you are good at,</p><p>Secondly I hope you could do the jobs you like.</p><p>You will be lucky if the jobs you good at is same jobs you like.</p><p>Enjoy your work, enjoy you life.</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>走在自己的时区里</title>
    <link href="/2023/01/01/walk-in-your-own-time-zone/"/>
    <url>/2023/01/01/walk-in-your-own-time-zone/</url>
    
    <content type="html"><![CDATA[<p><strong>美国的一首小诗</strong></p><span id="more"></span><p>在时间上，纽约走在加州前面三个小时，</p><p>New York is 3 hours ahead of California,</p><p>但加州并没有变慢。</p><p>but it does not make California slow.</p><p>有人22岁就毕业了，</p><p>Someone graduated at the age of 22,</p><p>但等了五年才找到好工作！</p><p>but waited 5 years before securing a good job!</p><p>有人25岁就当上了CEO，</p><p>Someone became a CEO at 25,</p><p>却在50岁去世了。</p><p>and died at 50.</p><p>也有人直到50岁才当上CEO，</p><p>While another became a CEO at 50,</p><p>最后活到90岁。</p><p>and lived to 90 years.</p><p>有人依然单身，</p><p>Someone is still single,</p><p>而别人却早已结婚。</p><p>while someone else got married.</p><p>奥巴马55岁退任总统，</p><p>Obama retires at 55,</p><p>而川普却是70岁才开始当。</p><p>but Trump starts at 70.</p><p>世上每个人都有自己的发展时区。</p><p>Absolutely everyone in this world works based on their Time Zone.</p><p>身边有些人看似走在你前面，</p><p>People around you might seem to go ahead of you,</p><p>也有人看似走在你后面。</p><p>some might seem to be behind you.</p><p>但其实每个人在自己的时区有自己的步程。</p><p>But everyone is running their own RACE, in their own TIME.</p><p>不用嫉妒或嘲笑他们。</p><p>Don’t envy them or mock them.</p><p>他们都在自己的时区，你在你的！</p><p>They are in their TIME ZONE, and you are in yours!</p><p>生命就是等待正确的时机行动。</p><p>Life is about waiting for the right moment to act.</p><p>所以，放轻松。</p><p>So, RELAX.</p><p>你没有落后，</p><p>You’re not LATE.</p><p>你没有领先。</p><p>You’re not EARLY.</p><p>在命运为你安排的属于你自己的时区里，一切都非常准时。</p><p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云原生 2.0 白皮书</title>
    <link href="/2022/10/01/Cloud-native-white-paper/"/>
    <url>/2022/10/01/Cloud-native-white-paper/</url>
    
    <content type="html"><![CDATA[<p>企业 IT 建设的三阶段两转变，进入云原生阶段</p><span id="more"></span><p>简单来看，企业 IT 建设所依赖的基础资源经历了从服务器到云化资源的发展历程，正在快速进入云原生阶段。</p><p>服务器阶段 ：其特点是以硬件设备为中心，业务应用随不同厂商设备、操作系统、虚拟化软件的差异化进行定制；设备的安装、调试，应用的部署、运维基本靠人力完成，自动化程度低，缺乏统一的设备和应用管理能力。后期随着虚拟化软件的出现，资源的利用率、扩缩容器的灵活性方面得到一定的提升，但并未从根本上解决基础设施与软件割裂、运维复杂的难题。</p><p>云化阶段：传统模式下分布离散的设备，被统一起来，实现了各类资源如计算、存储、网络的池化，通过统一的虚拟化软件平台，为上层业务软件提供统一的资源管理接口，实现资源管理能力的自动化，屏蔽一部分基础设施的差异，使得应用的通用性增强，但因为虚拟化软件平台差异化较大，尤其是各厂商的一些商业化增强，无法在厂商间进行能力共享，应用还是无法以完全标准化的模式构建，应用部署还是以资源为中心。</p><p>云原生阶段：在这一阶段，企业的关注点从以资源为中心转移到以应用为中心，包括应用敏捷交付、快速弹性、平滑迁移、无损容灾等。因此，企业开始考虑如何将基础设施与业务平台融合，为业务应用提供标准的运行、监控、治理平台，并将业务的通用能力下沉到平台侧，更好的帮助企业实现应用的自动化。</p><p><strong>企业IT数字化转型的“三阶段两转变”</strong></p><img src="https://img.darklorder.com/img/202307311440454.png"/><p><strong>参考资料</strong><br>云原生2.0白皮书</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式计算中的八大谬论</title>
    <link href="/2022/10/01/The-Eight-Fallacies-of-Distributed-Computing/"/>
    <url>/2022/10/01/The-Eight-Fallacies-of-Distributed-Computing/</url>
    
    <content type="html"><![CDATA[<p>分布式计算中的八大谬论</p><span id="more"></span><img src="https://img.darklorder.com/img/202307070417934.jpeg"/><p>构建分布式系统是一项复杂的工作。架构，设计，编码和测试对分布式系统的成功都至关重要。任何一点的失败都可能导致性能下降，故障频发，费用超标以及最终导致客户流失。在20世纪90年代Sun Microsystems的Peter Deutsch，James Gosling和其他人总结出了分布式计算的八个谬论。随着时间的推移，IT人员对这些谬论的认识可能已经消退，所以想要提醒下大家。</p><h3 id="八大谬论是："><a href="#八大谬论是：" class="headerlink" title="八大谬论是："></a><strong>八大谬论是：</strong></h3><p><strong>网络可靠。 The network is reliable.</strong><br><strong>延迟为零。 Latency is zero.</strong><br><strong>带宽是无限的。 Bandwidth is infinite.</strong><br><strong>网络是安全的。 The network is secure.</strong><br><strong>拓扑不会改变。 Topology doesn’t change.</strong><br><strong>只有一个管理员。 There is one administrator.</strong><br><strong>运输成本为零。 Transport cost is zero.</strong><br><strong>网络是同质的。The network is homogeneous.</strong></p><h4 id="网络可靠"><a href="#网络可靠" class="headerlink" title="网络可靠"></a>网络可靠</h4><p>在局域内，网络可能看起来坚如磐石。毕竟，现在网络组件多久失败一次？即使单个组件发生故障，也确实存在大量冗余？那么，随着网络变得越来越复杂，网络管理就越容易出错，大多数都是配置错误。在某些情况下，多达三分之一的网络更改会导致影响网络可靠性的错误。软件和硬件都可能出现故障，尤其是路由器，它们占所有故障的四分之一左右。“不间断”电源也可能会中断，人们可能会发生不明智的设备配置更改，并且可能存在网络拥塞，拒绝服务（DoS）攻击以及软件和固件升级或修补程序失败。网络遭受自然灾害和非自然灾害，设计一个对这类东西具有弹性的网络需要技巧。广域链接超出您的控制范围，很容易出错。</p><p>最近几个月，Azure上的事件令人痛苦，而且这种失败率是主要云服务提供商的典型特征。对于移动应用程序，各种各样的事情都可能会出错：网络请求将以不可预测的间隔失败，目标将不可用，数据将到达目的地但无法发回确认，数据将在传输中损坏或到达不完整。移动应用程序必须在网络可靠性范围的可怕范围内具有弹性，但所有分布式应用程序必须能够应对所有这些可能性，并且网络节点必须能够应对服务器故障。</p><h4 id="延迟为零"><a href="#延迟为零" class="headerlink" title="延迟为零"></a>延迟为零</h4><p>延迟与带宽不同。延迟是等待响应所花费的时间。除了明显的处理延迟外，还有网络延迟，包括传播延迟，节点延迟和拥塞延迟。传播延迟随距离增加：约为30 ms。欧洲和美国之间。路径中的节点数决定了节点延迟。</p><p>通常，开发人员在内部网中构建分布式系统，这些系统具有无关紧要的延迟，因此进行频繁的细粒度网络调用几乎不会受到惩罚。这种设计错误只有在投入实时系统时才会变得明显。</p><p>高延迟的一个令人不安的影响是它不是恒定的。在糟糕的网络上，偶尔可以在几秒钟内计算出来。就其性质而言，无法保证网络服务单个数据包的顺序，甚至不能保证请求进程仍然存在。延迟会让事情变得更糟。此外，在应用程序通过发送多个同时请求进行补偿的情况下，可以通过对其的响应来加剧暂时高延迟。</p><h4 id="带宽是无限的"><a href="#带宽是无限的" class="headerlink" title="带宽是无限的"></a>带宽是无限的</h4><p>虽然大多数现代电缆可以处理几乎无限的带宽，但我们还没有找到如何构建足够快的互连设备（集线器，交换机，路由器等）以保证所有连接用户的高带宽。典型的企业内部网仍将具有限制带宽的区域。</p><p>随着公共网络带宽的增加，网络对使用视频和音频的服务的使用也一样快，而视频和音频曾经使用过广播技术。诸如社交媒体之类的新用途往往会吸收不断增加的带宽。此外，主要城市以外的许多地方都存在“最后一英里”的限制，并且丢包的可能性也在增加。</p><p>一般而言，我们需要谨慎地假设高带宽是一种普遍的体验。无论网络带宽如何令人印象深刻，它都无法接近共同托管进程可以通信的速度。</p><h4 id="网络是安全的"><a href="#网络是安全的" class="headerlink" title="网络是安全的"></a>网络是安全的</h4><p>令人遗憾的是仍然遇到具有基本安全漏洞的基于网络的系统。网络攻击逐年增加，并且在好奇心，恶意和犯罪方面已经超越了它们的原始根源，成为国际冲突和政治“行动”的一部分。网络攻击是IT生活的一部分：对开发人员来说很无聊，但却是必不可少的。部分问题是网络入侵检测往往是低优先级，因此我们并不总是意识到成功的网络攻击。</p><p>传统上，漏洞通常是配置不当的防火墙的结果。大多数防火墙都会经常被检测出来，因为你会立即发现你是否愚蠢地禁用它们。然而，这只是破坏网络和防火墙的一种方式中的一种，只是防御的一部分。Wi-Fi通常是一个弱点，使用自己的设备（BYOD）可以允许通过受损设备进行入侵，虚拟化和软件定义网络（SDN）也是如此。越来越多的DevOps对快速变化的基础设施的需求使得更难以保持必要的控制措施。企业网络中的僵尸网络是一个持续存在的问题，以及通过业务合作伙伴的入侵。</p><p>您需要假设网络是敌对的，并且安全性必须深入。这意味着将安全性构建到分布式应用程序及其主机的基本设计中。</p><p>通过纵深防御，分布式系统的任何部分都需要具有访问其他网络资源的安全方式。</p><p>安全带来了自身的复杂性。这将来自维护不同用户帐户，权限，证书，帐户等的管理开销。一个主要的云网络中断是由于权限在更新之前到期而导致的。</p><h4 id="拓扑不会改变"><a href="#拓扑不会改变" class="headerlink" title="拓扑不会改变"></a>拓扑不会改变</h4><p>网络拓扑不断变化，速度非常快。由于“网络敏捷性”的压力越来越大，这是不可避免的，以便与快速变化的业务需求保持同步。</p><p>无论您在何处部署应用程序，都必须假设大部分网络拓扑都可能无法控制。网络管理员将一次进行更改，原因可能不符合您的利益。他们将移动服务器并更改网络拓扑以获得性能或安全性，并在服务器和网络故障的情况下进行路由更改。</p><p>因此，依赖特定端点或路由的持久性是错误的。必须始终从任何分布式设计中抽象出网络的物理结构。</p><h4 id="只有一个管理员"><a href="#只有一个管理员" class="headerlink" title="只有一个管理员"></a>只有一个管理员</h4><p>除非系统完全存在于小型LAN中，否则将有不同的管理员与网络的各种组件相关联。他们将拥有不同程度的专业知识，不同的职责和优先事项。</p><p>如果出现导致服务失败的问题，这将很重要。您的服务级别协议将要求在一定时间内做出响应。第一阶段将是确定问题。除非有问题的网络部分的管理员是您的开发团队的一部分，否则这可能并不容易。不幸的是，这不太可能。在许多网络中，问题可能完全是另一个组织的责任。如果云组件是应用程序的重要组成部分，并且云中断，则无法确定优先级。你所能做的就是等待。</p><p>如果网络中有许多管理员，那么协调升级到网络或应用程序就更加困难，特别是当涉及到几个忙碌的人时。升级和部署必须协调完成，涉及的人数越多，这就变得越困难！</p><h4 id="运输成本为零"><a href="#运输成本为零" class="headerlink" title="运输成本为零"></a>运输成本为零</h4><p>运输成本是指通过网络传输数据的总体成本。我们可以参考时间和计算机资源，或者我们可以参考财务成本。</p><p>将数据从应用程序层传输到传输层需要CPU和其他资源。需要对结构化信息进行序列化（编组）或解析以将数据传输到线路上。这种性能影响可能大于带宽和延迟时间，因为XML的冗长和复杂性使得XML占用JSON的两倍。</p><p>金融运输成本不仅包括创建网络的硬件和安装成本，还包括监控和维护网络服务器，服务和基础设施的成本，以及如果发现带宽不足，或者您的服务器实际上无法处理足够的并发请求。我们还需要考虑租用线路和云服务的成本，这些成本由所使用的带宽支付</p><h4 id="网络是同质的"><a href="#网络是同质的" class="headerlink" title="网络是同质的"></a>网络是同质的</h4><p>今天的同质网络是罕见的，甚至比首次发现谬论时更为罕见！网络可能连接计算机和其他设备，每个设备具有不同的操作系统，不同的数据传输协议，并且所有设备都与来自各种供应商的网络组件相连。</p><p>但是，异构网络没有什么特别的错误，除非它涉及需要专门支持，设备或驱动程序的专有数据传输协议。从应用程序的角度来看，如果数据以开放标准格式（如CSV，XML或JSON）传输，并且使用行业标准的查询数据（如ODBC）的方法，则会有很大帮助。</p><p>如果所有组件都来自一个供应商，则可靠性更高，因为测试覆盖范围可能更大，但实际情况是组件的丰富组合。这意味着互操作性应该从任何分布式系统的设计开始就内置。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>虽然这个指导是在二十年前制定的，但我们今天仍在犯这些错误。这些错误显示为不安全的端点，由于大型对象的序列化导致的超时，丢失的事务，性能降低等等。避免这些错误意味着在每次设计和代码审查中需要考虑这些谬论。</p><p><strong>参考资料</strong><br><a href="https://dandelioncloud.cn/article/details/1526804530352373762/">分布式计算中的八大谬论-蒲公英云</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cloud-Native</title>
    <link href="/2022/09/30/Cloud-Native/"/>
    <url>/2022/09/30/Cloud-Native/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>参考资料</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker从入门到实践</title>
    <link href="/2022/09/04/Doker-from-Introduction-to-Practice/"/>
    <url>/2022/09/04/Doker-from-Introduction-to-Practice/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="Docker-基础命令"><a href="#Docker-基础命令" class="headerlink" title="Docker 基础命令"></a>Docker 基础命令</h3><p><strong>参考资料</strong><br><a href="https://">XXXX</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基本概念</title>
    <link href="/2022/09/03/Docker-basic-concepts/"/>
    <url>/2022/09/03/Docker-basic-concepts/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="Docker-概念"><a href="#Docker-概念" class="headerlink" title="Docker 概念"></a>Docker 概念</h3><p>  当我们请求 Docker 运行容器时，Docker 会在计算机上设置一个资源隔离的环境。然后将打包的应用程序和关联的文件复制到 Namespace 内的文件系统中，此时环境的配置就完成了。之后 Docker 会执行我们预先指定的命令，运行应用程序。</p><blockquote><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote><p><strong>核心概念</strong></p><ul><li><p><code>Build</code>, <code>Ship and Run</code>（搭建、运输、运行）；</p></li><li><p><code>Build once</code>, <code>Run anywhere</code>（一次搭建，处处运行）；</p></li><li><p>Docker 本身并不是容器，它是创建容器的工具，是应用容器引擎；</p></li><li><p>Docker 三大核心概念，分别是：镜像 Image，容器 Container、仓库 Repository；</p></li><li><p>Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。</p></li><li><p>由于 Namespace 和 Cgroups 功能仅在 Linux 上可用，因此容器无法在其他操作系统上运行。那么 Docker 如何在 macOS 或 Windows 上运行？Docker 实际上使用了一个技巧，并在非 Linux 操作系统上安装 Linux 虚拟机，然后在虚拟机内运行容器。</p></li><li><p>镜像是一个可执行包，其包含运行应用程序所需的代码、运行时、库、环境变量和配置文件，容器是镜像的运行时实例。</p></li></ul><p><strong>Docker 的主要用途，目前有三大类。</strong></p><p><strong>（1）提供一次性的环境。</strong> 比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong> 因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong> 通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><img src="https://img.darklorder.com/img/202111271935108.png"/><h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>dotCloud公司的Docker项目最初也是建立在<strong>LXC</strong>之上，以促进容器技术对开发人员和用户更加友好；</p><ul><li>不久之后，Docker便使用了自行研发的<strong>libcontainer</strong>取代了LXC</li><li>在Docker项目声名大噪之后，dotCloud公司也更名为Docker</li></ul><p>最终，<strong>Docker</strong>于<strong>2013</strong>年发布，解决了开发人员在端到端到运行容器时遇到的许多问题</p><ul><li>容器镜像格式</li><li>构建容器镜像：Dockerfile、docker build</li><li>容器镜像管理：docker image、docker rmi</li><li>容器实例管理：docker ps、docker rm、……</li><li>共享容器镜像：docker push&#x2F;pull</li><li>运行容器镜像的方式：docker run</li></ul><h3 id="Docker-系统组件"><a href="#Docker-系统组件" class="headerlink" title="Docker 系统组件"></a>Docker 系统组件</h3><img src="https://img.darklorder.com/img/202111271940584.png"/><p>Docker系统有三个关键组件  (C&#x2F;S架构)</p><ul><li>Docker CLI（<strong>客户端</strong>）</li><li>Docker Daemon（<strong>守护进程</strong> 管理本地组件）</li><li>Registry（<strong>注册表</strong> 存，检索）</li></ul><p>Docker Daemon</p><ul><li><p>REST API（衔接 Docker Daemon和Docker CLI）（http）</p></li><li><p>Objects （<strong>对象</strong>：Resource资源实例化）</p><p>Image（<strong>镜像</strong>）</p><p>Container （<strong>容器</strong>)</p><p>Volume（<strong>数据卷</strong>）</p><p>Network（<strong>网络</strong>）</p></li></ul><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>运行容器时，基于Mount名称空间建立的隔离文件系统中的内容来自镜像</p><ul><li>Docker镜像是一个特殊的文件系统，它必须包含运行应用程序所需的一切——所有依赖项、配置、脚本、二进制文件等</li><li>镜像还包含容器的其他配置，例如环境变量、要运行的默认命令、 和其他元数据</li><li>通常，镜像还要定义默认启动的应用</li></ul><p>Docker镜像由许多层（Layer）叠加而成</p><ul><li>依赖于特殊的存储驱动，例如aufs、devicemapper、overlay2等</li><li>尽管每种存储驱动程序实现的管理方式不尽相同，但它们都使用可堆叠的镜像层和写时复制（CoW）策略</li></ul><h3 id="Docker-容器-1"><a href="#Docker-容器-1" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>运行有Docker Daemon的主机负责管理本地容器实例的生命周期</p><ul><li><p>Docker Daemon通过其监听的Socket API接收Docker对象的管理请求，包括容器的生命周期中的各类管理操作</p></li><li><p>容器实例的创建要基于本地存储的Docker镜像进行</p></li><li><p>实例启动后，要在前台（foreground，不能转为守护进程模式）运行镜像中定义的默认应用，或用户指定的应用</p></li></ul><p>创建容器时，指定了本地不存在的镜像时，则需要由Docker Daemon自动至Registry上进行下载</p><ul><li>Docker Daemon 默认使用的Registry是<a href="https://registry.hub.docker.com/">DockerHub</a></li></ul><h3 id="从Docker说起"><a href="#从Docker说起" class="headerlink" title="从Docker说起"></a>从Docker说起</h3><p>OCI (Open Container Initiative)</p><ul><li><p>较早版本的Docker是一个单体系统，但其内部的各类功能间并不存在依赖关系，每类功能都可以在一个独立的工具中实现，而且每个工具都可以基于通用格式和同一个容器标准来协作</p></li><li><p>于是，2015年6月，Docker、Google、CoreOS和其他供应商创建了OCI标准，它包括</p><pre><code class="hljs">    image-spec：镜像格式规范    runtime-spec：运行时规范</code></pre></li><li><p>Docker将用于运行容器的代码（libcontainer）作为一个名为runC的项目分解出来，并捐赠给了OCI作为参考实现</p></li></ul><img src="https://img.darklorder.com/img/202111272119098.png" style="zoom:50%;" /><h3 id="Docker-程序组件"><a href="#Docker-程序组件" class="headerlink" title="Docker 程序组件"></a>Docker 程序组件</h3><p>为了兼容OCI规范，自1.11.0版本起始，Docker引擎由一个单一组件拆分成4个独立的项目</p><ul><li><p>Docker engine（Docker-daemon）</p></li><li><p>containerd：守护进程，高级别的container runtime</p><pre><code class="hljs">几乎囊括了容器运行时所需要的容器创建、启动、停止、中止、信号处理和删除，以及镜像管理（镜像和元信息等）等所有功能通过grpc向上层调用者公开其API，可被兼容的任何上层系统所调用，例如Docker Engine或kubernetes等容器编排系统但具体的容器管理还需要OCI兼容的runtime负责完成</code></pre></li><li><p>containerd-shim：支持多种不同的OCI runtime</p><pre><code class="hljs">containerd-shim 的意思是垫片，类似于拧螺丝时夹在螺丝和螺母之间的垫片。containerd-shim 的主要作用是将 containerd 和真正的容器进程解耦，使用 containerd-shim 作为容器进程的父进程，从而实现重启 containerd 不影响已经启动的容器进程。</code></pre></li><li><p>runc：低级别的container runtime</p></li></ul><img src="https://img.darklorder.com/img/202111272129706.png" style="zoom: 55%;" /><img src="https://img.darklorder.com/img/202111272128656.png" style="zoom: 39%;" /><h3 id="低级和高级容器运行时"><a href="#低级和高级容器运行时" class="headerlink" title="低级和高级容器运行时"></a>低级和高级容器运行时</h3><p>当人们想到容器运行时，可能会想到一系列示例；runc、lxc、lmctfy、Docker（容器）、rkt、cri-o。这些中的每一个都是为不同的情况而构建的，并实现了不同的功能。有些，如 containerd 和 cri-o，实际上使用 runc 来运行容器，在High-Level实现镜像管理和 API。与 runc 的Low-Level实现相比，可以将这些功能（包括镜像传输、镜像管理、镜像解包和 API）视为High-Level功能。考虑到这一点，您可以看到容器运行时空间相当复杂。每个运行时都涵盖了这个Low-Level到High-Level频谱的不同部分。这是一个非常主观的图表：</p><img src="https://img.darklorder.com/img/202308030314104.png"/><p>因此，从实际出发，通常只专注于正在运行的容器的runtime通常称为“Low-Level容器运行时”，支持更多高级功能（如镜像管理和gRPC &#x2F; Web API）的运行时通常称为“High-Level容器运行时”，“High-Level容器运行时”或通常仅称为“容器运行时”，我将它们称为“High-Level容器运行时”。值得注意的是，Low-Level容器运行时和High-Level容器运行时是解决不同问题的、从根本上不同的事物。</p><p>Low-Level容器运行时：容器是通过Linux nanespace和Cgroups实现的，Namespace能让你为每个容器提供虚拟化系统资源，像是文件系统和网络，Cgroups提供了限制每个容器所能使用的资源的如内存和CPU使用量的方法。在最低级别的运行时中，容器运行时负责为容器建立namespaces和cgroups,然后在其中运行命令，Low-Level容器运行时支持在容器中使用这些操作系统特性。目前来看低级容器运行时有：runc ：我们最熟悉也是被广泛使用的容器运行时，代表实现Docker。runv：runV 是一个基于虚拟机管理程序（OCI）的运行时。它通过虚拟化 guest kernel，将容器和主机隔离开来，使得其边界更加清晰，这种方式很容易就能帮助加强主机和容器的安全性。代表实现是kata和Firecracker。runsc：runsc &#x3D; runc + safety ，典型实现就是谷歌的gvisor，通过拦截应用程序的所有系统调用，提供安全隔离的轻量级容器运行时沙箱。截止目前，貌似并不没有生产环境使用案例。wasm : Wasm的沙箱机制带来的隔离性和安全性，都比Docker做的更好。但是wasm 容器处于草案阶段，距离生产环境尚有很长的一段路。</p><p>High-Level容器运行时：通常情况下，开发人员想要运行一个容器不仅仅需要Low-Level容器运行时提供的这些特性，同时也需要与镜像格式、镜像管理和共享镜像相关的API接口和特性，而这些特性一般由High-Level容器运行时提供。就日常使用来说，Low-Level容器运行时提供的这些特性可能满足不了日常所需，因为这个缘故，唯一会使用Low-Level容器运行时的人是那些实现High-Level容器运行时以及容器工具的开发人员。那些实现Low-Level容器运行时的开发者会说High-Level容器运行时比如containerd和cri-o不像真正的容器运行时，因为从他们的角度来看，他们将容器运行的实现外包给了runc。但是从用户的角度来看，它们只是提供容器功能的单个组件，可以被另一个的实现替换，因此从这个角度将其称为runtime仍然是有意义的。即使containerd和cri-o都使用runc，但是它们是截然不同的项目，支持的特性也是非常不同的。dockershim, containerd 和cri-o都是遵循CRI的容器运行时，我们称他们为高层级运行时（High-level Runtime）。<br>Kubernetes 只需支持 containerd 等high-level container runtime即可。由containerd 按照OCI 规范去对接不同的low-level container runtime，比如通用的runc，安全增强的gvisor，隔离性更好的runv。</p><h3 id="CRI和容器运行时"><a href="#CRI和容器运行时" class="headerlink" title="CRI和容器运行时"></a>CRI和容器运行时</h3><p>我们知道 Kubernetes 提供了一个 CRI 的容器运行时接口，那么这个 CRI 到底是什么呢？这个其实也和 Docker 的发展密切相关的。</p><p>在 Kubernetes 早期的时候，当时 Docker 实在是太火了，Kubernetes 当然会先选择支持 Docker，而且是通过硬编码的方式直接调用 Docker API，后面随着 Docker 的不断发展以及 Google 的主导，出现了更多容器运行时，Kubernetes 为了支持更多更精简的容器运行时，Google 就和红帽主导推出了 CRI 标准，用于将 Kubernetes 平台和特定的容器运行时（当然主要是为了干掉 Docker）解耦。</p><p>CRI（Container Runtime Interface 容器运行时接口）本质上就是 Kubernetes 定义的一组与容器运行时进行交互的接口，所以只要实现了这套接口的容器运行时都可以对接到 Kubernetes 平台上来。不过 Kubernetes 推出 CRI 这套标准的时候还没有现在的统治地位，所以有一些容器运行时可能不会自身就去实现 CRI 接口，于是就有了 shim（垫片）， 一个 shim 的职责就是作为适配器将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上，其中 dockershim 就是 Kubernetes 对接 Docker 到 CRI 接口上的一个垫片实现。</p><img src="https://img.darklorder.com/img/202308030329960.png"/><p>Kubelet 通过 gRPC 框架与容器运行时或 shim 进行通信，其中 kubelet 作为客户端，CRI shim（也可能是容器运行时本身）作为服务器。</p><p>CRI 定义的 API(<a href="https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto">https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto</a>) 主要包括两个 gRPC 服务，ImageService 和 RuntimeService，ImageService 服务主要是拉取镜像、查看和删除镜像等操作，RuntimeService 则是用来管理 Pod 和容器的生命周期，以及与容器交互的调用（exec&#x2F;attach&#x2F;port-forward）等操作，可以通过 kubelet 中的标志 –container-runtime-endpoint 和 –image-service-endpoint 来配置这两个服务的套接字。</p><img src="https://img.darklorder.com/img/202308030351171.png"/><p>不过这里同样也有一个例外，那就是 Docker，由于 Docker 当时的江湖地位很高，Kubernetes 是直接内置了 dockershim 在 kubelet 中的，所以如果你使用的是 Docker 这种容器运行时的话是不需要单独去安装配置适配器之类的，当然这个举动似乎也麻痹了 Docker 公司。</p><img src="https://img.darklorder.com/img/202308030351558.png"/><p>现在如果我们使用的是 Docker 的话，当我们在 Kubernetes 中创建一个 Pod 的时候，首先就是 kubelet 通过 CRI 接口调用 dockershim，请求创建一个容器，kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server，不过他们都是在 kubelet 内置的。</p><p>dockershim 收到请求后, 转化成 Docker Daemon 能识别的请求, 发到 Docker Daemon 上请求创建一个容器，请求到了 Docker Daemon 后续就是 Docker 创建容器的流程了，去调用 containerd，然后创建 containerd-shim 进程，通过该进程去调用 runc 去真正创建容器。</p><p>其实我们仔细观察也不难发现使用 Docker 的话其实是调用链比较长的，真正容器相关的操作其实 containerd 就完全足够了，Docker 太过于复杂笨重了，当然 Docker 深受欢迎的很大一个原因就是提供了很多对用户操作比较友好的功能，但是对于 Kubernetes 来说压根不需要这些功能，因为都是通过接口去操作容器的，所以自然也就可以将容器运行时切换到 containerd 来。</p><img src="https://img.darklorder.com/img/202308030329927.png"/><p>切换到 containerd 可以消除掉中间环节，操作体验也和以前一样，但是由于直接用容器运行时调度容器，所以它们对 Docker 来说是不可见的。 因此，你以前用来检查这些容器的 Docker 工具就不能使用了。</p><p>你不能再使用 docker ps 或 docker inspect 命令来获取容器信息。由于不能列出容器，因此也不能获取日志、停止容器，甚至不能通过 docker exec 在容器中执行命令。</p><p>当然我们仍然可以下载镜像，或者用 docker build 命令构建镜像，但用 Docker 构建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。为了在 Kubernetes 中使用，需要把镜像推送到镜像仓库中去。</p><p>从上图可以看出在 containerd 1.0 中，对 CRI 的适配是通过一个单独的 CRI-Containerd 进程来完成的，这是因为最开始 containerd 还会去适配其他的系统（比如 swarm），所以没有直接实现 CRI，所以这个对接工作就交给 CRI-Containerd 这个 shim 了。</p><p>然后到了 containerd 1.1 版本后就去掉了 CRI-Containerd 这个 shim，直接把适配逻辑作为插件的方式集成到了 containerd 主进程中，现在这样的调用就更加简洁了。</p><img src="https://img.darklorder.com/img/202308030329202.png"/><p>与此同时 Kubernetes 社区也做了一个专门用于 Kubernetes 的 CRI 运行时 <a href="https://cri-o.io/">CRI-O</a>，直接兼容 CRI 和 OCI 规范。</p><img src="https://img.darklorder.com/img/202308030329388.png"/><p>这个方案和 containerd 的方案显然比默认的 dockershim 简洁很多，不过由于大部分用户都比较习惯使用 Docker，所以大家还是更喜欢使用 dockershim 方案。</p><p>但是随着 CRI 方案的发展，以及其他容器运行时对 CRI 的支持越来越完善，Kubernetes 社区在 2020 年 7 月份就开始着手移除 dockershim 方案了：<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E9%99%A4%E8%AE%A1%E5%88%92%E6%98%AF%E5%9C%A8">https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim，现在的移除计划是在</a> 1.20 版本中将 kubelet 中内置的 dockershim 代码分离，将内置的 dockershim 标记为维护模式，当然这个时候仍然还可以使用 dockershim，目标是在 1.23&#x2F;1.24 版本发布没有 dockershim 的版本（代码还在，但是要默认支持开箱即用的 docker 需要自己构建 kubelet，会在某个宽限期过后从 kubelet 中删除内置的 dockershim 代码）。</p><p>那么这是否就意味这 Kubernetes 不再支持 Docker 了呢？当然不是的，这只是废弃了内置的 dockershim 功能而已，Docker 和其他容器运行时将一视同仁，不会单独对待内置支持，如果我们还想直接使用 Docker 这种容器运行时应该怎么办呢？可以将 dockershim 的功能单独提取出来独立维护一个 cri-dockerd 即可，就类似于 containerd 1.0 版本中提供的 CRI-Containerd，当然还有一种办法就是 Docker 官方社区将 CRI 接口内置到 Dockerd 中去实现。</p><p>但是我们也清楚 Dockerd 也是去直接调用的 Containerd，而 containerd 1.1 版本后就内置实现了 CRI，所以 Docker 也没必要再去单独实现 CRI 了，当 Kubernetes 不再内置支持开箱即用的 Docker 的以后，最好的方式当然也就是直接使用 Containerd 这种容器运行时，而且该容器运行时也已经经过了生产环境实践的，接下来我们就来学习下 Containerd 的使用。</p><p><strong>Containerd</strong></p><p>我们知道很早之前的 Docker Engine 中就有了 containerd，只不过现在是将 containerd 从 Docker Engine 里分离出来，作为一个独立的开源项目，目标是提供一个更加开放、稳定的容器运行基础设施。分离出来的 containerd 将具有更多的功能，涵盖整个容器运行时管理的所有需求，提供更强大的支持。</p><p>containerd 是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性，containerd 可以负责干下面这些事情：</p><ul><li>管理容器的生命周期（从创建容器到销毁容器）</li><li>拉取&#x2F;推送容器镜像</li><li>存储管理（管理镜像及容器数据的存储）</li><li>调用 runc 运行容器（与 runc 等容器运行时交互）</li><li>管理容器网络接口及网络</li></ul><p><strong>架构</strong></p><p>containerd 可用作 Linux 和 Windows 的守护程序，它管理其主机系统完整的容器生命周期，从镜像传输和存储到容器执行和监测，再到底层存储到网络附件等等。</p><img src="https://img.darklorder.com/img/202308030352947.png"/>上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C/S 架构，服务端通过 unix domain socket 暴露低层的 gRPC API 接口出去，客户端通过这些 API 管理节点上的容器，每个 containerd 只负责一台机器，Pull 镜像，对容器的操作（启动、停止等），网络，存储都是由 containerd 完成。具体运行容器由 runc 负责，实际上只要是符合 OCI 规范的容器都可以支持。<p>为了解耦，containerd 将系统划分成了不同的组件，每个组件都由一个或多个模块协作完成（Core 部分），每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的，例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 Service Plugin、Metadata Plugin、GC Plugin、Runtime Plugin 等，其中 Service Plugin 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 Metadata Plugin 依赖 Containers Plugin、Content Plugin 等。比如:</p><ul><li>Content Plugin: 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。</li><li>Snapshot Plugin: 用来管理容器镜像的文件系统快照，镜像中的每一层都会被解压成文件系统快照，类似于 Docker 中的 graphdriver。</li></ul><p>总体来看 containerd 可以分为三个大块：Storage、Metadata 和 Runtime。</p><img src="https://img.darklorder.com/img/202308030352693.png"/><p><strong>参考资料</strong><br>Kubernetes进阶实战<br><a href="https://cloud.tencent.com/developer/article/1895805">Docker、Containerd、RunC分别是什么-腾讯云开发者社区-运维开发故事</a><br><a href="https://cloud.tencent.com/developer/article/1895808">真正运行容器的工具：深入了解 runc 和 OCI 规范-腾讯云开发者社区-运维开发故事</a><br><a href="https://www.qikqiak.com/post/containerd-usage/">一文搞懂容器运行时 Containerd-阳明的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器简介</title>
    <link href="/2022/09/02/Introduction-to-Docker-Containers/"/>
    <url>/2022/09/02/Introduction-to-Docker-Containers/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h2><p><strong>Docker</strong> 最初是 <code>dotCloud</code> 公司创始人 <a href="https://github.com/shykes">Solomon Hykes</a> 在法国期间发起的一个公司内部项目，它是基于 <code>dotCloud</code> 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby">GitHub</a> 上进行维护。<code>Docker</code> 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://opencontainers.org/">开放容器联盟（OCI）</a>。</p><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby">GitHub 项目</a> 已经超过 5 万 7 千个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，<a href="https://www.docker.com/blog/dotcloud-is-becoming-docker-inc/">dotCloud 公司决定改名为 Docker</a>。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p><img src="https://img.darklorder.com/img/202308011722747.png"/><p>Docker 架构</p><blockquote><p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec">OCI容器运行时规范</a> 创建和运行容器。</p></blockquote><blockquote><p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p></blockquote><p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><img src="https://img.darklorder.com/img/202308011725697.png"/><p>传统虚拟化</p><img src="https://img.darklorder.com/img/202308011725945.png"/><p>Docker</p><h2 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h2><p>作为一种新兴的虚拟化方式，<code>Docker</code> 跟传统的虚拟化方式相比具有众多的优势。</p><p><strong>更高效的利用系统资源</strong></p><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><p><strong>更快速的启动时间</strong></p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong>一致的运行环境</strong></p><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><p><strong>持续交付和部署</strong></p><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery&#x2F;Deployment)</a> 系统进行自动部署。</p><p>而且使用 <a href="https://yeasy.gitbook.io/docker_practice/image/build"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><p><strong>更轻松的迁移</strong></p><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p><strong>更轻松的维护和扩展</strong></p><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><p><strong>对比传统虚拟机总结</strong></p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。</p><p>开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。Docker是容器的一种，还有其他容器，比如 CoreOS 的 rkt。</p><p>容器有效的将单个操作系统的资源划分到孤立的组中，以便更好的在孤立的组之间平衡有冲突的资源使用需求。</p><p>其实容器本身并不是一个特别新的技术，早在2000年就已经有了，当时是用来在chroot环境(隔离mount namespac的工具)中做进程隔离（使用namespac和cgroups）</p><p>容器的本质，一句话解释，就是一组受到资源限制，彼此间相互隔离的进程。实现起来也并不复杂，隔离所用到的技术都是由linux内核本身提供的（所以说目前绝大部分的容器都是必须要跑在linux里面的）。其中<code>namespace</code>用来做访问隔离（每个容器进程都有自己独立的进程空间，看不到其他进程），<code>cgroups</code>用来做资源限制（cpu、内存、存储、网络的使用限制）。</p><p>总的来说容器就是一种基于操作系统能力的隔离技术，这和虚拟化技术不可同日而语。</p><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>分层构建（Layered Construction）、联合挂载（Union Mounting）和写时复制（Copy-on-Write）是三种 Linux 文件系统的特性，它们在容器技术中广泛应用。</p><ul><li><p>分层构建：分层构建是指将一个文件系统划分为多个层次，每个层次只包含文件系统的一部分。这种分层构建的优点是可以重用已有的文件系统层次，提高了构建效率。在容器中，分层构建使得容器只需要记录自己的变更，从而避免了重复存储文件系统的问题。</p></li><li><p>联合挂载：联合挂载是指将多个文件系统联合成一个虚拟文件系统。在联合挂载的过程中，只有最上层的文件系统是可写的，其余文件系统只读。在容器中，联合挂载使得容器可以使用主机上的一些文件系统，从而避免了容器中需要存储相同的文件系统的问题。</p></li><li><p>写时复制：写时复制是指当一个进程试图修改一个文件时，会先将这个文件复制到一个新的位置，然后在新的位置上进行修改，从而避免了原始文件的修改。在容器中，写时复制可以使得容器只需要记录自己的变更，从而避免了对主机上原始文件的修改。</p></li></ul><p>这三种特性在容器技术中被广泛应用，使得容器可以更高效地运行，同时也降低了容器与主机之间的耦合度。</p><h2 id="深入剖析"><a href="#深入剖析" class="headerlink" title="深入剖析"></a>深入剖析</h2><h3 id="初出茅庐"><a href="#初出茅庐" class="headerlink" title="初出茅庐"></a>初出茅庐</h3><p><strong>PaaS项目被大家接纳的一个主要原因</strong></p><ul><li>它提供了一种名叫“应用托管”的能力。 </li><li>租一批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，用脚本或者手工的方式在这些机器上部署应用。</li></ul><blockquote><p>缺点：部署过程难免会碰到云端虚拟机和本地环境不一致的问题。</p></blockquote><p><strong>PaaS开源项目最佳方案</strong></p><ul><li>Cloud Foundry 项目</li><li>核心组件 一套应用的打包和分发机制</li></ul><blockquote><p>为每种主流编程语音都定义了一种打包格式,把应用的可执行文件和启动脚本打进一个压缩包内,上传到云端的存储中<br>通过调度器选择一个可以运行这个应用的虚拟机,然后通知这个机器上的Agent把应用压缩包下载下来启动。</p></blockquote><p><strong>PaaS项目最核心的能力</strong></p><ul><li>运行应用的隔离环境</li><li>或者说“沙盒”</li><li>就是所谓的“容器”</li></ul><blockquote><p>由于需要在一个虚拟机上启动很多个来自不同用户的应用,会调用操作系统的Cgroups和Namespace机制为每一个应用单独创建一个称作”沙盒”的隔离环境,然后在”沙盒”中启动这些应用程序。</p></blockquote><h3 id="崭露头角"><a href="#崭露头角" class="headerlink" title="崭露头角"></a>崭露头角</h3><p><strong>Dcoker项目能取得高关注度的原因</strong></p><ul><li>解决了应用打包和发布这一困扰运维人员多年的技术难题</li><li>第一次把一个纯后端技术的概念,通过非常友好的设计,交到了最广大的开发者群体手里</li></ul><p><strong>Docker公司为什么一定要发布Swarm项目</strong></p><ul><li>Docker项目从发布之初就全面发力,从技术,社区,商业,市场全方位争取到的开发者群体,实际上是为此后吸引整个生态到自家”PaaS”上的一个铺垫.</li><li>只不过这时,PaaS的定义已经全然不是Docker公司描述的那个样子,而是变成了一套以Docker容器为技术核心,以Docker容器为技术核心,以Docker镜像为打包标准的,全新的容器化思路</li><li>这正是Docker项目从一开始悉心运作容器化理念和经营整个Docker生态的主要目的</li><li>而Swarm项目正式接下来承接Docker公司所有这些努力的关键所在</li></ul><p><strong>Docker在短时间内迅速崛起的三个重要原因</strong></p><ul><li>Docker镜像通过技术手段解决了PaaS的根本性问题</li><li>Docker容器同开发者之间有着与生俱来的关系</li><li>PaaS概念已经深入人心的完美时机</li></ul><h3 id="群雄并起"><a href="#群雄并起" class="headerlink" title="群雄并起"></a>群雄并起</h3><p><strong>Docker和CoreOS停止合作</strong></p><ul><li>根本原因是Docker公司对Docker项目定位的不满足,想让Docker项目提供更多的平台层能力,即向PaaS项目进化</li><li>这显然与CoreOS公司的核心产品和战略发生了冲突</li></ul><p><strong>Swarm项目的亮点</strong></p><ul><li>完全使用Docker项目原本的容器管理API来完成集群管理的</li></ul><p><strong>什么是编排</strong></p><ul><li>主要是指用户如何通过某些或者配置来完成一组虚拟机以及关联资源的定义,配置,创建,删除等工作,然后由平台按照这些指定的逻辑来完成的过程</li></ul><p><strong>Fig项目(后来的compose)</strong></p><ul><li>Fig在开发者面前第一次提出了”容器编排的概念”</li><li>容器和容器之间的关联关系,会由Fig交给Docker的Link功能通过写入Host文件的方式进行配置</li><li>Fig被收购之后改名为Compose,他成为Docker公司目前为止第二大受欢迎的项目</li></ul><p><strong>Docker公司收购的项目</strong></p><ul><li>Fig –&gt; 编排</li><li>SockerPlane –&gt; 容器网络</li><li>Flocker –&gt; 容器存储</li><li>Tutum –&gt; Docker集群图形化管理界面和提供云服务</li></ul><p><strong>Mesos</strong></p><ul><li>Messos作为Berkeley主导的大数据套件之一,是大数据火热时最受欢迎的资源管理项目</li><li>发布Marathon实现了应用托管和负载均衡的PaaS功能</li><li>Messos拥有超大规模集群的管理经验</li></ul><h3 id="尘埃落定"><a href="#尘埃落定" class="headerlink" title="尘埃落定"></a>尘埃落定</h3><p><strong>容器编排领域的两个压力</strong></p><ul><li>Swarm擅长的是跟Docker生态的无缝集成</li><li>Messos擅长的则是大规模集群的调度与管理</li><li>kubernetes借用Borg和Omega系统的内部特性</li></ul><p><strong>基于kubernetes的api和扩展接口的二次创新</strong></p><ul><li>目前热度极高的微服务治理项目Istio</li><li>被广泛采用的有状态应用部署框架Operator</li><li>还有像Rook这样的开源创业项目,它通过kubernetes的可扩展接口,把Ceph这样的重量级产品封装成了简单易用的容器存储插件</li></ul><p><strong>编排落下帷幕</strong></p><ul><li>2017年10月,Docker公司出人意料的宣布,将在自己的主打产品Docker企业中内置kubernetes项目</li><li>这标志着持续了进两年之久的”编排之争”至此落下帷幕</li></ul><p><strong>kubernetes成功的必然性</strong></p><ul><li>Docker公司最后是将开源项目和商业产品紧密绑定,打造一个极端封闭的技术生态</li><li>这其实违背了Docker项目与开发者保持密切关系的初衷</li><li>而kubernetes社区正是以一种更加温和的方式,承接了Docker项目的未尽事业</li><li>即:以开发者为核心,构建一个相对民主和开放的容器生态</li></ul><h3 id="从进程说开去"><a href="#从进程说开去" class="headerlink" title="从进程说开去"></a>从进程说开去</h3><p><strong>容器技术的几个事实</strong></p><ul><li>容器技术的兴起起源于PaaS技术的普及</li><li>Docker公司发布的Docker项目具有里程碑式的意义</li><li>Docker项目通过”容器镜像”,解决了应用打包这个根本性难题</li></ul><p><strong>什么是容器</strong></p><ul><li>容器就是一种沙盒技术,把你的应用”装起来”,让其能够方便的搬来搬去</li></ul><p><strong>进程</strong></p><ul><li>一旦程序被执行起来,它就从磁盘上的二进制文件,变成了计算机内存中的数据,寄存器里的值,</li><li>堆栈中的指令,被打开的文件,以及各种设备的状态信息的一个集合.</li><li>像这样一个程序运行起来后的计算机执行环境的总和,就是进程</li></ul><p><strong>进程的动态表现</strong></p><ul><li>进程的静态表现就是程序,平时都安安静静的待在磁盘上</li><li>一旦运行起来,它就变成了计算机里的数据和状态的总和,这就是它的动态表现</li></ul><p><strong>容器的核心功能</strong></p><ul><li>通过约束和修改进程的动态表现,为期创造出一个”边界”</li></ul><p><strong>容器的特性</strong></p><ul><li>容器内的第一个进程的PID是1,其实是对被隔离的应用的进程空间做了手脚,</li><li>使得这些进程只能看到重新计算过的进程编号,比如PID&#x3D;1,可实际上,</li><li>他们在宿主机的操作系统里,就是一个普通的进程</li></ul><p><strong>容器名称空间</strong>Namespace</p><ul><li>Mount 挂载文件系统</li><li>UTS 主机名和域名</li><li>IPC 进程间通信</li><li>Network 网络</li><li>User 用户</li><li>PID 进程ID</li></ul><p><strong>Docker并不是”轻量级”虚拟化技术</strong></p><ul><li>跟真实存在的虚拟机不同,在使用Docker时,并没有一个真正的”Docker容器”运行在宿主机里面</li><li>Docker项目帮助用户启动的,还是原来的应用进程,只不过在创建这些进程的时候,</li><li>Docker为他们加上了各种各样的Namespace参数,</li><li>这时这些进程就会觉得自己是各PID Namespace里的第一号进程</li><li>只能看到各自Mount Namespace里挂载的目录和文件,只能访问到各自Network Namespace里的网路设备</li><li>仿佛在一个个”容器”里面,与世隔绝</li></ul><h3 id="隔离与限制"><a href="#隔离与限制" class="headerlink" title="隔离与限制"></a>隔离与限制</h3><p><strong>传统虚拟机和Docker架构图</strong></p><img src="https://img.darklorder.com/img/202308011842921.png"/><ul><li>对比图中Docker和应用同级别并且在靠边的位置</li><li>用户在容器里的应用进程,跟宿主机上的其他进程一样,都由宿主机操作系统统一管理</li><li>只不过这些被隔离的进程拥有额外设置过的Namespace参数</li><li>Docker在这里扮演的更多是旁路是的辅助和管理工作</li></ul><p><strong>KVM虚拟机和容器的性能</strong></p><ul><li>一个运行CentOS的KVM虚拟机在不做优化的情况下,虚拟机自己就要占用100-200MB内存</li><li>用户应用会被宿主机操作系统拦截和处理,损耗性能</li><li>容器化的应用依然是宿主机的一个进程,不存在虚拟化带来的性能损耗</li><li>使用Namespace作为隔离手段的容器并不需要单独的Guest OS,容器额外资源占用几乎不存在</li><li>“敏捷”和”高性能”是容器对比虚拟机的最大优势</li></ul><p><strong>容器的隔离不彻底</strong></p><ul><li>宿主机上的多个容器之间使用的还是同一个宿主机的操作系统内核</li><li>很多资源和对象不能被Namespace化,比如时间</li></ul><p><strong>Cgroups资源限制</strong></p><ul><li>blkio 为块设备设定I&#x2F;O限制,一般用于磁盘等设置</li><li>cpuset 为进程分配单独的CPU核和对应的内存节点</li><li>memory 为进程设定内存使用的限制</li></ul><p><strong>容器是单进程模型</strong></p><ul><li>容器的本质就是一个进程,用户的应用进程实际上就是容器里的PID&#x3D;1的进程</li><li>也是其他后续的所有进程的父进程</li><li>在一个容器中,只能实现找到一个公共的PID&#x3D;1的程序来充当两个不同应用的父进程</li><li>这就是为什么很多人会使用systemd或者supervisord这样的软件来替代应用本身作为容器的启动进程</li></ul><p><strong>容器编排与容器生命周期</strong></p><ul><li>容器本身的设计是希望容器和应用能够同生命周期</li><li>否则一旦出现容器是正常运行的,但是应用早就挂了的情况</li><li>在容器编排处理起来就很麻烦了</li></ul><p><strong>Cgroups不完善的地方&#x2F;proc文件系统</strong></p><ul><li>Linux下的&#x2F;proc目录存储是记录当前内核运行状态的一系列特殊文件</li><li>用户能通过这些文件,查看系统以及当前正在运行的进程的信息,</li><li>比如CPU使用,内存占用等,这些信息是top命令的主要信息来源</li><li>如果你在容器中执行top指令,就会发现它显示的是宿主机的CPU和内存数据,并不是当前容器的数据</li><li>因为&#x2F;proc文件系统并不知道用户通过Cgroups给这个容器做了什么资源限制</li><li>即&#x2F;proc文件系统并不了解Cgroup限制的存在</li><li>生产环境中必须修正这个问题,否则应用程序在容器里读取到的CPU核数,可用内存等信息都是宿主机上的数据</li><li>会给应用的运行带来非常大的风险和困惑,这是容器化相较于虚拟机不尽人意的地方</li></ul><h3 id="深入理解容器镜像"><a href="#深入理解容器镜像" class="headerlink" title="深入理解容器镜像"></a>深入理解容器镜像</h3><p><strong>Docker项目未待创建的用户进程做了以下事情</strong></p><ol><li>启用Linux Namespace配置</li><li>设置指定的Cgroups参数</li><li>切换进程的跟目录(Change Root)</li></ol><p><strong>注意</strong></p><ul><li>rootfs只是一个操作系统所包含的文件,配置和目录,并不包括操作系统内核</li><li>在Linux操作系统中,这两部分是分开存放的</li><li>操作系统只有在开机启动时才会加载执行指定版本的内核镜像</li><li>rootfs只包括了操作系统的”躯壳”,并没有包括操作系统的”灵魂”</li></ul><p><strong>容器操作系统的”灵魂”</strong></p><ul><li>同一台机器上的所有容器,都共享宿主机操作系统的内核</li><li>容器内的与内核相关的内核参数,内核模块,和内核的直接交互都是”全局变量”,牵一发而动全身</li></ul><p><strong>容器的一致性</strong></p><ul><li>无论在本地,云端,还是在一台任何地方的的机器上</li><li>用户只需要解压打包好的容器镜像,那么这个应用运行所需要的完整的执行环境就被重现出来了</li><li>深入到操作系统级别的运行环境一致性,打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟</li></ul><p><strong>联合文件系统(UnionFS)</strong></p><img src="https://img.darklorder.com/img/202308011850015.png"/><p>第一层,只读层<br>他是这个容器的rootf最下面的五层,对应的正是ubuntu:latest镜像的五层<br>可以看到它们的挂载方式都是只读的(ro+wh即readonly+whiteout)</p><p>第二层,可读写层<br>它是容器rootfs最上面的一层,挂载方式为rw,即read write<br>在没有写入文件之前,这个目录是空的.而且一旦在容器里面做了写操作,<br>你的修改就会以增量的方式出现在这个层中<br>删除文件时,AuFS会在可读写层创建一个whiteout文件,把只读层里的文件遮挡起来</p><p>第三部分,init层<br>它是一个以”-init”结尾的层,夹在只读层和读写层之间<br>init层是Docker项目单独生成的一个内部层,专门用来存放&#x2F;etc&#x2F;hosts, &#x2F;etc&#x2F;resolv.conf等信息<br>需要这样一层的原因是,这些文件本来属于只读层的Ubuntu镜像的一部分<br>但是用户往往需要在容器启动时就写入一些指定的值比如hostname,所以就需要在读写层对他们进行修改<br>可以,这些修改往往只对当前的容器有效,我们并不希望执行docker commit时,<br>把这些信息连同可读写层一起提交掉,所以docker的做法是,在修改了这些文件之后,<br>以一个单独的层挂载了出来,用户执行docker commit只会提交可读写层,所以是不包含这些内容的</p><p><strong>分层镜像的设计好处</strong></p><ul><li>以Docker镜像为核心,将不同技术人员紧密的联系在了一起</li><li>容器镜像是增量式的,每次镜像拉取,推送的内容,比完整操作系统要小得多</li><li>镜像发布之后,在全世界的任何地方下载这个镜像,可以完全复制镜像制作者当时的环境</li></ul><h3 id="重新认识Docker容器"><a href="#重新认识Docker容器" class="headerlink" title="重新认识Docker容器"></a>重新认识Docker容器</h3><p><strong>Docker exec的原理</strong></p><ul><li>一个进程的Namespace信息在宿主机上是确确实实存在的,并且是以一个文件的方式存在</li><li>一个进程,可以选择加入到某个进程已有的Namespace中,从而达到”进入这个进程所在容器的目的”</li></ul><p><strong>Docker commit原理</strong></p><ul><li>实际上就是在容器运行起来后,把最上层的”可读写层”,加上原先容器镜像的只读层</li><li>打包成了一个新的镜像.并且只读层在宿主机是共享的,不会占用额外的空间</li><li>由于使用了联合文件系统,你在容器里镜像rootfs所做的任何修改,</li><li>都会被操作系统复制到这个读写层,然后再修改,这就是所谓的Copy-on-Write</li><li>Init层的存在,就是为了避免执行docker commit时,</li><li>把Docker自己对&#x2F;etc&#x2F;hosts等文件的修改,也一起提交掉</li></ul><p><strong>容器的volume</strong></p><p>docker run -v &#x2F;test …</p><ul><li>Docker默认会在宿主机上创建一个临时目录&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;[VOLUME_ID]&#x2F;_data</li><li>然后把它挂载到容器的&#x2F;test目录上</li></ul><p>docker run -v &#x2F;home:&#x2F;test …</p><ul><li>Docker直接把宿主机的&#x2F;home目录挂载到容器的&#x2F;test目录上</li></ul><p>Docker是如何将宿主机目录挂载到容器的</p><ul><li>只需要在容器的rootfs准备好之后,在执行chroot之前,把Volume指定的宿主机目录(比如&#x2F;home目录)</li><li>挂载到指定的容器目录(比如&#x2F;test目录)在宿主机上对应的目录(即&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层ID&#x2F;test])</li><li>这个Volume的挂载工作就完成了</li><li>由于执行这个挂载操作时,容器进程已经创建了,意味着此时Mount Namespace已经开启</li><li>所以挂载事件只在这个容器中可见,宿主机上看不到这个挂载点,保证了容器的隔离性不会被Volume打破</li></ul><p>注意:</p><ul><li>这里的”容器进程”,是Docker创建的一个容器初始化进程(dockerinit),而不是应用进程(ENTRYPOINT+CMD)</li><li>dockerinit会负责完成根目录的准备,挂载设备和目录,配置hostname等一系列需要在容器内进行的初始化操作</li><li>最后它通过execv()系统调用,让应用进程取代自己,成为容器里的PID&#x3D;1的进程</li></ul><p><strong>挂载机制</strong></p><ul><li>Docker中的挂载,使用的是Linux的绑定挂载(Bind Mount)机制</li><li>主要作用是运行你将一个目录或者文件,而不是整个设备,挂载到一个指定的目录上</li><li>原挂载点的内容则会被隐藏起来且不受影响</li><li>Bind Mount实际上是一个inode替换的过程</li></ul><p><strong>Bind Mount的本质</strong></p><img src="https://img.darklorder.com/img/202308011904273.png"/><ul><li>mount –bind &#x2F;home &#x2F;test 会将&#x2F;home 挂载到&#x2F;test上</li><li>实际上相当于&#x2F;test的dentry,重定向到了&#x2F;home的inode</li><li>当我们修改&#x2F;test目录时,实际上就是修改的是&#x2F;home目录的inode</li><li>这就是为何一旦执行umount命令,&#x2F;test目录原先的内容就会恢复</li></ul><p><strong>&#x2F;test目录挂载在容器的可读写层,会不会被docker commit提交掉呢</strong></p><ul><li>docker commit是发生在宿主机空间的</li><li>Mount Namespace的隔离作用,宿主机并不知道这个绑定挂载的存在</li><li>在宿主机看来,容器中可读写层的&#x2F;test目录(&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层ID]&#x2F;test)始终是空的</li><li>由于Docker一开始还是要创建这个&#x2F;test目录作为挂载点,执行完docker commit之后</li><li>新镜像中,会多出来一个空的&#x2F;test目录,因为新建目录操作不是挂载操作,Mount Namespace不能起到”障眼法”的作用</li></ul><h3 id="谈谈Kubernetes的本质"><a href="#谈谈Kubernetes的本质" class="headerlink" title="谈谈Kubernetes的本质"></a>谈谈Kubernetes的本质</h3><p><strong>一个正在运行的Linux容器</strong></p><ol><li>一组联合挂载在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt上的rootfs,也就是”容器镜像”,容器的静态视图</li><li>一个由Namespace+Cgroup构成的隔离环境,这一部分称为”容器运行时”,容器的动态视图</li></ol><p>真正承载着容器信息进行传递的,是容器镜像,而不是容器运行时</p><p><strong>kubernetes的由来</strong></p><ul><li>核心特性都基于Borg&#x2F;Omega系统的设计与经验</li><li>在开源社区落地过程中,修复了很多当年遗留在Borg体系中的缺陷和问题</li></ul><p><strong>架构图</strong></p><img src="https://img.darklorder.com/img/202308011905905.png"/><p>和原型项目Borg非常类似,都由Master和Node两种节点组成,分别对应着控制节点和计算节点</p><p>控制节点,Master节点</p><ul><li>负责API服务的kube-apiserver</li><li>负责调度的kube-scheduler</li><li>负责容器编排的kube-controller-manager</li><li>整个集群的持久化数据,由kube-apiserver处理后保存在Etcd中</li></ul><p>计算节点,Node节点</p><ul><li>kubelet主要负责和容器运行时打交道</li><li>而这个交互依赖的是CRI(Container Runtime Interface)的远程调用接口</li><li>这个接口定义了容器运行时的各项核心操作,比如启动一个容器所需要的所有参数</li><li>不需要关心是什么容器运行时,用到的什么基础</li><li>只要这个容器能够运行标准的容器镜像,他就可以通过实现CRI接入到kubernetes项目当中</li></ul><p><strong>容器运行时</strong></p><ul><li>例如Docker项目,一般通过OCI这个容器运行时规范通底层的Linux操作系统进行交互</li><li>即:把CRI请求翻译成对Linux操作系统的调用(操作Linux Namespace和Cgroups等)</li></ul><p><strong>kubelet</strong></p><ul><li>kubelet还通过gRPC协议同一个叫做Device Plugin的插件进行交互</li><li>这个插件是Kubernetes项目用来管理GPU等宿主机物理机设备的主要组件</li><li>也是基于kubernetes项目进行机器学习,高性能作业支持等工作必须关注的功能</li><li>调用网络插件和存储插件为容器配置网络和持久化存储</li><li>这两个插件和kubelet交互的接口,分别是CNI(Container Networking Interface)和CSI(Container Storage Interface)</li></ul><p><strong>Borg项目对kubernetes的指导作用</strong></p><ul><li>体现在Master节点之上</li><li>虽然在Master实现的细节上和Borg有所不同</li><li>但是出发点却高度一致:即如何编排,管理,调用用户提交的作业</li><li>将Docker仅仅作为最底层的一个容器运行时实现</li><li>着重解决的问题:运行在大规模集群中的各种任务之间,实际上存在着各种各样的关系</li><li>处理这些关系,才是作业编排和管理系统最困难的地方</li></ul><p><strong>kubernetes项目最主要的设计思想</strong></p><p>从宏观的角度,以统一的方式来定义任务之间的各种关系,并且为将来支持更多种类的关系留有余地</p><p><strong>紧密关系的应用</strong></p><ul><li>这些应用之间需要非常频繁的交互和访问,或者直接通过本地文件系统进行信息交换</li><li>在常规环境下,这些应用往往会直接部署在同一台机器上,通过localhost通信,通过本地磁盘交换文件</li><li>但在kubernetes项目中,这些容器会被划分为一个Pod</li><li>Pod里的容器共享同一个Network Namespace ,同一数据卷,从而达到高效交换信息的目的</li></ul><p><strong>类似Web应用和数据库之间的访问关系</strong></p><ul><li>kubernetes提供了一种叫做Service的服务</li><li>给Pod绑定一个Service服务,而Service服务声明的IP地址等信息是终生不变的</li><li>这个Service服务的主要作用,就是作为Pod的代理入口</li><li>从而代替Pod对外暴露一个固定的网络地址</li></ul><p><strong>Secret对象</strong></p><ul><li>其实是保存在Etcd里的键值对数据</li><li>可以把Credential信息以Secret的方式存在Etcd里</li><li>kubernetes就会在你指定的Pod启动时,自动把Secret里的数据以Volume的方式挂载刀片容器里</li></ul><p><strong>kubernetes的推崇做法</strong></p><ul><li>通过一个”编排对象”,比如PodmJob,CronJob等,来描述你试图管理的应用</li><li>再为它定义一些”服务对象”,比如Service,Secret, HPA等.这些对象会负责具体的平台级功能</li></ul><p><strong>参考资料</strong><br><a href="https://yeasy.gitbook.io/docker_practice/">Docker-从入门到实践</a><br><a href="https://time.geekbang.org/column/intro/116">极客时间-深入剖析Kubernetes</a><br><a href="https://kkwen.cn/index.php/category/kubernetes/">kwen94-博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装部署</title>
    <link href="/2022/09/01/Install-Docker/"/>
    <url>/2022/09/01/Install-Docker/</url>
    
    <content type="html"><![CDATA[<p>关于 Docker安装部署</p><span id="more"></span><h2 id="Docker-安装部署"><a href="#Docker-安装部署" class="headerlink" title="Docker 安装部署"></a>Docker 安装部署</h2><p>目前，Docker支持在多个平台上进行安装部署，包括Linux、Windows和Mac。每个平台会有对应的系统版本要求，具体可以参见官方说明。</p><img src="https://img.darklorder.com/img/202305121626702.png"/><p>在实际应用中，Docker使用最多的场景是在Linux系统上。本文将基于市面上最常用的Centos和Ubuntu系统，对Docker的安装部署进行介绍。</p><h5 id="初始化环境-CentOS"><a href="#初始化环境-CentOS" class="headerlink" title="初始化环境 CentOS"></a>初始化环境 CentOS</h5><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker</p><p>通过 uname -r 命令查看你当前的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>使用root 权限登录 CentOS。确保 yum 包更新到最新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update<br></code></pre></td></tr></table></figure><p>卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker  docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure><p>安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p>设置yum源</p><p>官方源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>阿里云源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>清华大学源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h5 id="安装Docker-CentOS"><a href="#安装Docker-CentOS" class="headerlink" title="安装Docker CentOS"></a>安装Docker CentOS</h5><p>安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce<br></code></pre></td></tr></table></figure><p>也可以查看所有仓库中所有docker版本，并选择特定版本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br>sudo yum install docker-ce-版本号.ce<br></code></pre></td></tr></table></figure><p>启动并加入开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start docker<br>sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure><h5 id="初始化环境-Ubuntu"><a href="#初始化环境-Ubuntu" class="headerlink" title="初始化环境 Ubuntu"></a>初始化环境 Ubuntu</h5><p>Docker CE 可以安装在 64 位的 x86平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。</p><p>卸载旧版本</p><p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker \<br>               docker-engine \<br>               docker.io<br></code></pre></td></tr></table></figure><h5 id="安装Docker-Ubuntu"><a href="#安装Docker-Ubuntu" class="headerlink" title="安装Docker Ubuntu"></a>安装Docker Ubuntu</h5><p>使用脚本自动安装</p><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套安装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror Aliyun<br></code></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中</p><p>启动Docker CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></figure><p>卸载Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 先执行命令</span><br>apt-get autoremove docker-ce<br></code></pre></td></tr></table></figure><p>删除 &#x2F;etc&#x2F;apt&#x2F;sources.list.d 目录下的 docker.list 文件</p><h6 id="安装Docker-Ubuntu-1"><a href="#安装Docker-Ubuntu-1" class="headerlink" title="安装Docker Ubuntu"></a>安装Docker Ubuntu</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 修改源地址</span><br>root@ubuntu2004:~<span class="hljs-comment"># vim /etc/apt/sources.list</span><br>deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br><br>root@ubuntu2004:~<span class="hljs-comment">#</span><br>root@ubuntu2004:~<span class="hljs-comment"># visudo</span><br>%sudo ALL=(ALL:ALL) NOPASSWD:ALL<br>root@ubuntu2004:~$ <br><span class="hljs-comment">## 更新本地包数据库</span><br>root@ubuntu2004:~$ apt update<br><span class="hljs-comment">## 更新所有已安装的包（也可以使用 full-upgrade）</span><br>root@ubuntu2004:~$ apt upgrade<br>root@ubuntu2004:~$ apt install screenfetch<br>root@ubuntu2004:~$ apt install vim net-tools aptitude git<br>root@ubuntu2004:~$ apt-get install uml-utilities<br>root@ubuntu2004:~$ apt install bridge-utils<br>root@ubuntu2004:~$ ufw <span class="hljs-built_in">disable</span> <br>root@ubuntu2004:~$ screenfetch<br>                          ./+o+-       root@ubuntu2004<br>                  yyyyy- -yyyyyy+      OS: Ubuntu 20.04 focal<br>               ://+//////-yyyyyyo      Kernel: x86_64 Linux 5.4.0-91-generic<br>           .++ .:/++++++/-.+sss/`      Uptime: 1m<br>         .:++o:  /++++++++/:--:/-      Packages: 656<br>        o:+o+:++.`..```.-/oo+++++/     Shell: bash 5.0.17<br>       .:+o:+o/.          `+sssoo+/    Resolution: No X Server<br>  .++/+:+oo+o:`             /sssooo.   WM: Not Found<br> /+++//+:`oo+o               /::--:.   GTK Theme: Adwaita [GTK3]<br> \+/+o+++`o++o               ++////.   Disk: 6.9G / 52G (15%)<br>  .++.o+++oo+:`             /dddhhh.   CPU: 11th Gen Intel Core i7-11700K @ 4x 3.6GHz<br>       .+.o+oo:.          `oddhhhh+    GPU: VMware SVGA II Adapter<br>        \+.++o+o``-````.:ohdhhhhh+     RAM: 509MiB / 3907MiB<br>         `:o+++ `ohhhhhhhhyo++os:     <br>           .o:`.syhhhhhhh/.oo++o`     <br>               /osyyyyyyo++ooo+++/    <br>                   ````` +oo+++o\:    <br>                          `oo++.      <br>root@ubuntu2004:~$ <br>root@ubuntu2004:~$ vim /etc/ssh/sshd_config<br>PermitRootLogin <span class="hljs-built_in">yes</span>              <span class="hljs-comment">#允许root直接登录</span><br>PermitEmptyPasswords no          <span class="hljs-comment">#因为设置了root密码，所以需要修改为no</span><br>root@ubuntu2004:~$ service ssh restart  重启ssh服务<br>root@ubuntu2004:~$ vim ~/.bash_profile<br><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">&quot;[\u@\h \W]\\$ &quot;</span><br>root@ubuntu2004:~$ <span class="hljs-built_in">source</span> ~/.bash_profile<br>[root@ubuntu2004 ~]<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## Ubuntu（使用 apt-get 进行安装）</span><br><span class="hljs-comment"># step 1: 安装必要的一些系统工具</span><br>sudo apt-get update<br>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br><span class="hljs-comment"># step 2: 安装GPG证书</span><br>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br><span class="hljs-comment"># Step 3: 写入软件源信息</span><br>sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br><span class="hljs-comment"># Step 4: 更新并安装Docker-CE</span><br>sudo apt-get -y update<br>sudo apt-get -y install docker-ce<br><span class="hljs-comment"># 安装指定版本的Docker-CE:</span><br><span class="hljs-comment"># Step 1: 查找Docker-CE的版本:</span><br><span class="hljs-comment"># apt-cache madison docker-ce</span><br><span class="hljs-comment">#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-comment">#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-comment"># Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)</span><br><span class="hljs-comment"># sudo apt-get -y install docker-ce=[VERSION]</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu2004:~$ docker version<br>Client: Docker Engine - Community<br> Version:           20.10.11<br> API version:       1.41<br> Go version:        go1.16.9<br> Git commit:        dea9396<br> Built:             Thu Nov 18 00:37:06 2021<br> OS/Arch:           linux/amd64<br> Context:           default<br> Experimental:      <span class="hljs-literal">true</span><br>Got permission denied <span class="hljs-keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get <span class="hljs-string">&quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version&quot;</span>: dial unix /var/run/docker.sock: connect: permission denied<br>root@ubuntu2004:~$ <br></code></pre></td></tr></table></figure><h5 id="Docker-镜像加速器"><a href="#Docker-镜像加速器" class="headerlink" title="Docker 镜像加速器"></a>Docker 镜像加速器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 镜像加速器</span><br>root@ubuntu2004:~<span class="hljs-comment"># </span><br>root@ubuntu2004:~<span class="hljs-comment"># sudo mkdir -p /etc/docker</span><br>root@ubuntu2004:~<span class="hljs-comment"># sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>          <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>          <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>          <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span><br>  ]<br>&#125;<br>EOF<br>root@ubuntu2004:~<span class="hljs-comment"># systemctl daemon-reload</span><br>root@ubuntu2004:~<span class="hljs-comment"># systemctl restart docker</span><br>root@ubuntu2004:~<span class="hljs-comment"># docker info</span><br> ...<br> Registry Mirrors:<br>  https://docker.mirrors.ustc.edu.cn/<br>  https://hub-mirror.c.163.com/<br>  https://reg-mirror.qiniu.com/<br> Live Restore Enabled: <span class="hljs-literal">false</span><br>root@ubuntu2004:~<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p><strong>参考资料</strong><br><a href="https://micromaple.blog.csdn.net/article/details/125727576">CSDN【云原生】Docker镜像详细讲解</a><br><a href="https://developer.aliyun.com/mirror/docker-ce">阿里云 Docker CE镜像</a><br><a href="https://developer.aliyun.com/mirror/ubuntu">阿里云 Ubuntu 镜像</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>名称空间</title>
    <link href="/2022/08/31/Kernel-Namespace/"/>
    <url>/2022/08/31/Kernel-Namespace/</url>
    
    <content type="html"><![CDATA[<p>Namespaces、CGroups、Containerruntime</p><span id="more"></span><h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><p>内核名称空间（Kernel Namespace）是Linux操作系统中的一个重要概念，用于隔离和管理系统资源。在Linux中，名称空间是一种资源隔离机制，它允许不同的进程看到和访问的资源独立于其他进程，从而实现进程间的隔离性。内核名称空间特别用于隔离内核级别的资源。</p><p>如果把<strong>Linux操作系统</strong>比作一个<strong>大房子</strong>，那<strong>命名空间</strong>指的就是这个房子中的一个个<strong>房间</strong>，住在每个房间里的人都自以为独享了整个房子的资源，但其实大家仅仅只是在共享的基础之上互相隔离，共享指的是共享全局的资源，而隔离指的是局部上彼此保持隔离，因而命名空间的本质就是指：一种在空间上<strong>隔离</strong>的概念，当下盛行的许多容器虚拟化技术（典型代表如LXC、Docker）就是基于linux命名空间的概念而来的。</p><p>Docker容器十分类似LXC容器，他们实现了相同的安全特性。在你使用 <code>docker run</code>,启动一个Docker容器的时候，  Docker 会创建设置一个 namespaces 和 control groups 来配合容器。</p><p>命名空间提供的隔离，是第一个也是最简单的安全形式，在容器中运行的进程在其他容器或主机中是看不到的，基本上不会相互影响。</p><p>每一个容器都有自己的网络机制，这意味这不同的容器能访问其他容器接口的sockets。当然如果你希望容器能相互配置使用，也可以将容器的网络接口释放出来，利用端口转发，让容器像主机一样可以在网络中被识别。都你使用一个公共的端口来连接容器直接内部的网络，你就是尝试去在容器之间进行ping。实际上所有的容器都是利用桥接方式来共享端口连接，一台主机就可以连接运行在上面的所有容器。</p><p><strong>名称空间管理相关的系统调用</strong></p><ul><li><p>clone()：创建子进程，并将其隔离至新建的名称空间之中； 负责创建一个子进程，若同时使用了CLONE_NEW*相关的标志，则为每个标志创建出名称空间，并将该进程置于该名称空间中；</p></li><li><p>setns()：将进程加入到指定的现有名称空间中； 通过操作进程相关的&#x2F;proc&#x2F;[pid]&#x2F;ns&#x2F;目录完成</p></li><li><p>unshare()：将进程隔离至新建的名称空间中； 与clone()类似，但不同之处在于，unshare()在当前进程中创建名称空间，一旦调用完成，当前进程即位于新的名称空间之中；</p></li><li><p>ioctl()：获取名称空间的相关信息。</p></li></ul><p>目前，内核(5.13)支持8种名称空间</p><table><thead><tr><th align="center">名称空间</th><th align="center">调用标志</th><th align="center">隔离内容</th><th align="center">引入时的内核版本</th></tr></thead><tbody><tr><td align="center"><strong>Mount</strong></td><td align="center">CLONE_NEWNS</td><td align="center">挂载点、文件系统</td><td align="center">2.4.19</td></tr><tr><td align="center"><strong>UTS</strong></td><td align="center">CLONE_NEWUFS</td><td align="center">主机名和NIS域名</td><td align="center">2.6.19</td></tr><tr><td align="center"><strong>IPC</strong></td><td align="center">CLONE_NEWIPC</td><td align="center">SysV IPC、POSIX messages</td><td align="center">2.6.19</td></tr><tr><td align="center"><strong>PID</strong></td><td align="center">CLONE_NEWPID</td><td align="center">PID</td><td align="center">2.6.24</td></tr><tr><td align="center"><strong>Network</strong></td><td align="center">CLONE_NEWNET</td><td align="center">网络设备、协议栈、端口等</td><td align="center">2.6.29</td></tr><tr><td align="center"><strong>User</strong></td><td align="center">CLONE_NEWUSER</td><td align="center">User ID和Group ID</td><td align="center">3.8</td></tr><tr><td align="center">Cgroup</td><td align="center">CLONE_NEWCGROUP</td><td align="center">Cgroup根目录及层级结构</td><td align="center">4.6</td></tr><tr><td align="center">Time</td><td align="center">CLONE_NEWTIME</td><td align="center">Boot time和monotonic time</td><td align="center">5.6</td></tr></tbody></table><p><em>备注：<br>monotonic time：单调递增时钟，自系统开机后开始累加计时，但系统休眠时间不计入；<br>boot time：类似于monotonic time，不同之处是，boot time会计入系统休眠时间；</em></p><h4 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h4><p>cgroups(Control Groups) 是 linux 内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</p><p>简单说，cgroups 可以限制、记录任务组所使用的物理资源。本质上来说，cgroups 是内核附加在程序上的一系列钩子(hook)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</p><p>cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups 提供了以下功能：</p><ul><li>资源限制：cgroups 可以对任务的资源总额进行限制。比如设定任务运行时使用的内存上限，一旦超出就发 OOM（内存溢出）。</li><li>优先级分配：通过分配的 CPU 时间片数量和磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。</li><li>资源统计：cgoups 可以统计系统的资源使用量，比如 CPU 使用时长、内存用量等。这个功能非常适合当前云端产品按使用量计费的方式。</li><li>隔离：为组隔离命名空间，这样一个组不会看到另一个组的进程、网络连接和文件系统</li><li>任务控制：cgroups 可以对任务执行挂起、恢复等操作。</li></ul><p><strong>CGroups能够限制的资源：</strong></p><ul><li>blkio：块设备IO</li><li>cpu：CPU</li><li>cpuacct：CPU资源使用报告</li><li>cpuset：多处理器平台上的CPU集合</li><li>devices：设备访问</li><li>freezer：挂起或恢复任务</li><li>memory：内存用量及报告</li><li>perf_event：对cgroup中的任务进行统一性能测试</li><li>net_cls：cgroup中的任务创建的数据报文的类别标识符</li></ul><p>安装Docker后，用户可以在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;docker&#x2F;目录下看到对Docker组应用的各种限制项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cd /sys/fs/cgroup/memory/</span><br>[root@localhost memory]<span class="hljs-comment"># ls</span><br>cgroup.clone_children           memory.kmem.slabinfo                memory.memsw.limit_in_bytes      memory.swappiness<br>cgroup.event_control            memory.kmem.tcp.failcnt             memory.memsw.max_usage_in_bytes  memory.usage_in_bytes<br>cgroup.procs                    memory.kmem.tcp.limit_in_bytes      memory.memsw.usage_in_bytes      memory.use_hierarchy<br>cgroup.sane_behavior            memory.kmem.tcp.max_usage_in_bytes  memory.move_charge_at_immigrate  notify_on_release<br>memory.failcnt                  memory.kmem.tcp.usage_in_bytes      memory.numa_stat                 release_agent<br>memory.force_empty              memory.kmem.usage_in_bytes          memory.oom_control               system.slice<br>memory.kmem.failcnt             memory.limit_in_bytes               memory.pressure_level            tasks<br>memory.kmem.limit_in_bytes      memory.max_usage_in_bytes           memory.soft_limit_in_bytes<br>memory.kmem.max_usage_in_bytes  memory.memsw.failcnt                memory.stat<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cd /sys/fs/cgroup/memory/</span><br>[root@localhost memory]<span class="hljs-comment"># ls</span><br>cgroup.clone_children       memory.kmem.max_usage_in_bytes      memory.memsw.failcnt             memory.stat<br>cgroup.event_control        memory.kmem.slabinfo                memory.memsw.limit_in_bytes      memory.swappiness<br>cgroup.procs                memory.kmem.tcp.failcnt             memory.memsw.max_usage_in_bytes  memory.usage_in_bytes<br>cgroup.sane_behavior        memory.kmem.tcp.limit_in_bytes      memory.memsw.usage_in_bytes      memory.use_hierarchy<br>init.scope                  memory.kmem.tcp.max_usage_in_bytes  memory.move_charge_at_immigrate  notify_on_release<br>memory.failcnt              memory.kmem.tcp.usage_in_bytes      memory.numa_stat                 release_agent<br>memory.force_empty          memory.kmem.usage_in_bytes          memory.oom_control               system.slice<br>memory.kmem.failcnt         memory.limit_in_bytes               memory.pressure_level            tasks<br>memory.kmem.limit_in_bytes  memory.max_usage_in_bytes           memory.soft_limit_in_bytes       user.slice<br></code></pre></td></tr></table></figure><p>用户可以通过修改这些文件值来控制组限制Docker应用资源。</p><h4 id="Container-runtime"><a href="#Container-runtime" class="headerlink" title="Container runtime"></a>Container runtime</h4><p>容器运行时（Container Runtime）是一种软件组件，负责在宿主机上管理和运行容器。它是容器化技术的核心组成部分，允许将应用程序及其依赖项打包并隔离在宿主系统之上。容器运行时与宿主操作系统内核进行交互，并管理容器的生命周期、网络、存储等重要功能。</p><p>容器并非Linux内核中的“一等公民”，它从根本上来说就是由名称空间、CGroups和LSM(Linux内核安全模块) 等几个内核原语组成；</p><ul><li><p>借助于这些内核原语即可设置安全、隔离的进程运行环境，但这也意味着每次创建都得手动执行相关的操作；</p></li><li><p>“容器运行时”便是一组简化该类操作的工具集</p></li></ul><p>“运行时”是进程的生命周期管理工具，容器运行时是一种特指运行和管理容器所需要的软件</p><p>用于帮助用户轻松、高效、安全地部署容器，而且是容器管理的关键组件</p><p>2007年，CGroups引入到Linux内核之后，便出现了一些容器运行时项目，例如LXC(Linux containers)和LMCTFY(Google)等</p><p>容器运行时的主要任务包括：</p><ul><li><p>容器创建：它加载容器镜像，该镜像包含应用程序及其运行时依赖项，并创建一个具有独立文件系统的容器实例。</p></li><li><p>容器执行：运行时启动容器进程，管理其资源，并提供一个独立的执行环境，使其表现为一个隔离的应用程序实例。</p></li><li><p>容器网络：设置网络接口并管理容器的网络连接，使其能够与其他容器或外部网络进行通信。</p></li><li><p>资源管理：运行时确保容器访问所需的资源，同时根据配置的限制限制其对宿主资源的访问。</p></li><li><p>容器终止：当容器内的应用程序完成任务或被显式停止时，运行时负责清理资源并终止容器。</p></li></ul><h4 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h4><p>借助于称之为 “容器运行时 Container Runtime” 的软件技术，在同一个内核之上生成多个彼此隔离的用户空间</p><ul><li>各用户空间可独立管理运行其内部进程</li><li>每个用户空间 “自以为” 独占该内核及硬件资源</li><li>每一个用户空间就叫一个容器</li></ul><p>需要将内核级的共享资源进行隔离，每个容器暴露的是系统接口</p><ul><li><p>依赖于内核中称为 “名称空间” 的技术进行</p><p>名称空间是Linux内核特性，用于隔离部分系统资源，从而使得进程仅可访问同一名称空间中的相应资源；</p><p>名称空间只能做到隔离，做不到资源的分配；</p></li><li><p>资源限制则依赖于由Google贡献的 “CGroups”</p><p>cgroups(Control Groups) 是 linux 内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</p></li></ul><p>支撑容器创建的功能是内置于内核当中的，需要通过系统调用来实现；用户空间虚拟化是内核的功能。</p><p>每一个容器都是一组独立的名称空间，一组名称空间组合起来形成的。</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文彻底弄懂REST API</title>
    <link href="/2022/08/20/REST-API/"/>
    <url>/2022/08/20/REST-API/</url>
    
    <content type="html"><![CDATA[<p>一文彻底弄懂REST API</p><span id="more"></span><center><img src="https://img.darklorder.com/img/202307070418363.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这是一个开发中经常会遇到的名词，也许你已经了解过一些这方面的知识，也有可能对这个概念比较模糊。本文将会诠释REST的基础以及如何给应用创建一个API，我们开始正文。</p><h4 id="什么是API？"><a href="#什么是API？" class="headerlink" title="什么是API？"></a><strong>什么是API？</strong></h4><p>首先介绍API的概念，Application Programming Interface（应用程序接口）是它的全称。简单的理解就是，API是一个接口。那么它是一个怎样的接口呢，现在我们常将它看成一个HTTP接口即HTTP API。也就是说这个接口得通过HTTP的方式来调用，做过前后端开发的小伙伴可能知道，后端开发又叫做面向接口开发，我们往往会提供一个接口供前端调用，或者供其他服务调用。举个例子，我们程序中往往会涉及到调用第三方接口，比如说，调用支付宝或者微信的支付接口来实现我们程序中的支付功能、调用带三方的短信接口来向用户发送验证码短信等等…</p><p>这样说吧，比如说我们有一个可以允许我们查看（view），创建（create），编辑（edit）以及删除（delete）部件的应用程序。我们可以创建一个可以让我们执行这些功能的HTTP API:</p><p><a href="http://demo.com/view_books">http://demo.com/view_books</a><br><a href="http://demo.com/create_new_book?name=shuxue">http://demo.com/create_new_book?name=shuxue</a><br><a href="http://demo.com/update_book?id=1&amp;name=shuxue">http://demo.com/update_book?id=1&amp;name=shuxue</a><br><a href="http://demo.com/delete_book">http://demo.com/delete_book</a>?</p><p>这是4个HTTP API，分别实现了图书的查看、新增、编辑、删除的操作，当我们把接口发布出去的时候，别人就可以通过这四个接口来调用相关的服务了。但是这样做有什么不方便的地方呢？你可能发现了，这种API的写法有一个缺点 ，那就是没有一个统一的风格，比如说第一个接口表示查询全部图书的信息，我们也可以写成这样：</p><p><a href="http://demo.com/books/list">http://demo.com/books/list</a><br>那这样就会造成使用我们接口的其他人必须得参考API才能知道它是怎么运作的。</p><p>不用担心，REST会帮我们解决这个问题。</p><h4 id="什么是REST？"><a href="#什么是REST？" class="headerlink" title="什么是REST？"></a><strong>什么是REST？</strong></h4><p>有了上面的介绍，你可能也大概有了直观的了解，说白了，<strong>REST是一种风格！</strong></p><p>REST的作用是将我们上面提到的查看（view），创建（create），编辑（edit）和删除（delete）直接映射到HTTP 中已实现的<strong>GET,POST,PUT和DELETE</strong>方法。</p><p>这四种方法是比较常用的，HTTP总共包含<strong>八种</strong>方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GET</span><br>POST<br>PUT<br><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">OPTIONS</span><br>HEAD<br>TRACE<br><span class="hljs-keyword">CONNECT</span><br></code></pre></td></tr></table></figure><p>当我们在浏览器点点点的时候我们通常只用到了GET方法，当我们提交表单，例如注册用户的时候我们就用到了POST方法…</p><p>介绍到这里，我们重新将上面的四个接口改写成REST风格：</p><p><strong>查看所有图书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//</span>demo.com/books<br></code></pre></td></tr></table></figure><p><strong>新增一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST http:<span class="hljs-regexp">//</span>demo.com/books<br>Data: name=shuxue<br></code></pre></td></tr></table></figure><p><strong>修改一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT http:<span class="hljs-regexp">//</span>demo.com/books<br>Data:id=<span class="hljs-number">1</span>,name=shuxue<br></code></pre></td></tr></table></figure><p><strong>删除一本书：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">DELETE http:<span class="hljs-regexp">//</span>demo.com/books<br>Data:id=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>大家有没有发现，这样改动之后API变得统一了，我们只需要改变请求方式就可以完成相关的操作，这样大大简化了我们接口的理解难度，变得易于调用。</p><p><strong>这就是REST风格的意义！</strong></p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h4><p>REST的另一重要部分就是为既定好请求的类型来响应正确的状态码。如果你对HTTP状态码陌生，以下是一个简易总结。当你请求HTTP时，服务器会响应一个状态码来判断你的请求是否成功，然后客户端应如何继续。以下是四种不同层次的状态码：</p><ul><li>2xx &#x3D; Success（成功）</li><li>3xx &#x3D; Redirect（重定向）</li><li>4xx &#x3D; User error（客户端错误）</li><li>5xx &#x3D; Server error（服务器端错误）</li></ul><p>我们常见的是200（请求成功）、404（未找到）、401（未授权）、500（服务器错误）…</p><h4 id="API格式响应"><a href="#API格式响应" class="headerlink" title="API格式响应"></a><strong>API格式响应</strong></h4><p>上面介绍了REST API的写法，响应状态码，剩下就是请求的数据格式以及响应的数据格式。说的通俗点就是，我们用什么格式的参数去请求接口并且我们能得到什么格式的响应结果。</p><p>我这里只介绍一种用的最多的格式——JSON格式</p><p>目前json已经发展成了一种最常用的数据格式，由于其轻量、易读的优点。</p><p>所以我们经常会看到一个请求的header信息中有这样的参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>:application/json<br></code></pre></td></tr></table></figure><p>这个参数的意思就是接收来自后端的json格式的信息。</p><p>我举个json响应的例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;<br>&quot;code&quot;: 200,<br>&quot;books&quot;: [&#123;<br>&quot;id&quot;: 1,<br>&quot;name&quot;: &quot;yuwen&quot;<br>&#125;, &#123;<br>&quot;id&quot;: 2,<br>&quot;name&quot;: &quot;shuxue&quot;<br>&#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样返回是不是一目了然，而且冗余信息很少！</p><h4 id="REST-API例子"><a href="#REST-API例子" class="headerlink" title="REST API例子"></a><strong>REST API例子</strong></h4><p>说了这么多，最后我以一个实际REST API的例子结尾（这里以java语言为例）</p><p>我们新建一个SpringBoot的项目demo</p><center><img src="https://img.darklorder.com/img/202307070418852.jpg"  alt="文件名" style="zoom:50%;" /></center><p>然后写上查看、新增、修改、删除四个接口（这里为了方便返回的格式我用字符串代替json格式）</p><center><img src="https://img.darklorder.com/img/202307070418147.jpg"  alt="文件名" style="zoom:40%;" /></center><p>最后通过Apifox工具对四个接口依次进行测试。如下图。</p><center><img src="https://img.darklorder.com/img/202307070418078.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070418452.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070418347.jpg"  alt="文件名" style="zoom:40%;" /></center><center><img src="https://img.darklorder.com/img/202307070417291.jpg"  alt="文件名" style="zoom:40%;" /></center><p>以上，</p><p><strong>问：REST API是什么呢？</strong></p><p><strong>答：是一种REST风格的HTTP接口！</strong></p><p><strong>参考资料</strong><br><a href="https://zhuanlan.zhihu.com/p/536437382">一文彻底弄懂REST API - 知乎</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟化技术的分类及介绍</title>
    <link href="/2022/08/12/Classification-and-Introduction-of-Virtualization-Technology/"/>
    <url>/2022/08/12/Classification-and-Introduction-of-Virtualization-Technology/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>虚拟化是云计算系统中的一种基础技术，可以说当前一个云计算服务必定是构建在虚拟化的基础上的。本文首先介绍了不同抽象层次的虚拟化技术，之后对应用广泛的系统级虚拟化和操作系统级虚拟化进行了更详细的分类和描述，最后介绍了各种典型虚拟化方案的具体实现。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>虚拟化是计算机系统中的一个重要概念，基本上每个计算机系统都提供一个给上层软件的界面，从处理器提供的基本指令集到很多中间件系统提供的巨大的应用程序界面集。虚拟化本质上是扩展或替换一个现存界面来模仿另一个系统的行为，其对计算机系统的重要性主要体现在以下几个方面。</p><p>相比高层软件（比如中间件和应用软件），硬件和底层系统软件变化得比较快，也就是说，我们面对的一种情况是旧有软件的维护跟不上下层平台更新的步伐。通过移植旧有软件的底层接口到新平台，可使得一大类的现有软件可以立刻在新平台上工作。</p><p>在服务器机器上，一个组织为它提供的每个服务都分配一台虚拟机，接着，将虚拟机以最佳方式分配到物理服务器上。与进程不同，虚拟机能很简单地迁移到其他物理机器上，这增加了管理服务器基础设施的灵活性。这个方法能潜在地减少服务器计算机的投资并减少能量消耗，后者是大型服务器中心的关键问题。</p><p>虚拟化技术和云计算的提供极为相关。云计算采用了这样一个模型，即作为一个服务，提供云上创建的存储、计算和高层对象。所提供的服务覆盖从诸如物理体系结构等的底层方面（基础设施即服务IaaS）到诸如软件平台（平台即服务PaaS），再到任意应用层次的服务（软件即服务SaaS）。云服务的提供被虚拟化技术直接驱动，允许为云的用户提供一个或多个虚拟机，供用户自己使用。</p><p>分布式应用的需求也激发虚拟化解决方案的开发者去以很少的开销创建和销毁虚拟机。在可能需要动态地请求资源的应用中，这是必要的。例如对于多人在线游戏或分布式多媒体应用，通过采用合适的资源分配策略满足虚拟机服务质量需求，能提升对这样的应用的支持度。</p><p>另一个好处是，在单台计算机上提供对几个不同操作系统环境的便利访问，虚拟化可用于在一种物理体系结构上提供多种操作系统类型。</p><p>虚拟化技术起始于IBM370体系结构，它的VM操作系统能为运行在同一计算机上的不同程序提供几个完整的虚拟机。最近，人们对虚拟化的兴趣大增，有许多研究项目和商业系统为商用PC、服务器和云基础设施提供虚拟化解决方案。</p><h2 id="虚拟化技术的分类"><a href="#虚拟化技术的分类" class="headerlink" title="虚拟化技术的分类"></a>虚拟化技术的分类</h2><p>现代计算机系统是一个庞大的整体，整个系统的复杂性是不言而喻的。因而，整个计算机系统被分成了多个自下而上的层次，每一个层次都向上一层次呈现一个抽象，并且每一层只需知道下层抽象的接口，而不需要了解其内部运作机制。这样以层的方式抽象资源的好处是每一层只需要考虑本层设计以及与相邻层间的相互交互，从而大大降低了系统设计的复杂性，提高了软件的移植性。</p><p>本质上，虚拟化就是由位于下层的软件模块，通过向上一层软件模块提供一个与它原先所期待的运行环境完全一致的接口的方法，抽象出一个虚拟的软件或硬件接口，使得上层软件可以直接运行在虚拟的环境上。虚拟化可以发生在现代计算机系统的各个层次上，不同层次的虚拟化会带来不同的虚拟化概念。</p><p>如前文所述，虚拟化技术起源于上世纪70年代的IBM370体系，经过四十余年的发展，当前存在诸多实现在不同层次的虚拟化技术，原理不尽相同，且每一种技术都相当复杂。在本文中，将通过不同的角度对目前存在的较流行的虚拟化技术进行分类，并对其原理进行初步介绍，旨在对纷繁复杂的虚拟化技术有个整体认识及厘清不同虚拟化技术之间的相互关系。</p><h3 id="不同抽象层次的虚拟化技术"><a href="#不同抽象层次的虚拟化技术" class="headerlink" title="不同抽象层次的虚拟化技术"></a>不同抽象层次的虚拟化技术</h3><p>在介绍各种虚拟化概念之前，先介绍虚拟化中的两个重要名词。在虚拟化中，物理资源通常有一个定语称为宿主（Host），而虚拟出来的资源通常有一个定语称为客户（Guest）。</p><p>在计算机系统中，从底层至高层依次可分为：硬件层、操作系统层、函数库层、应用程序层，在对某层实施虚拟化时，该层和上一层之间的接口不发生变化，而只变化该层的实现方式。从使用虚拟资源的Guest的角度来看，虚拟化可发生在上述四层中的任一层。应当注意，在对Guest的某一层进行虚拟化时，并未对Host在哪一层实现它作出要求，这一点是时常引起混淆的地方。</p><h4 id="硬件抽象层上的虚拟化"><a href="#硬件抽象层上的虚拟化" class="headerlink" title="硬件抽象层上的虚拟化"></a>硬件抽象层上的虚拟化</h4><p>硬件抽象层上的虚拟化是指通过虚拟硬件抽象层来实现虚拟机，为客户机操作系统呈现和物理硬件相同或相近的硬件抽象层，又称为指令集级虚拟化，实现在此层的虚拟化粒度是最小的。</p><p>实现在此层的虚拟化技术可以对整个计算机系统进行虚拟，即可将一台物理计算机系统虚拟化为一台或多台虚拟计算机系统，故又可称作系统级虚拟化。每个虚拟计算机系统（简称为虚拟机）都拥有自己的虚拟硬件（如CPU、内存和设备等），来提供一个独立的虚拟机执行环境。每个虚拟机中的操作系统可以完全不同，并且它们的执行环境是完全独立的。由于客户机操作系统所能看到的是硬件抽象层，因此，客户机操作系统的行为和在物理平台上没有什么区别。</p><h4 id="操作系统层上的虚拟化"><a href="#操作系统层上的虚拟化" class="headerlink" title="操作系统层上的虚拟化"></a>操作系统层上的虚拟化</h4><p>操作系统层上的虚拟化是指操作系统的内核可以提供多个互相隔离的用户态实例。这些用户态实例（经常被称为容器）对于它的用户来说就像是一台真实的计算机，有自己独立的文件系统、网络、系统设置和库函数等。</p><p>由于这是操作系统内核主动提供的虚拟化，因此操作系统层上的虚拟化通常非常高效，它的虚拟化资源和性能开销非常小，也不需要有硬件的特殊支持。但它的灵活性相对较小，每个容器中的操作系统通常必须是同一种操作系统。另外，操作系统层上的虚拟化虽然为用户态实例间提供了比较强的隔离性，但其粒度是比较粗的。</p><h4 id="库函数层上的虚拟化"><a href="#库函数层上的虚拟化" class="headerlink" title="库函数层上的虚拟化"></a>库函数层上的虚拟化</h4><p>操作系统通常会通过应用级的库函数提供给应用程序一组服务，例如文件操作服务、时间操作服务等。这些库函数可以隐藏操作系统内部的一些细节，使得应用程序编程更为简单。不同的操作系统库函数有着不同的服务接口，例如Linux的服务接口是不同于Windows的。库函数层上的虚拟化就是通过虚拟化操作系统的应用级库函数的服务接口，使得应用程序不需要修改，就可以在不同的操作系统中无缝运行，从而提高系统间的互操作性。</p><p>例如，Wine就是在Linux上模拟了Windows的库函数接口，使得一个Windows应用程序能够在Linux上正常运行。</p><h4 id="编程语言层上的虚拟化"><a href="#编程语言层上的虚拟化" class="headerlink" title="编程语言层上的虚拟化"></a>编程语言层上的虚拟化</h4><p>另一大类编程语言层上的虚拟机称为语言级虚拟机，例如JVM（Java Virtual Machine）和微软的CLR（Common Language Runtime）。这一类虚拟机运行的是进程级的作业，所不同的是这些程序所针对的不是一个硬件上存在的体系结构，而是一个虚拟体系结构。这些程序的代码首先被编译为针对其虚拟体系结构的中间代码，再由虚拟机的运行时支持系统翻译为硬件的机器语言进行执行。</p><h3 id="系统级虚拟化"><a href="#系统级虚拟化" class="headerlink" title="系统级虚拟化"></a>系统级虚拟化</h3><p>系统级虚拟化即硬件抽象层上的虚拟化、指令集级虚拟化，是最早被提出和研究的一种虚拟化技术，当前存在多种此种技术的具体实现方案，在介绍它们之前，有必要先了解实现系统级虚拟化可采取的途径。</p><p>在每台虚拟机中都有属于它的虚拟硬件，通过虚拟化层的模拟，虚拟机中的操作系统认为自己仍然是独占一个系统在运行，这个虚拟化层被称为虚拟机监控器（Virtual Machine Monitor，VMM）。VMM对物理资源的虚拟可以归结为三个主要任务：处理器虚拟化、内存虚拟化和I&#x2F;O虚拟化。其中，处理器虚拟化是VMM中最核心的部分，因为访问内存或进行I&#x2F;O本身就是通过一些指令来实现的。</p><h4 id="可虚拟化架构和不可虚拟化架构"><a href="#可虚拟化架构和不可虚拟化架构" class="headerlink" title="可虚拟化架构和不可虚拟化架构"></a>可虚拟化架构和不可虚拟化架构</h4><p>在系统级虚拟化中，虚拟计算机系统和物理计算机系统可以是两个完全不同ISA（Instruction Set Architecture，指令集架构）的系统，例如，可以在一个x86的物理计算机上运行一个安腾的虚拟计算机。但是，不同的ISA使得虚拟机的每一条指令都需要在物理机上模拟执行，从而造成性能上的极大下降。</p><p>显然，相同体系结构的系统虚拟化通常会有比较好的性能，并且VMM实现起来也会比较简单。这种情况下虚拟机的大部分指令可以在处理器上直接运行，只有那些与硬件资源关系密切的敏感指令才会由VMM进行处理。此时面前的一个问题是，要能将这些敏感指令很好地筛选出来。但事实上，某些处理器在设计之初并没有充分考虑虚拟化的需求，导致没有办法识别出所有的敏感指令，因而不具备一个完备的可虚拟化结构。</p><p>大多数的现代计算机体系结构都有两个或两个以上的特权级，用来分隔系统软件和应用软件。系统中有一些操作和管理关键系统资源的指令会被定为特权指令，这些指令只有在最高特权级上才能够正确执行。如果在非最高特权级上运行，特权指令会引发一个异常，处理器会陷入到最高特权级，交由系统软件来处理。</p><p>在x86架构中，所有的特权指令都是敏感指令，然而并不是所有的敏感指令都是特权指令。</p><p>为了VMM可以完全控制系统资源，它不允许虚拟机上操作系统直接执行敏感指令。如果一个系统上所有敏感指令都是特权指令，则能够用一个很简单的方法来实现一个虚拟环境：将VMM运行在系统的最高特权级上，而将客户机操作系统运行在非最高特权级上，当客户机操作系统因执行敏感指令而陷入到VMM时，VMM模拟执行引起异常的敏感指令，这种方法被称为“陷入再模拟”。</p><p>总而言之，判断一个架构是否可虚拟化，其核心就在于该结构对敏感指令的支持上。如果一个架构中所有敏感指令都是特权指令，则称其为可虚拟化架构，否则称为不可虚拟化架构。</p><h4 id="按照实现方法分类"><a href="#按照实现方法分类" class="headerlink" title="按照实现方法分类"></a>按照实现方法分类</h4><p>系统级虚拟化有许多不同的具体实现方案，按照实现方法的不同，可划分为如下几个类别。</p><p><strong>（1）仿真（Emulation）</strong></p><p>我们已经知道，通过陷入再模拟敏感指令的执行来实现虚拟机的方法是有前提条件的：所有的敏感指令必须都是特权指令。如果一个体系结构上存在敏感指令不属于特权指令，那么其就存在虚拟化漏洞，可以采用一些方法来填补或避免这些漏洞。最简单直接的方法是，所有指令都采用模拟来实现，就是取一条指令，就模拟出这条指令执行的效果。这种方法称作仿真。</p><p>仿真是最复杂的虚拟化实现技术，使用仿真方法，可以在一个x86处理器上运行为PowerPC设计的操作系统，这在其它的虚拟化方案中是无法实现的。甚至可以运行多个虚拟机，每个虚拟机仿真一个不同的处理器。此外，这种方法不需要对宿主操作系统的特殊支持，虚拟机可以完全作为应用层程序运行。</p><p>正如前面提到的，使用仿真方法的主要问题是速度会非常慢。由于每条指令都必须在底层硬件上进行仿真，因此速度减慢100倍的情况也并不稀奇。若要实现高度保真的仿真，包括周期精度、CPU的缓存行为等，实际速度差距甚至可能会达到1000倍之多。</p><p>使用这种方式的典型实现是Bochs。</p><p><strong>（2）完全虚拟化（Full Virtualization）</strong></p><p>在客户操作系统看来，完全虚拟化的虚拟平台和现实平台是一样的，客户机操作系统察觉不到是运行在一个虚拟平台上，这样的虚拟平台可以运行现有的操作系统，无须对操作系统进行任何修改，因此这种方式被称为完全虚拟化。</p><p>进一步说，客户机的行为是通过执行反映出来的，因此VMM需要能够正确处理所有可能的指令。在实现方式上，以x86架构为例，完全虚拟化经历了两个阶段：软件辅助的完全虚拟化和硬件辅助的完全虚拟化。</p><p><strong>①软件实现的完全虚拟化</strong></p><p>在x86虚拟化技术的早期，没有在硬件层次上对虚拟化提供支持，因此完全虚拟化只能通过软件实现。一个典型的做法是二进制代码翻译（Binary Translation）。</p><p>二进制代码翻译的思想是，通过扫描并修改客户机的二进制代码，将难以虚拟化的指令转化为支持虚拟化的指令。VMM通常会对操作系统的二进制代码进行扫描，一旦发现需要处理的指令，就将其翻译成为支持虚拟化的指令块（Cache Block）。这些指令块可以与VMM合作访问受限的虚拟资源，或者显式地触发异常让VMM进一步处理。</p><p>这种技术虽然能够实现完全虚拟化，但很难在架构上保证其完整性。因此，x86厂商在硬件上加入了对虚拟化的支持，从而在硬件架构上实现了虚拟化。</p><p><strong>②硬件辅助完全虚拟化</strong></p><p>可以预料，如果硬件本身加入足够的虚拟化功能，可以截获操作系统对敏感指令的执行或者对敏感资源的访问，从而通过异常的方式报告给VMM，这样就解决了虚拟化的问题。硬件虚拟化时一种完备的虚拟化方法，因而内存和外设的访问本身也是由指令来承载，对处理器指令级别的截获就意味着VMM可以模拟一个与真实主机完全一样的环境。</p><p>Intel的VT-x和AMD的AMD-V是这一方向的代表。以VT-x为例，其在处理器上引入了一个新的执行模式用于运行虚拟机，当虚拟机执行在这个特殊模式中时，它仍然面对的是一套完整的处理器寄存器集合和执行环境，只是任何敏感操作都会被处理器截获并报告给VMM。</p><p>在当前的系统级虚拟化解决方案中，全虚拟化应用得非常普遍，典型的有知名的产品有VirtualBox、KVM、VMware Workstation和VMware ESX（它在其4.0版，被改名为VMware vSphere）、Xen（也支持全虚拟化）。</p><p><strong>（3）类虚拟化（Para-Virtualization）</strong></p><p>这样的虚拟平台需要对所运行的客户机操作系统进行或多或少的修改使之适应虚拟环境，因此客户机操作系统知道其运行在虚拟平台上，并且会去主动适应。这种方式被称为类虚拟化，有时也称作半虚拟化。另外，值得指出的是，一个VMM可以既提供完全虚拟化的虚拟平台，又提供类虚拟化的虚拟平台。</p><p>类虚拟化是通过在源代码级别修改指令以回避虚拟化漏洞的方式来使VMM 能够对物理资源实现虚拟化。上面谈到x86 存在一些难以虚拟化的指令，完全虚拟化通过Binary Translation在二进制代码级别上来避免虚拟化漏洞。类虚拟化采取的是另一种思路，即修改操作系统内核的代码，使得操作系统内核完全避免这些难以虚拟化的指令。</p><p>既然内核代码已经需要修改，类虚拟化进一步可以被用于优化I&#x2F;O。也就是说，类虚拟化不是去模拟真实世界中的设备，因为太多的寄存器模拟会降低性能．相反，类虚拟化可以自定义出高度优化的协议I&#x2F;O。这种I&#x2F;O协议完全基于事务，可以达到近似物理机的速度。</p><p>这种虚拟技术以Xen为代表，微软的Hyper-V所采用技术和Xen类似，也可以把Hyper-V归属于半虚拟化。</p><h4 id="按照实现结构分类"><a href="#按照实现结构分类" class="headerlink" title="按照实现结构分类"></a>按照实现结构分类</h4><p>在系统级虚拟化的实现中，VMM是一个关键角色，前面已介绍过VMM的组成部分。从Host实现VMM的角度出发，还可以将当前主流的虚拟化技术按照实现结构分为如下三类。</p><ul><li><strong>Hypervisor模型</strong></li></ul><p>Hypervisor这个术语是在 20 世纪 70 年代出现的，在早期计算机界，操作系统被称为Supervisor，因而能够在其他操作系统上运行的操作系统被称为 Hypervisor。</p><p>在Hypervisor模型中，VMM首先可以被看做是一个完备的操作系统，不过和传统操作系统不同的是，VMM是为虚拟化而设计的，因此还具备虚拟化功能。从架构上来看，首先，所有的物理资源如处理器、内存和I&#x2F;O设备等都归VMM所有，因此，VMM承担着管理物理资源的责任；其次，VMM需要向上提供虚拟机用于运行客户机操作系统，因此，VMM还负责虚拟环境的创建和管理。</p><p>由于VMM同时具备物理资源的管理功能和虚拟化功能，因此，物理资源虚拟化的效率会更高一些。在安全方面，虚拟机的安全只依赖于VMM的安全。Hypervisor模型在拥有虚拟化高效率的同时也有其缺点。由于VMM完全拥有物理资源，因此，VMM需要进行物理资源的管理，包括设备的驱动。我们知道，设备驱动开发的工作量是很大的。因此，对于Hypervisor模型来说这是个很大的挑战。事实上，在实际的产品中，基于Hypervisor模型的VMM通常会根据产品定位，有选择地挑选一些I&#x2F;O设备来支持，而不是支持所有的I&#x2F;O设备。</p><p>采用这种模型的典型是面向企业级应用的VMware vSphere。</p><ul><li><strong>宿主模型</strong></li></ul><p>与Hypervisor模型不同。在宿主模型中，物理资源由宿主机操作系统管理。宿主机操作系统是传统操作系统，如Windows 、Linux等，这些传统操作系统并不是为虚拟化而设计的，因此本身并不具备虚拟化功能，实际的虚拟化功能由VMM来提供。VMM通常是宿主机操作系统独立的内核模块，有些实现中还包括用户态进程，如负责I&#x2F;O虚拟化的用户态设备模型。 VMM通过调用宿主机操作系统的服务来获得资源， 实现处理器、内存和I&#x2F;O设备的虚拟化。VMM创建出虚拟机之后，通常将虚拟机作为宿主机操作系统的一个进程参与调度。</p><p>宿主模型的优缺点和Hypervisor模型恰好相反。宿主模型最大的优点是可以充分利用现有操作系统的设备驱动程序，VMM无须为各类I&#x2F;O设备重新实现驱动程序，可以专注于物理资源的虚拟化。考虑到I&#x2F;O设备种类繁多，千变万化， 设备驱动程序开发的工作量非常大，因此，这个优点意义重大。此外，宿主模型也可以利用宿主机操作系统的其他功能，例如调度和电源管理等，这些都不需要VMM重新实现就可以直接使用。</p><p>宿主模型当然也有缺点，由于物理资源由宿主机操作系统控制，VMM得要调用宿主机操作系统的服务来获取资源进行虚拟化，而那些系统服务在设计开发之初并没有考虑虚拟化的支持，因此，VMM虚拟化的效率和功能会受到一定影响。此外，在安全方面，由于VMM是宿主机操作系统内核的一部分，因此，如果宿主机操作系统内核是不安全的，那么，VMM也是不安全的，相应地运行在虚拟机之上的客户机操作系统也是不安全的。换言之，虚拟机的安全不仅依赖于VMM的安全，也依赖于宿主机操作系统的安全。</p><p>采用这种模型的典型是KVM、VirtualBox和VMware Workstation。</p><ul><li><strong>混合模型</strong></li></ul><p>混合模型是上述两种模式的汇合体。VMM依然位于最低层，拥有所有的物理资源。与Hypervisor模式不同的是，VMM 会主动让出大部分I&#x2F;O设备的控制权，将它们交由一个运行在特权虚拟机中的特权操作系统控制。相应地，VMM 虚拟化的职责也被分担．处理器和内存的虚拟化依然由VMM来完成，而I&#x2F;O的虚拟化则由VMM和特权操作系统共同合作来完成。</p><p>I&#x2F;O设备虚拟化由VMM和特权操作系统共同完成，因此，设备模型模块位于特权操作系统中，并且通过相应的通信机制与VMM合作。</p><p>混合模型集中了上述两种模型的优点。 VMM可以利用现有操作系统的I&#x2F;O设备驱动程序，不需要另外开发。VMM直接控制处理器、内存等物理资源，虚拟化的效率也比较高。</p><p>在安全方面，如果对特权操作系统的权限控制得当，虚拟机的安全性只依赖于VMM。当然，混合模型也存在缺点。由于特权操作系统运行在虚拟机上，当需要特权操作系统提供服务时，VMM需要切换到特权操作系统，这里面就产生上下文切换的开销。当切换比较频繁时，上下文切换的开销会造成性能的明显下降。出于性能方面的考虑，很多功能还是必须在VMM 中实现，如调度程序和电源管理等。</p><p>采用这种模型的典型是Xen。</p><h3 id="操作系统级虚拟化"><a href="#操作系统级虚拟化" class="headerlink" title="操作系统级虚拟化"></a>操作系统级虚拟化</h3><p>在操作系统虚拟化技术中，每个节点上只有唯一的系统内核，不虚拟任何硬件设备。通过使用操作系统提供的功能，多个虚拟环境之间可以相互隔离。通常所说的容器（Container）技术，如目前为止最流行的容器系统Docker，即属于操作系统级虚拟化。此外，在不同的场景中，隔离出的虚拟环境也被称作虚拟环境（即VE，Virtual Environment）或虚拟专用服务器（即VPS，Virtual Private Server）。</p><p>以容器技术为例，它有自己独特的优点，它的出现，一方面解决了传统操作系统所忽视和缺乏的应用程序间的独立性问题，另一方面，它避免了相对笨重的系统级虚拟化，是一种轻量级的虚拟化解决方案。</p><p>操作系统领域一直以来面临的一个主要挑战来自于应用程序间存在的相互独立性和资源互操作性之间的矛盾，即每个应用程序都希望能运行在一个相对独立的系统环境下，不受到其他程序的干扰，同时又能以方便快捷的方式与其他程序交换和共享系统资源。当前通用操作系统更强调程序间的互操作性，而缺乏对程序间相对独立性的有效支持，然而对于许多分布式系统如Web服务、数据库、游戏平台等应用领域，提供高效的资源互操作同保持程序间的相对独立性具有同等重要的意义。</p><p>主流虚拟化产品VMware和Xen等均采用Hypervisor模型（Xen采用的混合模型与Hypervisor模型差别不大，可统称为Hypervisor模型）。该模型通过将应用程序运行在多个不同虚拟机内，实现对上层应用程序的隔离。但由于Hypervisor 模型倾向于每个虚拟机都拥有一份相对独立的系统资源，以提供更为完全的独立性，这种策略造成处于不同虚拟机内的应用程序间实现互操作非常困难。例如， 即使是运行在同一台物理机器上，如果处于不同虚拟机内，那么应用程序间仍然只能通过网络进行数据交换，而非共享内存或者文件。而如果使用容器技术，由于各容器共享同一个宿主操作系统，能够在满足基本的独立性需求的同时提供高效的系统资源共享支持。</p><p>容器技术还可以更高效地使用系统资源，由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。此外，容器还具有更快速的启动时间，传统的虚拟机技术启动应用服务往往需要数分钟，而对于容器由于，直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大的节约了应用开发、测试、部署的时间。</p><h2 id="典型虚拟化技术实现及其特点"><a href="#典型虚拟化技术实现及其特点" class="headerlink" title="典型虚拟化技术实现及其特点"></a>典型虚拟化技术实现及其特点</h2><h3 id="系统级虚拟化实现"><a href="#系统级虚拟化实现" class="headerlink" title="系统级虚拟化实现"></a>系统级虚拟化实现</h3><h4 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h4><p>VMware是x86 虚拟化软件的主流广商之一。VMware的5位创始人中的3位曾在斯坦福大学研究操作系统虚拟化，项目包括SimOS系统模拟器和Disco虚拟机监控器。1998年，他们与另外两位创始人共同创建了VMware 公司，总部位于美国加州Palo Alto。</p><p>VMware提供一系列的虚拟化产品，产品的应用领域从服务器到桌面。下面是VMware主要产品的简介，包括VMware ESX、VMware Server和VMware Workstation。</p><p>VMware ESX Server是VMware的旗舰产品，后续版本改称VMware vSphere。ESX Server基于Hypervisor模型，在性能和安全性方面都得到了优化，是一款面向企业级应用的产品。VMware ESX Server支持完全虚拟化，可以运行Windows 、Linux、Solaris和Novell Netware等客户机操作系统。VMware ESX Server也支持类虚拟化，可以运行Linux 2. 6. 21 以上的客户机操作系统。ESX Server的早期版本采用软件虚拟化的方式，基于Binary Translation技术。自ESX Server 3开始采用硬件虚拟化的技术，支持Intel VT技术和AMD-V技术。</p><p>VMware Server之前叫VMware GSX Server，是VMware面向服务器端的入门级产品。VMware Server采用了宿主模型，宿主机操作系统可以是Windows或者Linux。VMware Server的功能与ESX Server类似，但是在性能和安全性上与ESX Server有所差距。VMware Server也有自己的优点，由于采用了宿主模型，因此VMware Server支持的硬件种类要比ESX Server多。</p><p>VMware Workstation是VMware面向桌面的主打产品。与VMware Server类似，VMware Workstation也是基于宿主模型，宿主机操作系统可以是Windows或者Linux。VMware Workstation也支持完全虚拟化，可以运行Windows、Linux、Solaris、Novell Netware和FreeBSD等客户机操作系统。与VMware Server不同， VMware Workstation专门针对桌面应用做了优化，如为虚拟机分配USB设备，为虚拟机显卡进行3D加速等。</p><h4 id="Microsoft"><a href="#Microsoft" class="headerlink" title="Microsoft"></a>Microsoft</h4><p>微软在虚拟化产品方面起步比VMware晚，但是在认识到虚拟化的重要性之后，微软通过外部收购和内部开发，推出了一系列虚拟化产品，目前已经形成了比较完整的虚拟化产品线。微软的虚拟化产品涵盖了服务器虚拟化（Hyper-V）和桌面虚拟化（Virtual PC）。</p><p>Virtual PC是而向桌面的虚拟化产品，最早由Connectix公司开发，后来该产品被微软公司收购。Virtual PC是基于宿主模型的虚拟机产品，宿主机操作系统是Windows。早期版本也采用软件虚拟化方式，基于Binary Translation技术。之后版本已经支持硬件虚拟化技术。</p><p>Windows Server 2008是微软推出的服务器操作系统，其中一项重要的新功能是虚拟化功能。其虚拟化架构采用的是混合模型，重要组件之一Hyper-V作为Hypervisor运行在最底层，Server 2008本身作为特权操作系统运行在Hyper-V之上。Server 2008采用硬件虚拟化技术，必须运行在支持Intel VT技术或者AMD-V 技术的处理器上。</p><h4 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h4><p>Xen是一款基于GPL授权方式的开源虚拟机软件。Xen起源于英国剑桥大学Ian Pratt领导的一个研究项目，之后，Xen独立出来成为一个社区驱动的开源软件项目。Xen社区吸引了许多公司和科研院所的开发者加入，发展非常迅速。之后，Ian成立了XenSource公司进行Xen的商业化应用，并且推出了基于Xen的产品Xen Server。2007年，Ctrix公司收购了XenSource公司，继续推广Xen的商业化应用，Xen开源项目本身则被独立到<a href="http://www.xen.org./">www.xen.org。</a></p><p>从技术角度来说，Xen基于混合模型，特权操作系统（ 在Xen中称作Domain 0）可以是Linux、Solaris以及NetBSD，理论上，其他操作系统也可以移植作为Xen的特权操作系统。Xen最初的虚拟化思路是类虚拟化，通过修改Linux内核，实现处理器和内存的虚拟化，通过引入I&#x2F;O的前端驱动&#x2F;后端驱动（front &#x2F; backend）架构实现设备的类虚拟化。之后也支持了完全虚拟化和硬件虚拟化技术。</p><h4 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h4><p>KVM（Kernel-based Virtual Machine）也是一款基于GPL授权方式的开源虚拟机软件。KVM 最早由Qumranet公司开发，在2006年出现在Linux内核的邮件列表上，并于2007年被集成到了Linux 2.6.20内核中，成为内核的一部分。</p><p>KVM支持硬件虚拟化方法，并结合QEMU来提供设备虚拟化。KVM的特点在于和Linux内核结合得非常好，而且和Xen一样，作为开源软件，KVM的移植性也很好。</p><h4 id="Oracle-VM-VirtualBox"><a href="#Oracle-VM-VirtualBox" class="headerlink" title="Oracle VM VirtualBox"></a>Oracle VM VirtualBox</h4><p>VirtualBox是一款开源虚拟机软件，类似于VMware Workstation。VirtualBox 是由德国Innotek公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle 收购后正式更名成 Oracle VM VirtualBox。Innotek 以 GNU General Public License (GPL) 释出 VirtualBox。用户可以在VirtualBox上安装并且执行Solaris、Windows、DOS、Linux、BSD等系统作为客户端操作系统。现在由甲骨文公司进行开发，是甲骨文公司VM虚拟化平台技术的一部分。</p><h4 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h4><p>Bochs 是一个 x86 计算机仿真器，它在很多平台上（包括 x86、PowerPC、Alpha、SPARC 和 MIPS）都可以移植和运行。使 Bochs 不仅可以对处理器进行仿真，还可以对整个计算机进行仿真，包括计算机的外围设备，比如键盘、鼠标、视频图像硬件、网卡（NIC）等。</p><p>Bochs 可以配置作为一个老式的 Intel® 386 或其后继处理器使用，例如 486、Pentium、Pentium Pro 或 64 位处理器。它甚至还可以对一些可选的图形指令进行仿真，例如 MMX 和 3DNow。</p><h4 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h4><p>QEMU是一套由Fabrice Bellard所编写的模拟处理器的自由软件。它与Bochs，PearPC近似，但其具有某些后两者所不具备的特性，如高速度及跨平台的特性，qemu可以虚拟出不同架构的虚拟机，如在x86平台上可以虚拟出power机器。kqemu为qemu的加速器，经由kqemu这个开源的加速器，QEMU能模拟至接近真实电脑的速度。</p><p>QEMU本身可以不依赖于KVM，但是如果有 KVM的存在并且硬件(处理器)支持比如Intel VT功能，那么QEMU在对处理器虚拟化这一块可以利用KVM提供的功能来提升性能。换言之，KVM缺乏设备虚拟化以及相应的用户空间管理虚拟机的工具，所以它借用了QEMU的代码并加以精简，连同KVM一起构成了一个完整的虚拟化解决方案，不妨称之为：KVM+QEMU。</p><h3 id="操作系统级虚拟化实现"><a href="#操作系统级虚拟化实现" class="headerlink" title="操作系统级虚拟化实现"></a>操作系统级虚拟化实现</h3><h4 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h4><p>容器的概念始于 1979 年的 UNIX chroot，它是一个 UNIX 操作系统上的系统调用，用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到该目录。这个功能的想法是为每个进程提供独立的磁盘空间。其后在 1982年，它被加入到了 BSD 系统中。</p><h4 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h4><p>LXC 的意思是 LinuX Containers，它是第一个最完善的 Linux 容器管理器的实现方案，是通过 cgroups 和 Linux 名字空间namespace实现的。LXC 存在于 liblxc 库中，提供了各种编程语言的 API 实现，包括 Python3、Python2、Lua、Go、Ruby 和 Haskell 等。与其它容器技术不同的是， LXC 可以工作在普通的 Linux 内核上，而不需要增加补丁。现在 LXC project 是由 Canonical 公司赞助并托管的。</p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>Docker 是到现在为止最流行和使用广泛的容器管理系统。它最初是一个叫做 dotCloud 的 PaaS 服务公司的内部项目，后来该公司改名为 Docker。Docker 开始阶段使用的也是 LXC ，之后采用自己开发的 libcontainer 替代了它。不像其它的容器平台，Docker 引入了一整个管理容器的生态系统，这包括高效、分层的容器镜像模型、全局和本地的容器注册库、清晰的 REST API、命令行等等。稍后的阶段， Docker 推动实现了一个叫做 Docker Swarm 的容器集群管理方案。</p><h4 id="Linux-VServer"><a href="#Linux-VServer" class="headerlink" title="Linux VServer"></a>Linux VServer</h4><p>Linux-VServer 也是一个操作系统级虚拟化解决方案。Linux-VServer 对 Linux 内核进行虚拟化，这样多个用户空间环境—又称为 Virtual Private Server（VPS） 就可以单独运行，而不需要互相了解。Linux-VServer 通过修改 Linux 内核实现用户空间的隔离。</p><p>Linux-VServer 也使用了 chroot 来为每个 VPS 隔离 root 目录。虽然 chroot 允许指定新 root 目录，但还是需要其他一些功能（称为 Chroot-Barrier）来限制 VPS 脱离其隔离的 root 目录回到上级目录。给定一个隔离的 root 目录之后，每个 VPS 就可以拥有自己的用户列表和 root 密码。</p><p>2.4 和 2.6 版本的 Linux 内核支持 Linux-VServer，它可以运行于很多平台之上，包括 x86、x86-64、SPARC、MIPS、ARM 和 PowerPC。</p><h4 id="Virtuozzo-x2F-OpenVZ"><a href="#Virtuozzo-x2F-OpenVZ" class="headerlink" title="Virtuozzo&#x2F;OpenVZ"></a>Virtuozzo&#x2F;OpenVZ</h4><p>Virtuozzo是SWsoft公司（目前SWsoft已经改名为Parallels）的操作系统虚拟化软件的命名，Virtuozzo是商业解决方案，而OpenVZ是以Virtuozzo为基础的开源项目，它们采用的也是操作系统级虚拟化技术。OpenVZ 类似于 Linux-VServer，它通过对 Linux 内核进行补丁来提供虚拟化、隔离、资源管理和状态检查。每个 OpenVZ 容器都有一套隔离的文件系统、用户及用户组等。</p><p><em>参考文献</em></p><ul><li>1 ] 金海, 廖小飞. 面向计算系统的虚拟化技术J]. 中国基础科学, 2008, 10(6):12-18.</li><li>2 ] 英特尔开源软件技术中心. 系统虚拟化M]. 清华大学出版社, 2009.</li><li>3 ] GeorgeCoulouris, 库鲁里斯, 金蓓弘,等. 分布式系统:分布式系统概念与设计M]. 机械工业出版社, 2013</li><li>4 ] Andrew S. Tanenbaum, Maarten van Steen. 分布式系统原理与范型M]. 清华大学出版社, 2004.</li><li>5 ] Barham P, Dragovic B, Fraser K, et al. Virtual machine monitors: Xen and the art of virtualizationJ]. Symposium on Operating System Principles, 2003, 36(August):164–177.</li><li>6 ] Qumranet A K, Qumranet Y K, Qumranet D L, et al. kvm: the Linux virtual machine monitorJ]. Proc Linux Symposium, 2007.</li><li>7 ] Adams K, Agesen O. A comparison of software and hardware techniques for x86 virtualizationC]&#x2F;&#x2F; ACM, 2006:2-13.</li><li>8 ] Uhlig R, Neiger G, Rodgers D, et al. Intel virtualization technologyJ]. Computer, 2005, 38(5):48-56.</li><li>9 ] Garfinkel T, Rosenblum M. A Virtual Machine Introspection Based Architecture for Intrusion DetectionJ]. Proceedings of the Network &amp; Distributed Systems Security Symposium, 2003:191–206.</li></ul><p><strong>参考资料</strong><br><a href="https://blog.csdn.net/mumuriyue/article/details/85714900">虚拟化技术的分类及介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>Hypervisor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hypervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟化技术</title>
    <link href="/2022/08/10/what-is-a-hypervisor/"/>
    <url>/2022/08/10/what-is-a-hypervisor/</url>
    
    <content type="html"><![CDATA[<p>Hypervisor是所有虚拟化技术的核心。</p><span id="more"></span><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>虚拟化技术源于提升计算机硬件资源使用效率的需求，发展出了Xen、KVM等众多硬件虚拟化方式的虚拟机技术、以Docker容器为代表的软件虚拟化技术，虚拟化技术实质上在不同层级上对于计算机的软硬件资源进行了模拟封装，使得这些资源可按需分配、配置和调度，也为云计算的发展奠定了坚实的基础，甚至可以说没有虚拟化技术的发展就没有云计算发展。</p><p>“虚拟化”的概念最早于1959年6月提出，牛津大学的计算机教授克里斯·托弗在国际信息处理大会上发表了一篇名为《大型高速计算机中的时间共享》的学术报告，文中首次提出了 “虚拟化” 的基本概念，并论述了什么是虚拟化技术。上个世纪60年代，IBM公司最先进行了虚拟化技术的实践探索，发明了一种操作系统虚拟机技术，允许用户在一台主机上运行多个操作系统，让用户尽可能地充分利用昂贵的大型机资源。最初主要运用于大型服务器上，但随着硬件技术突飞猛进的发展，普通PC的性能越来越强，也可用来运行虚拟机，构建云服务平台。</p><h4 id="常用的虚拟化技术有这些"><a href="#常用的虚拟化技术有这些" class="headerlink" title="常用的虚拟化技术有这些"></a>常用的虚拟化技术有这些</h4><ul><li>微软的Hyper-V</li><li>Linux中的KVM，XEN</li><li>VMware的ESXI</li><li>Docker</li></ul><p>虚拟化包含多个层面，比如硬件虚拟化，这种虚拟化从底层的硬件平台直接支持软件环境；另外一种是操作系统虚拟化，这是Linux的一个亮点。</p><p>在硬件层之上，独立于操作系统的一层软件被称之为hypervisor，或者叫做虚拟机监视器。hypervisor创建了虚拟化平台，而操作系统实例则运行在这个平台上，这使得硬件平台可以被多个操作系统和应用所共享，从而降低硬件的成本。<br>运行在hypervisor上面的实体被称为虚拟机，即VM，是用来放置操作系统、应用和数据元的“容器”。虚拟机中的操作系统和应用程序的数据被存储在虚拟磁盘中，hypervisor利用虚拟磁盘来启动虚拟化平台。虚拟机被封装为一个文件，这样比分布式的文件更好管理。</p><h4 id="虚拟机：虚拟化硬件"><a href="#虚拟机：虚拟化硬件" class="headerlink" title="虚拟机：虚拟化硬件"></a>虚拟机：虚拟化硬件</h4><p>虚拟机 Virtual Machine 指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。</p><p>在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。在容器技术之前，业界的网红是虚拟机。</p><p>虚拟机技术的代表，是 VMWare 和 OpenStack。</p><h4 id="容器：将操作系统层虚拟化，是一个标准的软件单元"><a href="#容器：将操作系统层虚拟化，是一个标准的软件单元" class="headerlink" title="容器：将操作系统层虚拟化，是一个标准的软件单元"></a>容器：将操作系统层虚拟化，是一个标准的软件单元</h4><ul><li><p>随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。</p></li><li><p>高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置 CPU 和内存的使用率，进而更好地利用服务器的计算资源。</p></li><li><p>快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。</p></li></ul><table><thead><tr><th>特性</th><th align="center">虚拟机</th><th align="center">容器</th></tr></thead><tbody><tr><td>隔离级别</td><td align="center">操作系统级</td><td align="center">进程</td></tr><tr><td>隔离策略</td><td align="center"><a href="https://baike.baidu.com/item/hypervisor/3353492?fr=aladdin">Hypervisor</a>（虚拟机监控器）</td><td align="center"><a href="https://baike.baidu.com/item/Cgroup/4988200?fr=aladdin">Cgroups</a>（控制组群）</td></tr><tr><td>系统资源</td><td align="center">5 ～ 15%</td><td align="center">0 ～ 5%</td></tr><tr><td>启动时间</td><td align="center">分钟级</td><td align="center">秒级</td></tr><tr><td>镜像存储</td><td align="center">GB - TB</td><td align="center">KB - MB</td></tr><tr><td>集群规模</td><td align="center">上百</td><td align="center">上万</td></tr><tr><td>高可用策略</td><td align="center">备份、容灾、迁移</td><td align="center">弹性、负载、动态</td></tr></tbody></table><p><strong>参考资料</strong><br><a href="https://www.ibm.com/cn-zh/topics/hypervisors?mhsrc=ibmsearch_a&mhq=hypervisor">IBM 虚拟机管理器</a><br><a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">RedHat 什么是虚拟机监控程序</a></p>]]></content>
    
    
    <categories>
      
      <category>Hypervisor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hypervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE 到底是什么</title>
    <link href="/2022/08/07/What-is-SRE/"/>
    <url>/2022/08/07/What-is-SRE/</url>
    
    <content type="html"><![CDATA[<p>什么是 SRE？SRE 需要具备什么能力？</p><span id="more"></span><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>SRE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算概论</title>
    <link href="/2022/08/06/Introduction-to-Cloud-Computing/"/>
    <url>/2022/08/06/Introduction-to-Cloud-Computing/</url>
    
    <content type="html"><![CDATA[<p>关于云计算基本特征、部署模型和服务模型</p><span id="more"></span><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p>让我们首先了解云的五个基本特征，包括按需自助服务、广泛的网络访问、资源池、快速弹性和可度量的服务。</p><p><strong>按需自助服务（On-demand Self-service）：</strong> 用户可以使用简单的界面访问云资源，如处理能力、存储和网络，而无需与每个服务提供商进行人工交互。</p><p><strong>广泛的网络访问（Broad Network Access）：</strong> 可以通过标准机制和平台（如手机、平板电脑、笔记本电脑和工作站）通过网络访问云计算资源。</p><p><strong>资源池（Resource Pooling）：</strong> 云提供商的规模经济，他们将其传递给客户，使云具有成本效益。使用多租户模型，将计算资源集中起来为多个消费者提供服务；云资源是根据需求动态分配和重新分配的，而客户无需关心这些资源的物理位置。</p><p><strong>快速弹性（Rapid Elasticity）：</strong> 用户可以在需要的时候访问更多的资源，在不需要的时候缩小规模，因为资源是弹性供应和释放的。</p><p><strong>可度量的服务（Measured Service）：</strong> 用户只为其使用或预订的东西付费。如果用户不使用资源，就不会付钱。根据利用率透明地监控、测量和报告资源使用情况。</p><h3 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h3><p><strong>Public Cloud：公共云</strong> 云服务提供商通过公共网络向用户提供云服务，用户可以根据自己的需求随时使用或释放资源。<br><strong>Private Cloud：私有云</strong> 云服务提供商在企业内部或数据中心中提供云服务，仅对内部员工或合作伙伴提供服务。<br><strong>Hybrid Cloud：混合云</strong> 结合了公有云和私有云的特点，使用户可以在公有云和私有云之间移动工作负载和数据。<br><strong>Community Cloud：社区云</strong> 特定的组织或行业提供的云服务，仅面向该组织或行业的成员。<br><strong>Multi-cloud：多云</strong> 同时采用两个或多个不同的云服务提供商，以获取更好的性能、可靠性、安全性和成本控制等方面的优势。<br><strong>Edge computing 边缘计算</strong> 在边缘设备上进行数据处理和存储，以减少数据传输和响应时间，提高应用程序性能。</p><h3 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h3><p><strong>Infrastructure as a Service (IaaS)：基础设施即服务</strong> 提供基础设施服务，例如虚拟机、存储、网络等。<br><strong>Platform as a Service (PaaS)：平台即服务</strong> 提供完整的应用程序开发和部署平台，包括开发、测试、部署和管理工具等。<br><strong>Software as a Service (SaaS)：软件即服务</strong> 提供基于云的应用程序服务，例如邮件、协作、客户关系管理等。<br><strong>Function as a Service (FaaS)：函数即服务</strong> 以事件驱动的方式提供计算服务，例如无服务器计算、事件处理等。<br><strong>Backend as a Service (BaaS)：后端即服务</strong> 提供云端的后端服务，例如数据库、身份认证、通知、存储等。<br><strong>Data as a Service (DaaS)：数据即服务</strong> 提供数据访问和分析服务，例如数据挖掘、数据分析、数据可视化等。<br><strong>Machine as a Service (MaaS)：机器即服务</strong> 提供物联网设备租赁或购买服务，例如传感器、智能家居设备等。<br><strong>Gaming as a Service (GaaS)：游戏即服务</strong> 提供云游戏服务，例如流媒体游戏、云端游戏服务器等。<br><strong>Container as a Service (CaaS)：容器即服务</strong> 提供容器管理平台，快速部署、运行和管理容器化应用程序。<br><strong>Anything as a Service (XaaS)：任何事物即服务</strong> 广义的术语，包括所有可以作为服务提供的事物，例如网络安全服务、身份认证服务、API管理服务等。</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Computing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算（Cloud Computing）</title>
    <link href="/2022/08/05/Cloud-Computing/"/>
    <url>/2022/08/05/Cloud-Computing/</url>
    
    <content type="html"><![CDATA[<p>关于云计算（Cloud Computing） 看懂云计算、虚拟化和容器，这一篇就够啦！</p><span id="more"></span><h2 id="云计算这个词，相信大家都非常熟悉了。"><a href="#云计算这个词，相信大家都非常熟悉了。" class="headerlink" title="云计算这个词，相信大家都非常熟悉了。"></a>云计算这个词，相信大家都非常熟悉了。</h2><p>云计算的准确定义，有比较多的先驱定义过，具体如下：</p><p><strong>Gartner公司</strong>将云计算定义为：「一种计算方式，能够通过Internet技术将可扩展的和弹性的IT能力作为服务交付给外部用户。」</p><p><strong>Forrester Research公司</strong>，将云计算定义为：「一种标准化的IT性能（服务，软件或者基础设施），以按使用付费和自助服务方式，通过Internet技术进行交付。」</p><p><strong>NIST（美国国家标准和技术研究院）</strong>，将云计算定义为：「云计算是一种模型，可以随时随地，便捷地，按需地从可配置计算资源共享池中获取所需的资源（例如，网络，服务器，存储，应用程序及服务），资源可以快速供给和释放，使管理的工作量和服务提供者的介入降低至最少。这种云模型，包括五个基本特征，三种服务模型和四种部署模型。」</p><p>“云计算”这个词，相信大家都非常熟悉。</p><p>作为信息科技发展的主流趋势，它频繁地出现在我们的眼前。伴随它一起出现的，还有这些概念名词——OpenStack、Hypervisor、KVM、Docker、K8S…</p><center><img src="https://img.darklorder.com/img/202305112240666.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这些名词概念，全部都属于云计算技术领域的范畴。</p><p>对于初学者来说，理解这些概念的具体含义并不是一件容易的事情。</p><p>所以，今天这篇文章，将给大家做一个通俗易懂的介绍，解释这些云计算概念以及它们之间的关系，希望对大家入门有所帮助。</p><h3 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h3><p>在介绍那些古怪名词之前，我先介绍一下<strong>云计算。</strong></p><p>以前电脑被发明的时候，还没有网络，每个电脑（PC），就是一个单机。</p><center><img src="https://img.darklorder.com/img/202305112242464.jpg"  alt="文件名" style="zoom:50%;" /></center><p>这台单机，包括CPU、内存、硬盘、显卡等硬件。用户在单机上，安装操作系统和应用软件，完成自己的工作。</p><p>后来，有了<strong>网络（Network），</strong>单机与单机之间，可以交换信息，协同工作。</p><center><img src="https://img.darklorder.com/img/202305112243322.jpg"  alt="文件名" style="zoom:50%;" /></center><p>再后来，单机性能越来越强，就有了<strong>服务器（Server）。</strong>人们发现，可以把一些服务器集中起来，放在机房里，然后让用户通过网络，去访问和使用机房里的计算机资源。</p><center><img src="https://img.darklorder.com/img/202305112243607.jpg"  alt="文件名" style="zoom:50%;" /></center><p>再再后来，小型网络变成了大型网络，就有了<strong>互联网（Internet）。</strong>小型机房变成了大型机房，就有了<strong>IDC（Internet Data Center，互联网数据中心）。</strong></p><p>当越来越多的计算机资源和应用服务（Application，例如看网页，下电影）被集中起来，就变成了——<strong>“云计算（Cloud Computing）”。</strong>无数的大型机房，就成了“云端”。</p><center><img src="https://img.darklorder.com/img/202305112244542.jpg"  alt="文件名" style="zoom:50%;" /></center><p>是不是觉得太简单？别急，开始深入。</p><p>云计算的道理是简单的，说白了，就是把计算机资源集中起来，放在网络上。但是，云计算的实现方式，就非常复杂了。</p><p>举个例子，如果你只是在公司小机房摆了一个服务器，开个FTP下载服务，然后用于几个同事之间的电影分享，当然是很简单的。</p><p>如果是“双11”的淘宝购物节，全球几十亿用户访问阿里巴巴的淘宝网站，单日几十<strong>PB（1PB&#x3D;1024TB&#x3D;1024×1024GB）</strong>的访问量，每秒几百<strong>GB</strong>的流量……这个，就不是几根网线几台服务器能解决的了。</p><p>这时，需要设计一个<strong>超大容量、超高并发（同时访问）、超快速度、超强安全</strong>的云计算系统，才能满足业务平稳运行的要求。</p><p>这才是云计算的复杂之处。</p><p>刚才说了，我们把计算机资源放在云端。这个计算机资源，实际上分为好几种层次：</p><p><strong>第一层次，</strong>是最底层的硬件资源，主要包括CPU（计算资源），硬盘（存储资源），还有网卡（网络资源）等。</p><p><strong>第二层次，</strong>要高级一些，我不打算直接使用CPU、硬盘、网卡，我希望你把操作系统（例如Windows、Linux）装好，把数据库软件装好，我再来使用。</p><p><strong>第三层次，</strong>更高级一些，你不但要装好操作系统这些基本的，还要把具体的应用软件装好，例如FTP服务端软件、在线视频服务端软件等，我可以直接使用服务。</p><p>这三种层次，就是大家经常听到的<strong>IaaS、Paas、SaaS。</strong></p><center><img src="https://img.darklorder.com/img/202305112246787.jpg"  alt="文件名" style="zoom:50%;" /></center><p>SaaS: Software-as-a-Service（软件即服务）<br>PaaS: Platform-as-a-Service（平台即服务）<br>IaaS: Infrastructure-as-a-Service（基础设施即服务）</p><p>再补一张图，可能更直观：</p><center><img src="https://img.darklorder.com/img/202305112246104.jpg"  alt="文件名" style="zoom:50%;" /></center><p>目前主流的云计算服务提供商，例如亚马逊AWS、阿里云、华为云、天翼云、腾讯云，说白了，都是为大家提供以上三个层次的云资源。你想要什么，它们就提供什么。你想要多少，它们就提供多少。</p><center><img src="https://img.darklorder.com/img/202305112247813.jpg"  alt="文件名" style="zoom:50%;" /></center><p>继续，继续。</p><p>这么多样化多层次的云计算服务，阿里、华为们又是怎么提供的呢？</p><p>难道说，是人工安排？——</p><p>如果你要八核CPU、16GB内存、500GB硬盘的服务器，阿里临时安排工程师帮你组装？如果你要装CentOS 7.2（一种类Linux操作系统），MySQL 5.5.60（一种数据库系统），阿里也临时让工程师帮你安装配置？</p><p>这显然是不可能的，耗不起人力，也等不起时间。</p><p><strong>于是，就有了各种软件和平台，负责对资源进行快速调用和集中管理。</strong></p><h3 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h3><p>如果要对物理资源进行管理，第一步，就是<strong>“虚拟化”。</strong></p><p>虚拟化是云计算的基础。简单来说，虚拟化就是在一台物理服务器上，运行多台“虚拟服务器”。这种虚拟服务器，也叫<strong>虚拟机（VM，Virtual Machine）。</strong></p><p>从表面来看，这些虚拟机都是独立的服务器，但实际上，它们共享物理服务器的CPU、内存、硬件、网卡等资源。</p><center><img src="https://img.darklorder.com/img/202305112248949.png"  alt="文件名" style="zoom:50%;" /></center><p>物理机，通常称为“宿主机（Host）”。虚拟机，则称为“客户机（Guest）”。</p><p>谁来完成物理资源虚拟化的工作呢？</p><p>就是大名鼎鼎的 <strong>Hypervisor 。</strong></p><p>Hypervisor，汉译过来是“超级监督者”，也叫做VMM（Virtual Machine Monitor，虚拟机监视器）。它不是一款具体的软件，而是一类软件的统称。</p><p>Hypervisor分为两大类：</p><p>第一类，hypervisor直接运行在物理机之上。虚拟机运行在hypervisor之上。第二类，物理机上安装正常的操作系统（例如Linux或Windows），然后在正常操作系统上安装hypervisor，生成和管理虚拟机。</p><center><img src="https://img.darklorder.com/img/202305112249807.jpg"  alt="文件名" style="zoom:50%;" /></center><p>像<strong>VMware、KVM、Xen、Virtual Box，</strong>都属于Hypervisor。</p><p>VMware大家应该很熟悉，就是VMware Workstation。学习Linux的话，很多人都是在windows系统下安装WMware，然后创建Linux虚拟机。</p><center><img src="https://img.darklorder.com/img/202305112250795.jpg"  alt="文件名" style="zoom:50%;" /></center><p>但是，真正厉害的，是但是，真正厉害的，是 <strong>KVM（kernel-based virtual machine，基于Linux内核的虚拟机）。</strong>它是目前最热门最受追捧的虚拟化方案。</p><center><img src="https://img.darklorder.com/img/202305112251358.jpg"  alt="文件名" style="zoom:50%;" /></center><p>KVM这样的Hypervisor软件，实际上是提供了一种虚拟化能力，模拟CPU的运行，更为底层。但是它的用户交互并不良好，不方便使用。</p><p>于是，为了更好地管理虚拟机，就需要OpenStack这样的云管理平台。</p><center><img src="https://img.darklorder.com/img/202305112252953.jpg"  alt="文件名" style="zoom:50%;" /></center><p>关于OpenStack，我之前曾经介绍过（<a href="https://mp.weixin.qq.com/s?__biz=MzI1NTA0MDUyMA==&mid=2456660029&idx=1&sn=1a900a0c45ff77355693e7902c3d8f38&chksm=fda5055acad28c4c34d015b72843ef14c5529f81651cf38daddd1ce4d7e595c9f937f1ee3327&scene=21#wechat_redirect">链接</a>）。它有点像个商店，负责管理商品（计算资源、存储资源、网络资源等），卖给用户，但它本身不制造商品（不具备虚拟化能力），它的商品，来自于KVM。当然，如果不用KVM，也可以用Xen等其它hypervisor。</p><center><img src="https://img.darklorder.com/img/202305112252467.jpg"  alt="文件名" style="zoom:50%;" /></center><p>OpenStack的管理界面，比命令行好多了吧？</p><p>请记住，上面所说的几个概念，包括VM、KVM、OpenStack等，都主要属于IaaS（基础设施即服务）。这个不难理解吧？</p><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>继续往下说。</p><p>那么，容器是什么呢？大佬们经常说的Docker和K8S，又是什么呢？</p><p>前面我们介绍了虚拟化。人们在使用虚拟化一段时间后，发现它存在一些问题：</p><p>不同的用户，有时候只是希望运行各自的一些简单程序，跑一个小进程。为了不相互影响，就要建立虚拟机。如果建虚拟机，显然浪费就会有点大，而且操作也比较复杂，花费时间也会比较长。</p><p>而且，有的时候，想要迁移自己的服务程序，就要迁移整个虚拟机。显然，迁移过程也会很复杂。</p><p>有没有办法<strong>更灵活快速一</strong>些呢？</p><p>有，这就引入了<strong>“容器（Container）”。</strong></p><p>容器也是虚拟化，但是属于“轻量级”的虚拟化。它的目的和虚拟机一样，都是为了创造“隔离环境”。但是，它又和虚拟机有很大的不同——虚拟机是操作系统级别的资源隔离，而容器本质上是进程级的资源隔离。</p><center><img src="https://img.darklorder.com/img/202305112253652.jpg"  alt="文件名" style="zoom:50%;" /></center><p>虚拟化 VS 容器</p><p>而大家常听说的<strong>Docker，</strong>就是创建容器的工具，是应用容器引擎。</p><p>Docker的中文意思，就是码头工人。而它的LOGO，就是一只鲸鱼背着很多货柜箱。</p><center><img src="https://img.darklorder.com/img/202305112254729.jpg"  alt="文件名" style="zoom:50%;" /></center><p>相比于传统的虚拟机，Docker的优势很明显，它启动时间很快，是秒级，而且对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB，而容器只需要MB级甚至KB级。</p><center><img src="https://img.darklorder.com/img/202305112254245.jpg"  alt="文件名" style="zoom:50%;" /></center><p>除了Docker对容器进行创建之外，我们还需要一个工具，对容器进行<strong>编排。</strong></p><p>这个工具，就是<strong>K8S。</strong></p><p><strong>K8S，</strong>就是<strong>Kubernetes，</strong>中文意思是舵手或导航员。Kubernetes这个单词很长，所以大家把中间8个字母缩写成8，就成了K8S。</p><center><img src="https://img.darklorder.com/img/202305112255615.jpg"  alt="文件名" style="zoom:50%;" /></center><p>K8S是一个容器集群管理系统，主要职责是<strong>容器编排（Container Orchestration）</strong>——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。</p><p>简单来说，K8S有点像容器的保姆。它负责管理容器在哪个机器上运行，监控容器是否存在问题，控制容器和外界的通信，等等。</p><p>通过下面这张K8S系统结构图，就能够看出K8S和容器之间的关系。</p><center><img src="https://img.darklorder.com/img/202305112255372.jpg"  alt="文件名" style="zoom:80%;" /></center><p>除了K8S之外，还有很多种容器管理平台，例如<strong>Compose，Marathon，Swarm，Mesos</strong>等。</p><p>Docker和K8S，关注的不再是基础设施和物理资源，而是应用层，所以，就属于PaaS。明白了吧？</p><p>好啦，今天就先到这里了。再说下去，估计很多人又要晕啦。</p><p>正如文章开头所说，今天主要是介绍KVM、Hypervisor、OpenStack、Docker、K8S这些名词的意思，它们在云计算系统中的位置，以及它们之间的关系。云计算涉及到大量的需求。同一个需求，会有很多不同的技术来实现。同一个技术，往往又有多个不同的厂家互相竞争。所以，概念和名词就会特别多，发展变化也会很快。</p><p>不管怎么说，梳理清楚最关键的名词概念，是学好云计算的第一步。</p><p><strong>参考资料</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NTA0MDUyMA==&mid=2456665252&idx=1&sn=365da9095c9a1ed46886eab43b5bc003&chksm=fda511c3cad298d5679642973577a7380ad050fddc15fde6c5bd81f354aacc787fb9ee86bb7f&scene=21#wechat_redirect">看懂云计算、虚拟化和容器，这一篇就够啦！鲜枣课堂-作者小枣君</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Computing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloud Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>千万不要陷入“自证陷阱”</title>
    <link href="/2022/08/01/Self-certification-trap/"/>
    <url>/2022/08/01/Self-certification-trap/</url>
    
    <content type="html"><![CDATA[<p>如果有人冤枉你吃了他的东西，你不要剖开自己的肚子以证清白，应该挖出他的眼睛咽下去，让他在你肚子里，看看清楚。–《反击》</p><img src="https://img.darklorder.com/img/202308030445256.gif" style="zoom: 50%;"/><blockquote><p>看到这句话有些触动想到了《让子弹飞》里的六子，为了证明自己只吃了一碗粉而刨开肚子</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>丛林法则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writing Article</title>
    <link href="/2022/07/31/writing/"/>
    <url>/2022/07/31/writing/</url>
    
    <content type="html"><![CDATA[<p>写作</p><span id="more"></span><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><ul><li>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p><table><thead><tr><th align="center">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="left">source&#x2F;_posts</td></tr><tr><td align="center">page</td><td align="left">source</td></tr><tr><td align="center">draft</td><td align="left">source&#x2F;_drafts</td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source&#x2F;_drafts 文件夹，您可通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><ul><li>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</li></ul><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是文件最上方以 —— 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>title: Hello World<br><span class="hljs-built_in">date</span>: 2022-07-24 00:00:00<br>---<br></code></pre></td></tr></table></figure><ul><li>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="left"></td></tr><tr><td align="left"><code>lang</code></td><td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="left">Inherited from <code>_config.yml</code></td></tr></tbody></table><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">删除文件夹<span class="hljs-built_in">source</span>/_posts下目标文章markdown文件<br>删除.deploy_git文件夹<br>执行hexo cl 后，再执行 hexo g ，hexo s 即可。<br></code></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>创建 分类 页并添加 tpye 属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page categories<br></code></pre></td></tr></table></figure><p>source&#x2F;categories&#x2F;index.md 添加 categories 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: categories<br>date: 2022-07-24 00:00:00<br><span class="hljs-section">type: &quot;categories&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>给文章添加 categories 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: 写作<br>date: 2022-07-31 00:00:00<br>categories:<br><span class="hljs-section">- Hello World</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>打开需要添加分类的文章，为其添加categories属性。</li><li>下方的categories: Hello World 表示添加这篇文章到 Hello World 这个分类。</li><li>注意：hexo一篇文章只能属于一个分类，也就是说如果在 “- Hello World” 下方添加 “-xxx”，hexo不会产生两个分类，</li><li>而是把分类嵌套（即该文章属于 “- Hello World” 下的 “-xxx” 分类）。</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>创建 标签 页并添加 tpye 属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page tags<br></code></pre></td></tr></table></figure><p>source&#x2F;tags&#x2F;index.md 添加 tags 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: tags<br>date: 2022-07-24 00:00:00<br><span class="hljs-section">type: &quot;tags&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>给文章添加 tags 属性</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md">---<br>title: 写作<br>date: 2022-07-25 00:00:00<br>categories:<br><span class="hljs-bullet">-</span> Hello World<br>tags:<br><span class="hljs-bullet">-</span> Hello <br><span class="hljs-section">- World</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- Hello - World 就是这篇文章的标签了</li><li>至此，成功给文章添加分类，点击首页的 “标签” 可以看到该标签下的所有文章。</li><li>当然，只有添加了tags: xxx的文章才会被收录到首页的 “标签” 中。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>出身重要还是后天努力重要？</title>
    <link href="/2022/07/25/Origin-or-hard-work/"/>
    <url>/2022/07/25/Origin-or-hard-work/</url>
    
    <content type="html"><![CDATA[<p>我始终觉得，天生的出身很重要，但后天的努力更加重要，所以如今的很多“科班”往往不如后天努力的“非科班”。所以，我们需要重新给“专业”和“专家”下一个定义：所谓专业，就是别人不搞你搞，这就是你的“专业”;你和别人同时搞，你比别人搞的好，就是“专家”。</p><p><strong>源于网络</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/24/hello-world/"/>
    <url>/2022/07/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>用户手册</p><span id="more"></span><h2 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a>用户手册</h2><h3 id="自动更新主题"><a href="#自动更新主题" class="headerlink" title="自动更新主题"></a>自动更新主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm update            <span class="hljs-comment">#  更新所有</span><br>$ npm update --save hexo-theme-fluid            <span class="hljs-comment"># 更新主题</span><br></code></pre></td></tr></table></figure><h3 id="手动更新主题"><a href="#手动更新主题" class="headerlink" title="手动更新主题"></a>手动更新主题</h3><p>修改根目录的package.json文件，将对应插件名称所对应的版本号更改为要更新的版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm <span class="hljs-built_in">ls</span>            <span class="hljs-comment"># 查询当前项目已安装插件版本</span><br>$ npm install --save            <span class="hljs-comment"># 更新</span><br></code></pre></td></tr></table></figure><h3 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean            <span class="hljs-comment"># 清理缓存 clean</span><br>$ hexo generate         <span class="hljs-comment"># 构建 build</span><br>$ hexo server           <span class="hljs-comment"># 本地启动 server</span><br>$ hexo deploy           <span class="hljs-comment"># 自动部署 deploy</span><br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&quot;博客配置&quot;</span> <span class="hljs-string">指的是</span> <span class="hljs-string">根目录下的</span> <span class="hljs-string">_config.yml</span><br><span class="hljs-string">&quot;主题配置&quot;</span> <span class="hljs-string">指的是</span> <span class="hljs-string">theme/fluid/_config.yml</span><br></code></pre></td></tr></table></figure><h3 id="顶部大图"><a href="#顶部大图" class="headerlink" title="顶部大图"></a>顶部大图</h3><p>主题配置中，每个页面都有名为 banner_img 的属性，可以使用本地图片的相对路径，也可以为外站链接。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml">  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span>          <span class="hljs-comment"># 对应存放在 /source/img/default.png</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://xxxx.com/img/default.png</span><br>  <br><span class="hljs-comment"># 高度</span><br>  <span class="hljs-string">鉴于每个人的喜好不同，开放对页面</span> <span class="hljs-string">banner_img</span> <span class="hljs-string">高度的控制。</span><br>  <span class="hljs-string">主题配置中，每个页面对应的</span> <span class="hljs-string">banner_img_height</span> <span class="hljs-string">属性，有效值为</span> <span class="hljs-number">0</span> <span class="hljs-bullet">-</span> <span class="hljs-number">100</span><span class="hljs-string">。100</span> <span class="hljs-string">即为全屏，个人建议</span> <span class="hljs-number">70</span> <span class="hljs-string">以上。</span><br><span class="hljs-comment"># 蒙版透明度</span><br>  <span class="hljs-string">主题配置中，每个页面对应的</span> <span class="hljs-string">banner_mask_alpha</span> <span class="hljs-string">属性，有效值为</span> <span class="hljs-number">0</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1.0</span><span class="hljs-string">，</span> <span class="hljs-number">0</span> <span class="hljs-string">是完全透明（无蒙版），1</span> <span class="hljs-string">是完全不透明</span><br></code></pre></td></tr></table></figure><h3 id="博客标题"><a href="#博客标题" class="headerlink" title="博客标题"></a>博客标题</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">博客标题</span><br></code></pre></td></tr></table></figure><h3 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;links&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/links/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-link-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li>key: 用于关联有语言配置，如不存在关联则显示 key 本身的值</li><li>link: 跳转链接</li><li>icon: 图标的 css class，可以省略（即没有图标），主题内置图标详见这里</li><li>name: 强制使用此名称显示（不再按语言配置显示），可省略</li></ul><p>另外支持二级菜单（下拉菜单），配置写法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;文档&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-books&#x27;</span>,<br>      <span class="hljs-attr">submenu:</span> [<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;主题博客&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;配置指南&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/guide/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;图标用法&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/icon/&#x27;</span> &#125;<br>      ]<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="全局字体"><a href="#全局字体" class="headerlink" title="全局字体"></a>全局字体</h3><p>设置单独的页面，可以直接在 markdown 里通过 style 标签实现：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">&lt;style&gt;</span><br>  <span class="hljs-string">/*</span> <span class="hljs-string">设置整个页面的字体</span> <span class="hljs-string">*/</span><br>  <span class="hljs-string">html,</span> <span class="hljs-string">body,</span> <span class="hljs-string">.markdown-body</span> &#123;<br>    <span class="hljs-attr">font-family:</span> <span class="hljs-string">KaiTi</span>,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,<span class="hljs-string">Georgia</span>, <span class="hljs-string">sans</span>, <span class="hljs-string">serif;</span><br>    <span class="hljs-attr">font-size:</span> <span class="hljs-string">15px;</span><br>  &#125;<br><br>  <span class="hljs-string">/*</span> <span class="hljs-string">只设置</span> <span class="hljs-string">markdown</span> <span class="hljs-string">字体</span> <span class="hljs-string">*/</span><br>  <span class="hljs-string">.markdown-body</span> &#123;<br>    <span class="hljs-attr">font-family:</span> <span class="hljs-string">KaiTi</span>,<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>,<span class="hljs-string">Georgia</span>, <span class="hljs-string">sans</span>, <span class="hljs-string">serif;</span><br>    <span class="hljs-attr">font-size:</span> <span class="hljs-string">15px;</span><br>  &#125;<br><span class="hljs-string">&lt;/style&gt;</span><br></code></pre></td></tr></table></figure><h3 id="强制全局-HTTPS"><a href="#强制全局-HTTPS" class="headerlink" title="强制全局 HTTPS"></a>强制全局 HTTPS</h3><p>这种情况可以在主题配置中开启此配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">force_https:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="自定义-JS-x2F-CSS-x2F-HTML"><a href="#自定义-JS-x2F-CSS-x2F-HTML" class="headerlink" title="自定义 JS &#x2F; CSS &#x2F; HTML"></a>自定义 JS &#x2F; CSS &#x2F; HTML</h3><p>如果你想引入外部的 JS、CSS（比如 IconFont）或 HTML，可以通过以下主题配置，具体见注释：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 指定自定义 js 文件路径，路径是相对 source 目录</span><br><span class="hljs-attr">custom_js:</span> <span class="hljs-string">/js/custom.js</span><br><br><span class="hljs-comment"># 指定自定义 css 文件路径，路径是相对 source 目录</span><br><span class="hljs-attr">custom_css:</span> <span class="hljs-string">/css/custom.css</span><br><br><span class="hljs-comment"># 自定义 &lt;head&gt; 节点中的 HTML 内容</span><br><span class="hljs-attr">custom_head:</span> <span class="hljs-string">&#x27;&lt;meta name=&quot;key&quot; content=&quot;value&quot;&gt;&#x27;</span><br><br><span class="hljs-comment"># 自定义底部 HTML 内容（位于 footer 上方），也可用于外部引入 js css 这些操作，注意不要和 post.custom 配置冲突</span><br><span class="hljs-attr">custom_html:</span> <span class="hljs-string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css&quot;&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Slogan-打字机"><a href="#Slogan-打字机" class="headerlink" title="Slogan(打字机)"></a>Slogan(打字机)</h3><p>标题文字默认开启了打字机动效，相关配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">fun_features:</span><br>  <span class="hljs-attr">typing:</span> <span class="hljs-comment"># 为 subtitle 添加打字机效果</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typeSpeed:</span> <span class="hljs-number">70</span> <span class="hljs-comment"># 打印速度</span><br>    <span class="hljs-attr">cursorChar:</span> <span class="hljs-string">&quot;_&quot;</span> <span class="hljs-comment"># 游标字符</span><br>    <span class="hljs-attr">loop:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否循环播放效果</span><br></code></pre></td></tr></table></figure><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>若要手动指定摘要，使用 <!-- more --> MD文档里划分，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文的一部分作为摘要</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">余下的正文</span><br></code></pre></td></tr></table></figure><p>或者在 Front-matter 里设置 excerpt 字段，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ul><li>无论哪种摘要都最多显示 3 行，当屏幕宽度不足时会隐藏部分摘要。</li></ul><h3 id="文章跳转方式"><a href="#文章跳转方式" class="headerlink" title="文章跳转方式"></a>文章跳转方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_blank</span><br></code></pre></td></tr></table></figure><ul><li>_blank：新标签页打开</li><li>_self：当前标签页打开</li></ul><h3 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h3><p>如果想把某些文章隐藏起来，不在首页和其他分类里展示，可以在文章开头 Front-matter 中配置 hide: true 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><ul><li>隐藏会使文章在分类和标签类里都不显示</li><li>隐藏后依然可以通过文章链接访问</li></ul><h3 id="文章排序"><a href="#文章排序" class="headerlink" title="文章排序"></a>文章排序</h3><p>如果想手动将某些文章固定在首页靠前的位置，在文章开头 Front-matter 中配置 sticky 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><ul><li>sticky 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</li></ul><h3 id="文章在首页的封面图"><a href="#文章在首页的封面图" class="headerlink" title="文章在首页的封面图"></a>文章在首页的封面图</h3><p>对于单篇文章，在文章开头 Front-matter 中配置 index_img 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h3 id="文章页顶部大图"><a href="#文章页顶部大图" class="headerlink" title="文章页顶部大图"></a>文章页顶部大图</h3><p>默认显示主题配置中的 post.banner_img，如需要设置单个文章的 Banner，在 Front-matter 中指定 banner_img 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-24 00:00:00</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h3 id="文章内容本地图片"><a href="#文章内容本地图片" class="headerlink" title="文章内容本地图片"></a>文章内容本地图片</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-type">![](/img/example.jpg)</span><br></code></pre></td></tr></table></figure><h3 id="日期-x2F-字数-x2F-阅读时长-x2F-阅读数"><a href="#日期-x2F-字数-x2F-阅读时长-x2F-阅读数" class="headerlink" title="日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数"></a>日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数</h3><p>显示在文章页大标题下的文章信息，除了作者和阅读次数，其他功能都是默认开启的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">author:</span>  <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">date:</span>  <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;dddd, MMMM Do YYYY, h:mm a&quot;</span>  <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-attr">wordcount:</span>  <span class="hljs-comment"># 字数统计</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">min2read:</span>  <span class="hljs-comment"># 阅读时间</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span><br>    <span class="hljs-attr">views:</span>  <span class="hljs-comment"># 阅读次数</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span>  <span class="hljs-comment"># 统计数据来源，可选：leancloud | busuanzi   注意不蒜子会间歇抽风</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br></code></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>将脚注写在文末，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文</span><br><br><span class="hljs-comment">## 参考</span><br>[<span class="hljs-string">^1</span>]<span class="hljs-string">:</span> <span class="hljs-string">参考资料1</span><br>[<span class="hljs-string">^2</span>]<span class="hljs-string">:</span> <span class="hljs-string">参考资料2</span><br></code></pre></td></tr></table></figure><h3 id="Tag-插件"><a href="#Tag-插件" class="headerlink" title="Tag 插件"></a>Tag 插件</h3><p>在 markdown 中加入如下的代码来使用便签</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br><br>使用时 &#123;% note primary %&#125; 和 &#123;% endnote %&#125; 需单独一行，否则会出现问题<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-info">info</p><p class="note note-light">light</p><h3 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h3><p>在 markdown 中加入如下的代码来使用 Label：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% label primary @text %&#125;<br><br>若使用 &#123;% label primary @text %&#125;，text 不能以 @ 开头<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;label label-primary&quot;</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span class="label label-primary">primary</span> <span class="label label-default">default</span> <span class="label label-info">info</span> <span class="label label-success">success</span> <span class="label label-warning">warning</span> <span class="label label-danger">danger</span></p><h3 id="组图"><a href="#组图" class="headerlink" title="组图"></a>组图</h3><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% gi total n1-n2-... %&#125;<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>&#123;% endgi %&#125;<br><br>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-...：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式<br>如下图为 &#123;% gi 5 3-2 %&#125; 示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。<br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/avatar.png"></div><div class="group-image-wrap"><img src="/img/avatar.png"></div></div></div><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>标签是以词云的形式展示，标签的大小和颜色会根据标签下的文章数量变化，相关配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tag:</span><br>  <span class="hljs-attr">tagcloud:</span><br>    <span class="hljs-attr">min_font:</span> <span class="hljs-number">15</span><br>    <span class="hljs-attr">max_font:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">unit:</span> <span class="hljs-string">px</span>  <span class="hljs-comment"># 字号单位</span><br>    <span class="hljs-attr">start_color:</span> <span class="hljs-string">&quot;#BBBBEE&quot;</span><br>    <span class="hljs-attr">end_color:</span> <span class="hljs-string">&quot;#337ab7&quot;</span><br></code></pre></td></tr></table></figure><h3 id="友情链接页"><a href="#友情链接页" class="headerlink" title="友情链接页"></a>友情链接页</h3><p>友情链接页用于展示好友的博客入口，默认关闭，开启需要先在 navbar 项中将 links 的注释(#号)删掉：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;links&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/links/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-link-fill&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>然后找到 links 的配置项，对页面内容进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">links:</span><br>  <span class="hljs-attr">items:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Fluid Docs&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;主题使用指南&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;/img/favicon.png&#x27;</span><br>    &#125;<br>  <span class="hljs-attr">default_avatar:</span> <span class="hljs-string">/img/avatar.png</span><br></code></pre></td></tr></table></figure><ul><li>title: 友链站的标题</li><li>intro: 站点或博主的简介，可省略</li><li>link: 跳转链接</li><li>avatar: 头像图片，可省略</li><li>default_avatar: 成员的默认头像（仅在指定了头像并且加载失败时生效）</li></ul><p>友链页也可以使用自定义区域和评论，使用方式类似于文章页，具体见配置项与相关注释。</p><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><p>如果想单独生成一个页面，步骤和创建「关于页」类似<br>先用命令行创建页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page example<br></code></pre></td></tr></table></figure><p>创建成功后编辑博客目录下 &#x2F;source&#x2F;example&#x2F;index.md：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">若不填默认是</span> <span class="hljs-string">title</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p>正文默认没有 Markdown 样式，如果希望和文章相同的样式，可以加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;markdown-body&quot;</span>&gt;</span><br>正文<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面的参数配置可以在主题配置中统一设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">page:<br>  banner_img: /img/default.png<br>  banner_img_height: 70<br>  banner_mask_alpha: 0.3<br></code></pre></td></tr></table></figure><p>也可以直接在 Front-matter 里单独设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br><span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br><span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.5</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里可以写正文</span><br></code></pre></td></tr></table></figure><h3 id="Fluid-注入代码"><a href="#Fluid-注入代码" class="headerlink" title="Fluid 注入代码"></a>Fluid 注入代码</h3><p>进入博客目录下 scripts 文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">filter</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">injects</span>) &#123;<br>  injects.<span class="hljs-property">header</span>.<span class="hljs-title function_">file</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;source/_inject/test1.ejs&#x27;</span>, &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;, -<span class="hljs-number">1</span>);<br>  injects.<span class="hljs-property">footer</span>.<span class="hljs-title function_">raw</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;&lt;script async src=&quot;https://xxxxxx&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>header 和 footer 是注入点的名称，表示代码注入到页面的什么位置；</li><li>file 方法表示注入的是文件，第一个参数下面介绍，第二个参数则是文件的路径，第三个参数是传入文件的参数（可省略），第四个参数是顺序（可省略）；</li><li>raw 方法表示注入的是原生代码，第一个参数下面介绍，第二个参数则是一句原生的 HTML 语句；</li><li>default 表示注入的键名，可以使用任意键名，同一个注入点下的相同键名会使注入的内容覆盖，而不同键名则会让内容依次排列（默认按执行先后顺序，可通过 file 第四个参数指定），这里 default 为主题默认键名，通常会替换掉主题默认的组件；</li></ul><p>主题目前提供的注入点如下：</p><table><thead><tr><th>注入点名称</th><th>注入范围</th><th>存在 <code>default</code> 键</th></tr></thead><tbody><tr><td>head</td><td><code>&lt;head&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>header</td><td><code>&lt;header&gt;</code> 标签中所有内容</td><td>有</td></tr><tr><td>bodyBegin</td><td><code>&lt;body&gt;</code> 标签中的开始</td><td>无</td></tr><tr><td>bodyEnd</td><td><code>&lt;body&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>footer</td><td><code>&lt;footer&gt;</code> 标签中所有内容</td><td>有</td></tr><tr><td>postMetaTop</td><td>文章页 <code>&lt;header&gt;</code> 标签中 meta 部分内容</td><td>有</td></tr><tr><td>postMetaBottom</td><td>文章页底部 meta 部分内容</td><td>有</td></tr><tr><td>postMarkdownBegin</td><td><code>&lt;div class=&quot;markdown-body&quot;&gt;</code> 标签中的开始</td><td>无</td></tr><tr><td>postMarkdownEnd</td><td><code>&lt;div class=&quot;markdown-body&quot;&gt;</code> 标签中的结尾</td><td>无</td></tr><tr><td>postLeft</td><td>文章页左侧边栏</td><td>有</td></tr><tr><td>postRight</td><td>文章页右侧边栏</td><td>有</td></tr><tr><td>postCopyright</td><td>文章页版权信息</td><td>有</td></tr><tr><td>postRight</td><td>文章页右侧边栏</td><td>无</td></tr><tr><td>postComments</td><td>文章页评论</td><td>有</td></tr><tr><td>pageComments</td><td>自定义页评论</td><td>有</td></tr><tr><td>linksComments</td><td>友链页评论</td><td>有</td></tr></tbody></table><p><strong>参考资料</strong><br><a href="https://github.com/fluid-dev/hexo-theme-fluid">Hexo Fluid GitHub</a><br><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
